(()=>{var __create=Object.create;var __defProp=Object.defineProperty;var __getOwnPropDesc=Object.getOwnPropertyDescriptor;var __getOwnPropNames=Object.getOwnPropertyNames;var __getProtoOf=Object.getPrototypeOf;var __hasOwnProp=Object.prototype.hasOwnProperty;var __commonJS=(cb,mod)=>function __require(){return mod||(0,cb[__getOwnPropNames(cb)[0]])((mod={exports:{}}).exports,mod),mod.exports};var __export=(target,all)=>{for(var name in all)__defProp(target,name,{get:all[name],enumerable:true})};var __copyProps=(to,from,except,desc)=>{if(from&&typeof from==="object"||typeof from==="function"){for(let key of __getOwnPropNames(from))if(!__hasOwnProp.call(to,key)&&key!==except)__defProp(to,key,{get:()=>from[key],enumerable:!(desc=__getOwnPropDesc(from,key))||desc.enumerable})}return to};var __toESM=(mod,isNodeMode,target)=>(target=mod!=null?__create(__getProtoOf(mod)):{},__copyProps(isNodeMode||!mod||!mod.__esModule?__defProp(target,"default",{value:mod,enumerable:true}):target,mod));var require_objectid=__commonJS({"node_modules/bson-objectid/objectid.js"(exports,module){var MACHINE_ID=Math.floor(Math.random()*16777215);var index=ObjectID2.index=parseInt(Math.random()*16777215,10);var pid=(typeof process==="undefined"||typeof process.pid!=="number"?Math.floor(Math.random()*1e5):process.pid)%65535;var BufferCtr=(()=>{try{return _Buffer}catch(_2){try{return Buffer}catch(_3){return null}}})();var isBuffer=function(obj){return!!(obj!=null&&obj.constructor&&typeof obj.constructor.isBuffer==="function"&&obj.constructor.isBuffer(obj))};var hexTable=[];for(i=0;i<256;i++){hexTable[i]=(i<=15?"0":"")+i.toString(16)}var i;var checkForHexRegExp=new RegExp("^[0-9a-fA-F]{24}$");var decodeLookup=[];i=0;while(i<10)decodeLookup[48+i]=i++;while(i<16)decodeLookup[65-10+i]=decodeLookup[97-10+i]=i++;function ObjectID2(id){if(!(this instanceof ObjectID2))return new ObjectID2(id);if(id&&(id instanceof ObjectID2||id._bsontype==="ObjectID"))return id;this._bsontype="ObjectID";if(id==null||typeof id==="number"){this.id=this.generate(id);return}var valid=ObjectID2.isValid(id);if(!valid&&id!=null){throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters")}else if(valid&&typeof id==="string"&&id.length===24){return ObjectID2.createFromHexString(id)}else if(id!=null&&id.length===12){this.id=id}else if(id!=null&&typeof id.toHexString==="function"){return id}else{throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters")}}module.exports=ObjectID2;ObjectID2.default=ObjectID2;ObjectID2.createFromTime=function(time){time=parseInt(time,10)%4294967295;return new ObjectID2(hex(8,time)+"0000000000000000")};ObjectID2.createFromHexString=function(hexString){if(typeof hexString==="undefined"||hexString!=null&&hexString.length!==24){throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters")}var data="";var i2=0;while(i2<24){data+=String.fromCharCode(decodeLookup[hexString.charCodeAt(i2++)]<<4|decodeLookup[hexString.charCodeAt(i2++)])}return new ObjectID2(data)};ObjectID2.isValid=function(id){if(id==null)return false;if(typeof id==="number"){return true}if(typeof id==="string"){return id.length===12||id.length===24&&checkForHexRegExp.test(id)}if(id instanceof ObjectID2){return true}if(isBuffer(id)){return ObjectID2.isValid(id.toString("hex"))}if(typeof id.toHexString==="function"){if(BufferCtr&&(id.id instanceof BufferCtr||typeof id.id==="string")){return id.id.length===12||id.id.length===24&&checkForHexRegExp.test(id.id)}}return false};ObjectID2.prototype={constructor:ObjectID2,toHexString:function(){if(!this.id||!this.id.length){throw new Error("invalid ObjectId, ObjectId.id must be either a string or a Buffer, but is ["+JSON.stringify(this.id)+"]")}if(this.id.length===24){return this.id}if(isBuffer(this.id)){return this.id.toString("hex")}var hexString="";for(var i2=0;i2<this.id.length;i2++){hexString+=hexTable[this.id.charCodeAt(i2)]}return hexString},equals:function(otherId){if(otherId instanceof ObjectID2){return this.toString()===otherId.toString()}else if(typeof otherId==="string"&&ObjectID2.isValid(otherId)&&otherId.length===12&&isBuffer(this.id)){return otherId===this.id.toString("binary")}else if(typeof otherId==="string"&&ObjectID2.isValid(otherId)&&otherId.length===24){return otherId.toLowerCase()===this.toHexString()}else if(typeof otherId==="string"&&ObjectID2.isValid(otherId)&&otherId.length===12){return otherId===this.id}else if(otherId!=null&&(otherId instanceof ObjectID2||otherId.toHexString)){return otherId.toHexString()===this.toHexString()}else{return false}},getTimestamp:function(){var timestamp=new Date;var time;if(isBuffer(this.id)){time=this.id[3]|this.id[2]<<8|this.id[1]<<16|this.id[0]<<24}else{time=this.id.charCodeAt(3)|this.id.charCodeAt(2)<<8|this.id.charCodeAt(1)<<16|this.id.charCodeAt(0)<<24}timestamp.setTime(Math.floor(time)*1e3);return timestamp},generate:function(time){if("number"!==typeof time){time=~~(Date.now()/1e3)}time=parseInt(time,10)%4294967295;var inc=next();return String.fromCharCode(time>>24&255,time>>16&255,time>>8&255,time&255,MACHINE_ID>>16&255,MACHINE_ID>>8&255,MACHINE_ID&255,pid>>8&255,pid&255,inc>>16&255,inc>>8&255,inc&255)}};function next(){return index=(index+1)%16777215}function hex(length,n){n=n.toString(16);return n.length===length?n:"00000000".substring(n.length,length)+n}var inspect=Symbol&&Symbol.for&&Symbol.for("nodejs.util.inspect.custom")||"inspect";ObjectID2.prototype[inspect]=function(){return"ObjectID("+this+")"};ObjectID2.prototype.toJSON=ObjectID2.prototype.toHexString;ObjectID2.prototype.toString=ObjectID2.prototype.toHexString}});var DataStructures_exports={};__export(DataStructures_exports,{AuthorizationStruct:()=>AuthorizationStruct,ChatroomStruct:()=>ChatroomStruct,CoherenceMap:()=>CoherenceMap,CoherenceStruct:()=>CoherenceStruct,CommentStruct:()=>CommentStruct,Data:()=>Data,DataStruct:()=>DataStruct,DateStruct:()=>DateStruct,ECGStruct:()=>ECGStruct,EDAStruct:()=>EDAStruct,EEGCoordinates:()=>EEGCoordinates,EEGStruct:()=>EEGStruct,EMGStruct:()=>EMGStruct,EventStruct:()=>EventStruct,EyeTrackerStruct:()=>EyeTrackerStruct,FNIRSStruct:()=>FNIRSStruct,FrequencyBandsStruct:()=>FrequencyBandsStruct,GroupStruct:()=>GroupStruct,HRVStruct:()=>HRVStruct,IMUStruct:()=>IMUStruct,NotificationStruct:()=>NotificationStruct,PPGStruct:()=>PPGStruct,ProfileStruct:()=>ProfileStruct,ScheduleStruct:()=>ScheduleStruct,Struct:()=>Struct,eegCoordinates:()=>eegCoordinates,setCoordinate:()=>setCoordinate,structRegistry:()=>structRegistry});function Struct(structType="struct",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){function randomId3(tag=""){return`${tag+Math.floor(Math.random()+Math.random()*Math.random()*1e16)}`}let struct={_id:randomId3(structType+"defaultId"),structType,ownerId:parentUser?._id,timestamp:Date.now(),parent:{structType:parentStruct?.structType,_id:parentStruct?._id}};if(!struct.ownerId)delete struct.ownerId;if(!struct?.parent?._id)delete struct.parent;if(Object.keys(assignProps).length>0)Object.assign(struct,assignProps);return struct}var eegCoordinates={FP1:[-21.2,66.9,12.1],FPZ:[1.4,65.1,11.3],FP2:[24.3,66.3,12.5],AF7:[-41.7,52.8,11.3],AF3:[-32.7,48.4,32.8],AFZ:[1.8,54.8,37.9],AF4:[35.1,50.1,31.1],AF8:[43.9,52.7,9.3],F5:[-51.4,26.7,24.7],F3:[-39.7,25.3,44.7],F1:[-22.1,26.8,54.9],FZ:[0,26.8,60.6],F2:[23.6,28.2,55.6],F4:[41.9,27.5,43.9],F6:[52.9,28.7,25.2],F7:[-52.1,28.6,3.8],F8:[53.2,28.4,3.1],FC5:[-59.1,3,26.1],FC3:[-45.5,2.4,51.3],FC1:[-24.7,.3,66.4],FCZ:[1,1,72.8],FC2:[26.1,3.2,66],FC4:[47.5,4.6,49.7],FC6:[60.5,4.9,25.5],FT9:[-53.8,-2.1,-29.1],FT7:[-59.2,3.4,-2.1],FT8:[60.2,4.7,-2.8],FT10:[55,-3.6,-31],T7:[-65.8,-17.8,-2.9],T5:[-61.5,-65.3,1.1],T3:[-70.2,-21.3,-10.7],T4:[71.9,-25.2,-8.2],T6:[59.3,-67.6,3.8],T8:[67.4,-18.5,-3.4],C5:[-63.6,-18.9,25.8],C3:[-49.1,-20.7,53.2],C1:[-25.1,-22.5,70.1],CZ:[.8,-21.9,77.4],C2:[26.7,-20.9,69.5],C4:[50.3,-18.8,53],C6:[65.2,-18,26.4],CP5:[-61.8,-46.2,22.5],CP3:[-46.9,-47.7,49.7],CP1:[-24,-49.1,66.1],CPZ:[.7,-47.9,72.6],CP2:[25.8,-47.1,66],CP4:[49.5,-45.5,50.7],CP6:[62.9,-44.6,24.4],TP9:[-73.6,-46.7,-4],TP7:[-63.6,-44.7,-4],TP8:[64.6,-45.4,-3.7],TP10:[74.6,-47.4,-3.7],P9:[-50.8,-51.3,-37.7],P7:[-55.9,-64.8,0],P5:[-52.7,-67.1,19.9],P3:[-41.4,-67.8,42.4],P1:[-21.6,-71.3,52.6],PZ:[.7,-69.3,56.9],P2:[24.4,-69.9,53.5],P4:[44.2,-65.8,42.7],P6:[54.4,-65.3,20.2],P8:[56.4,-64.4,.1],P10:[51,-53.9,-36.5],PO7:[-44,-81.7,1.6],PO3:[-33.3,-84.3,26.5],POZ:[0,-87.9,33.5],PO4:[35.2,-82.6,26.1],PO8:[43.3,-82,.7],O1:[-25.8,-93.3,7.7],OZ:[.3,-97.1,8.7],O2:[25,-95.2,6.2]};function setCoordinate(channelDict,assignTo={}){if(!eegCoordinates[channelDict.tag]&&channelDict.position){eegCoordinates[channelDict.tag]=[channelDict.position.x,channelDict.position.y,channelDict.position.z]}if(eegCoordinates[channelDict.tag]){let props={channel:"",position:{x:eegCoordinates[channelDict.tag][0],y:eegCoordinates[channelDict.tag][1],z:eegCoordinates[channelDict.tag][2]}};return Object.assign(assignTo,props)}else return Object.assign(assignTo,channelDict)}function EEGCoordinates(channelDicts=[],genCoherenceMap=true){let structs=[];for(let channelDict of channelDicts){let struct=EEGStruct(channelDict);structs.push(struct)}if(genCoherenceMap){structs.push(...CoherenceMap({channelDicts}))}return structs}function FrequencyBandsStruct(additionalBands=[],assignTo={}){let bands={scp:[],delta:[],theta:[],alpha1:[],alpha2:[],beta:[],lowgamma:[],highgamma:[]};additionalBands.forEach(band=>bands[band]=[]);return Object.assign(assignTo,bands)}function EEGStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let bands=FrequencyBandsStruct();let props={tag,position:{x:0,y:0,z:0},count:0,times:[],raw:[],filtered:[],fftCount:0,fftTimes:[],ffts:[],slices:JSON.parse(JSON.stringify(bands)),means:JSON.parse(JSON.stringify(bands)),startTime:Date.now()};let struct=Struct("eeg",props,parentUser,parentStruct);if(tag)setCoordinate(props,struct);return Object.assign(struct,assignProps)}function CoherenceStruct(coords={0:EEGStruct("FP1"),1:EEGStruct("FP2")},assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let bands=FrequencyBandsStruct();let props={tag:coords[0]?.tag+"::"+coords[1]?.tag,x0:coords[0]?.position?.x,y0:coords[0]?.position?.y,z0:coords[0]?.position?.z,x1:coords[1]?.position?.x,y1:coords[1]?.position?.y,z1:coords[1]?.position?.z,fftCount:0,fftTimes:[],ffts:[],slices:JSON.parse(JSON.stringify(bands)),means:JSON.parse(JSON.stringify(bands)),startTime:Date.now()};let struct=Struct("coherence",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}function CoherenceMap(opts={channelDicts:[{ch:0,tag:"FP1",analyze:false},{ch:1,tag:"FP2",analyze:false}],taggedOnly:true},_2={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){var cmap=[];var l=1,k=0;for(var i=0;i<opts.channelDicts.length*(opts.channelDicts.length+1)/2-opts.channelDicts.length;i++){if(opts.taggedOnly===false||opts.taggedOnly===true&&(opts.channelDicts[k].tag!==null&&opts.channelDicts[k+l].tag!==null&&(opts.channelDicts[k].tag!=="other"&&opts.channelDicts[k+l].tag!=="other")&&(opts.channelDicts[k].analyze===true&&opts.channelDicts[k+l].analyze===true))){var coord0=EEGStruct(opts.channelDicts[k].tag);var coord1=EEGStruct(opts.channelDicts[k+l].tag);cmap.push(CoherenceStruct({0:coord0,1:coord1},{},parentUser,parentStruct))}l++;if(l+k===opts.channelDicts.length){k++;l=1}}return cmap}function FNIRSStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,position:{x:0,y:0,z:0},count:0,times:[],red:[],ir:[],ir2:[],ambient:[],ratio:[],temp:[],beat_detect:{beats:[],breaths:[],rir:[],rir2:[],drir_dt:[],localmins:[],localmaxs:[],val_dists:[],peak_dists:[],localmins2:[],localmaxs2:[],val_dists2:[],peak_dists2:[]},startTime:Date.now()};let struct=Struct("fnirs",props,parentUser,parentStruct);if(tag)setCoordinate(props,struct);return Object.assign(struct,assignProps)}function IMUStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,Ax:[],Ay:[],Az:[],Gx:[],Gy:[],Gz:[],startTime:Date.now()};let struct=Struct("imu",props,parentUser,parentStruct);if(tag)setCoordinate(props,struct);return Object.assign(struct,assignProps)}function EyeTrackerStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,count:0,times:[],x:[],y:[],smax:[],smay:[],startTime:Date.now()};let struct=Struct("eyetracker",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}function ECGStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,count:0,times:[],raw:[],filtered:[],bpm:[],hrv:[],startTime:Date.now()};let struct=Struct("ecg",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}function EDAStruct(_2="",__={},___={_id:""},____={structType:"struct",_id:""}){}function PPGStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let struct=FNIRSStruct(tag,parentUser,parentStruct,assignProps);struct.structType="ppg";return struct}function HRVStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let struct=ECGStruct(tag,parentUser,parentStruct,assignProps);struct.structType="hrv";return struct}function EMGStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let struct=EEGStruct(tag,parentUser,parentStruct,assignProps);struct.structType="emg";return struct}function ProfileStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,name:"",username:"",firstName:"",lastName:"",email:"",phone:"",sex:"",birthday:"",type:"",userRoles:{},socials:{},data:{},id:""};let struct=Struct("profile",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}function AuthorizationStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,authorizedId:"",authorizedName:"",authorizerId:"",authorizerName:"",authorizations:{},structs:{},excluded:{},groups:{},status:"PENDING",expires:false,associatedAuthId:""};let struct=Struct("authorization",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}function GroupStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,name:"",details:"",admins:{},peers:{},clients:{},users:{}};let struct=Struct("group",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}function Data(type,data){return{type,data,timestamp:Date.now()}}function DataStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,title:"",author:"",expires:false,type:"",data:new Array};let struct=Struct("data",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}function EventStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,event:"",author:"",startTime:"",endTime:"",grade:0,notes:"",attachments:new Array,users:{}};let struct=Struct("event",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}function ChatroomStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,message:"",topic:"",author:"",attachments:new Array,comments:new Array,replies:new Array,users:{},audioChatActive:false,videoChatActive:false};let struct=Struct("chatroom",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}function CommentStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,author:"",replyTo:"",message:"",rating:0,replies:new Array,users:{},attachments:new Array};let struct=Struct("comment",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}function NotificationStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,note:"",parentUserId:""};let struct=Struct("notification",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}function ScheduleStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,title:"",author:"",attachments:new Array,dates:new Array};let struct=Struct("schedule",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}function DateStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,timeSet:"",notes:"",recurs:"NEVER",attachments:new Array};let struct=Struct("date",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}var structRegistry={Struct,EEGStruct,FNIRSStruct,CoherenceStruct,CoherenceMap,FrequencyBandsStruct,IMUStruct,EyeTrackerStruct,ECGStruct,EDAStruct,PPGStruct,HRVStruct,EMGStruct,ProfileStruct,AuthorizationStruct,GroupStruct,DataStruct,EventStruct,ChatroomStruct,CommentStruct,NotificationStruct,ScheduleStruct,DateStruct};var DataTablet=class{constructor(props={}){this.DS=DataStructures_exports;this.collections=new Map;this.data={byTime:{},notes:{},events:{},sleep:{},food:{},rx:{},hr:{},ppg:{},hrv:{},ecg:{},emg:{},eeg:{},fnirs:{}};this.rolloverLimit=5e4;this.dataSorts=new Map;this.watches={};this.onCollectionSet=(type,collection)=>{};Object.assign(this.data,props);this.dataSorts=new Map;this.watches={};this.setSort("event",dataObj=>{if(!this.data.events[dataObj.timestamp])this.data.events[dataObj.timestamp]=[dataObj];else this.data.events[dataObj.timestamp].push(dataObj);if(dataObj.event==="sleep"){if(!this.data.sleep[dataObj.timestamp])this.data.sleep[dataObj.timestamp]=[dataObj];else this.data.sleep[dataObj.timestamp].push(dataObj)}return dataObj});this.setSort(["notes","note","link"],dataObj=>{if(!this.data.notes[dataObj.timestamp])this.data.notes[dataObj.timestamp]=[dataObj];else this.data.notes[dataObj.timestamp].push(dataObj);if(!this.data.byTime[dataObj.timestamp])this.data.byTime[dataObj.timestamp]=[dataObj];else this.data.byTime[dataObj.timestamp].push(dataObj);return dataObj});this.id=this.randomId("dataTablet")}randomId(tag=""){return`${tag+Math.floor(Math.random()+Math.random()*Math.random()*1e16)}`}setLocalData(structs){let setInCollection=s=>{let type=s.structType;let collection=this.collections.get(type);if(!collection){collection=new Map;this.collections.set(type,collection)}collection.set(s._id,s);this.onCollectionSet(type,collection)};if(Array.isArray(structs)){structs.forEach(s=>{setInCollection(s)})}else setInCollection(structs)}getLocalData(collection,query){let ownerId="";let key="";let value="";if(typeof query==="object"){ownerId=query.ownerId;const keys=Object.keys(query).filter(k=>k!="ownerId");key=keys[0];value=query[key]}else value=query;if(!collection&&!ownerId&&!key&&!value)return[];let result=[];if(!collection&&(ownerId||key)){this.collections.forEach(c=>{if((key==="_id"||key==="id")&&value){let found=c.get(value);if(found)result.push(found)}else{c.forEach(struct=>{if(key&&value){if(struct[key]===value&&struct.ownerId===ownerId){result.push(struct)}}else if(struct.ownerId===ownerId){result.push(struct)}})}});return result}else{let c=this.collections.get(collection);if(!c)return result;if(!key&&!ownerId){c.forEach(struct=>{result.push(struct)});return result}if((key==="_id"||key==="id")&&value)return c.get(value);else{c.forEach((struct,_2)=>{if(key&&value&&!ownerId){if(struct[key]===value)result.push(struct)}else if(ownerId&&!key){if(struct.ownerId===ownerId)result.push(struct)}else if(ownerId&&key&&value){if(struct.ownerId===ownerId&&struct[key]){if(struct[key]===value)result.push(struct)}}})}}return result}runSort(key,dataObj={},newdata=[],tablet=this){let result;let sort=this.getSort(key);if(sort)result=sort(dataObj,newdata,tablet);else return false;return result}setSort(key,response=(data,newdata=[],tablet=this)=>{}){if(Array.isArray(key))key.forEach(k=>{this.dataSorts.set(k,response)});else this.dataSorts.set(key,response)}getSort(key){return this.dataSorts.get(key)}checkWatches(sorted={}){for(const prop in this.watches){let triggered=this.watches[prop].ondata(sorted,this.watches[prop].accum,this.watches[prop].ownerId);if(triggered){this.watches[prop].ontrigger(this.watches[prop].accum);this.watches[prop].triggered=false}}}setWatch(name,ownerId,ondata=(sorted,accum,ownerId2)=>{if(sorted.ownerId===ownerId2)accum.data[sorted._id]=sorted;if(Object.keys(accum.data).length>10){return true}else return false},ontrigger=accum=>{console.log(accum);let alert=Struct("alert",{alert:true,data:accum},{_id:accum[Object.keys(accum)[0]].ownerId});accum={}}){this.watches[name]={accum:{},ownerId,ondata,ontrigger}}getWatch(name){return this.watches[name]}async sortStructsIntoTable(datastructs=[]){let ascending=function(a,b2){if(a.timestamp&&b2.timestamp)return a.timestamp-b2.timestamp};datastructs.sort(ascending);let newdata=[];for(let i=0;i<datastructs.length;i++){let struct=datastructs[i];if(!struct.timestamp)continue;let timestamp=struct.timestamp;if(!this.data.byTime[timestamp])this.data.byTime[timestamp]=[struct];else this.data.byTime[timestamp].push(struct);if(struct.structType==="data"&&struct.data){struct.data.forEach(async dat=>{if(typeof dat==="object"&&!Array.isArray(dat)){let typ=dat.dataType;dat.ownerId=struct.ownerId;if(!dat.timestamp)dat.timestamp=timestamp;if(typ){let sorted=this.runSort(typ,dat,newdata,this);if(!sorted){if(!this.data[typ])this.data[typ]={};dat.timestamp=timestamp;if(!this.data[typ][timestamp])this.data[typ][timestamp]=[dat];else this.data[typ][timestamp].push(dat);if(!this.data.byTime[timestamp])this.data.byTime[timestamp]=[dat];else this.data.byTime[timestamp].push(dat);this.checkWatches(dat);this.onUpdate(timestamp,dat);newdata.push(dat)}else{if(sorted.constructor?.name!=="Promise"){this.checkWatches(sorted);this.onUpdate(timestamp,sorted);newdata.push(sorted)}}}}})}else{let sorted=this.runSort(struct.structType,struct,newdata,this);if(!sorted){let typ=struct.structType;if(!this.data[typ])this.data[typ]={};if(!this.data[typ][timestamp])this.data[typ][timestamp]=[struct];else this.data[typ][timestamp].push(struct);this.checkWatches(struct);this.onUpdate(timestamp,struct);newdata.push(struct)}else{this.checkWatches(sorted);this.onUpdate(timestamp,sorted);newdata.push(sorted)}}}for(const prop in this.data){this.data[prop]=this.sortObjectByPropName(this.data[prop])}this.onSorted(newdata)}onUpdate(_2,__,___=this.data){}onSorted(_2=[]){}getDataByTimestamp(timestamp,ownerId){let result=this.data.byTime[timestamp];if(ownerId&&result)result=result.filter(o=>{if(!ownerId)return true;else if(ownerId===o.ownerId)return true;else return false});return result}getDataByTimeRange(begin,end,type,ownerId){let result={};if(type){for(const key in this.data[type]){let t=parseInt(key);if(t>begin&&t<end){result[key]=[...this.data[type][key]]}}if(type==="sleep"){result=this.filterSleepResults(result)}}else{for(const key in this.data.byTime){let t=parseInt(key);if(t>begin&&t<end){result[key]=[...this.data.byTime[key]]}}}if(ownerId&&result){for(const key in result){let popidx=[];result[key]=result[key];result[key].forEach((o,i)=>{if(o.ownerId!==ownerId){popidx.push(i)}});popidx.reverse().forEach(idx=>{result[key].splice(idx,1)});if(result[key].length===0)delete result[key]}}return result}getDataByType(type,timestamp,ownerId){if(!this.data[type])return void 0;let result={...this.data[type]};if(timestamp)result=[...result[timestamp]];if(ownerId&&result){for(const key in result){let popidx=[];result[key]=[...result[key]];result[key].forEach((o,i)=>{if(o.ownerId!==ownerId){popidx.push(i)}});popidx.reverse().forEach(idx=>{result[key].splice(idx,1)});if(result[key].length===0)delete result[key]}}if(type==="sleep"){result=this.filterSleepResults(result)}return result}filterSleepResults(unfiltered={}){let events=[];for(const key in unfiltered){unfiltered[key]=[...unfiltered[key]];events.push(...unfiltered[key].filter(o=>{if(o.structType==="event")return true;else return false}))}events.forEach(ev2=>{let foundidx;for(const key in unfiltered){unfiltered[key].forEach((o,i)=>{if(o.structType==="fitbitsleep"&&ev2.startTime&&ev2.endTime){if(Math.abs(o.startTime-ev2.startTime)<1e3*12*3600&&Math.abs(o.endTime-ev2.endTime)<1e3*12*3600&&ev2.endTime-ev2.startTime>1e3*2*3600){foundidx=i;return true}else return false}else return false});if(foundidx)unfiltered[key].splice(foundidx,1)}});let result=unfiltered;return result}sortObjectByPropName(object){const ordered=Object.keys(object).sort().reduce((obj,key)=>{obj[key]=object[key];return obj},{});return ordered}checkRollover(collection,limit=this.rolloverLimit){if(!collection)return false;let c=this.collections.get(collection);if(!c)return false;c.forEach(struct=>{for(const prop in struct){if(Array.isArray(struct[prop])){if(struct[prop].length>limit){struct[prop].slice(struct[prop].length-limit);if(prop==="ffts"){struct.fftCount=struct[prop].length}else if(prop==="times"){struct.count=struct[prop].length}}}else if(typeof struct[prop]==="object"){this.checkRollover(struct[prop])}}});return true}};var EventHandler=class{constructor(data){this.pushToState={};this.data={};this.triggers={};this.setState=updateObj=>{Object.assign(this.data,updateObj);for(const prop of Object.getOwnPropertyNames(updateObj)){if(this.triggers[prop])this.triggers[prop].forEach(obj=>obj.onchange(this.data[prop]))}return this.data};this.setValue=(key,value)=>{this.data[key]=value;if(this.triggers[key])this.triggers[key].forEach(obj=>obj.onchange(this.data[key]))};this.subscribeTrigger=(key,onchange)=>{if(key){if(!this.triggers[key]){this.triggers[key]=[]}let l=this.triggers[key].length;this.triggers[key].push({sub:l,onchange});return this.triggers[key].length-1}else return void 0};this.unsubscribeTrigger=(key,sub)=>{let triggers=this.triggers[key];if(triggers){if(!sub)delete this.triggers[key];else{let sub2=void 0;let obj=triggers.find((o,i)=>{if(o.sub===sub2){sub2=i;return true}});if(obj)triggers.splice(sub2,1);if(this.onRemoved)this.onRemoved(obj);return true}}};this.subscribeTriggerOnce=(key,onchange)=>{let sub;let changed=value=>{onchange(value);this.unsubscribeTrigger(key,sub)};sub=this.subscribeTrigger(key,changed)};this.getTrigger=(key,sub)=>{for(const s in this.triggers[key]){if(this.triggers[key][s].sub===sub)return this.triggers[key][s]}};if(typeof data==="object")this.data=data}};var state=new EventHandler;var GraphNode=class{constructor(properties,parent2,graph){this.__node={tag:`node${Math.floor(Math.random()*1e15)}`,unique:`${Math.random()}`,state};this.__subscribe=(callback,key,subInput,bound,target)=>{const subscribeToFunction=(k,setTarget=(callback2,target2)=>callback2,triggerCallback=callback)=>{let sub=this.__node.state.subscribeTrigger(k,triggerCallback);let trigger=this.__node.state.getTrigger(k,sub);trigger.source=this.__node.tag;if(key)trigger.key=key;trigger.target=setTarget(callback);if(bound)trigger.bound=bound;return sub};const subscribeToGraph=callback2=>{let fn=this.__node.graph.get(callback2);if(!fn&&callback2.includes(".")){let n=this.__node.graph.get(callback2.substring(0,callback2.lastIndexOf(".")));let key2=callback2.substring(callback2.lastIndexOf(".")+1);if(n&&typeof n[key2]==="function")callback2=(...args)=>{return n[key2](...args)}}};if(key){if(!this.__node.localState){this.__addLocalState(this)}if(typeof callback==="string"){if(typeof this[callback]==="function")callback=this[callback];else if(this.__node.graph)subscribeToGraph(callback)}let sub;let k=subInput?this.__node.unique+"."+key+"input":this.__node.unique+"."+key;if(typeof callback==="function")sub=subscribeToFunction(k);else if(callback?.__node)sub=subscribeToFunction(k,(callback2,target2)=>target2?target2:callback2.__node.unique,state2=>{if(callback.__operator)callback.__operator(state2)});return sub}else{if(typeof callback==="string"){if(this.__node.graph)callback=this.__node.graph.get(callback);else callback=this.__node.graph.nodes.get(callback)}let sub;let k=subInput?this.__node.unique+"input":this.__node.unique;if(typeof callback==="function")sub=subscribeToFunction(k);else if(callback?.__node)sub=subscribeToFunction(k,(callback2,target2)=>target2?target2:callback2.__node.unique,state2=>{if(callback.__operator)callback.__operator(state2)});return sub}};this.__unsubscribe=(sub,key,subInput)=>{if(key){return this.__node.state.unsubscribeTrigger(subInput?this.__node.unique+"."+key+"input":this.__node.unique+"."+key,sub)}else return this.__node.state.unsubscribeTrigger(subInput?this.__node.unique+"input":this.__node.unique,sub)};this.__setOperator=fn=>{fn=fn.bind(this);this.__operator=(...args)=>{if(this.__node.inputState)this.__node.state.setValue(this.__node.unique+"input",args);let result=fn(...args);if(this.__node.state.triggers[this.__node.unique]){if(typeof result?.then==="function"){result.then(res=>{if(res!==void 0)this.__node.state.setValue(this.__node.unique,res)}).catch(console.error)}else if(result!==void 0)this.__node.state.setValue(this.__node.unique,result)}return result};if(!this.__subscribedToParent){if(this.__parent instanceof GraphNode&&this.__parent.__operator){let sub=this.__parent.__subscribe(this);let ondelete=()=>{this.__parent?.__unsubscribe(sub);delete this.__subscribedToParent};this.__addOndisconnected(ondelete);this.__subscribedToParent=true}}return this.__operator};this.__proxyObject=obj=>{let allProps=getAllProperties(obj);for(const k of allProps){if(typeof this[k]==="undefined"){if(typeof obj[k]==="function"){this[k]=(...args)=>{if(this.__node.inputState)this.__node.state.setValue(this.__node.unique+"."+k+"input",args);let result=obj[k](...args);if(this.__node.state.triggers[this.__node.unique+"."+k]){if(typeof result?.then==="function"){result.then(res=>{this.__node.state.setValue(this.__node.unique+"."+k,res)}).catch(console.error)}else this.__node.state.setValue(this.__node.unique+"."+k,result)}return result}}else{let definition={get:()=>{return obj[k]},set:value=>{obj[k]=value;if(this.__node.state.triggers[this.__node.unique+"."+k])this.__node.state.setValue(this.__node.unique+"."+k,value)},enumerable:true,configurable:true};Object.defineProperty(this,k,definition)}}}};let orig=properties;if(typeof properties==="function"){if(isNativeClass(properties)){console.log(properties);properties=new properties}else properties={__operator:properties,__node:{forward:true,tag:properties.name}}}else if(typeof properties==="string"){if(graph?.get(properties)){properties=graph.get(properties)}}if(!properties.__node.initial)properties.__node.initial=orig;if(typeof properties==="object"){if(properties.__props){if(typeof properties.__props==="function")properties.__props=new properties.__props;if(typeof properties.__props==="object"){this.__proxyObject(properties.__props)}}if(typeof properties.__node==="string"){if(graph?.get(properties.__node.tag)){properties=graph.get(properties.__node.tag)}else properties.__node={}}else if(!properties.__node)properties.__node={};if(!properties.__parent&&parent2)properties.__parent=parent2;if(graph){properties.__node.graph=graph}if(properties.__operator){if(typeof properties.__operator==="string"){if(graph){let n=graph.get(properties.__operator);if(n)properties.__operator=n.__operator;if(!properties.__node.tag&&properties.__operator.name)properties.__node.tag=properties.__operator.name}}if(typeof properties.__operator==="function")properties.__operator=this.__setOperator(properties.__operator)}if(!properties.__node.tag){if(properties.__operator?.name)properties.__node.tag=properties.__operator.name;else properties.__node.tag=`node${Math.floor(Math.random()*1e15)}`}if(parent2?.__node&&!(parent2 instanceof Graph||properties instanceof Graph))properties.__node.tag=parent2.__node.tag+"."+properties.__node.tag;if(parent2 instanceof Graph&&properties instanceof Graph){if(properties.__node.loaders)Object.assign(parent2.__node.loaders?parent2.__node.loaders:{},properties.__node.loaders);if(parent2.__node.mapGraphs){properties.__node.nodes.forEach(n=>{parent2.set(properties.__node.tag+"."+n.__node.tag,n)});let ondelete=()=>{properties.__node.nodes.forEach(n=>{parent2.__node.nodes.delete(properties.__node.tag+"."+n.__node.tag)})};this.__addOndisconnected(ondelete)}}properties.__node=Object.assign(this.__node,properties.__node);let keys=Object.getOwnPropertyNames(properties);for(const key of keys){this[key]=properties[key]}if(typeof properties.default==="function"&&!properties.__operator){let fn=properties.default.bind(this);this.default=(...args)=>{if(this.__node.inputState)this.__node.state.setValue(this.__node.unique+"input",args);let result=fn(...args);if(typeof result?.then==="function"){result.then(res=>{if(res!==void 0)this.__node.state.setValue(this.__node.unique,res)}).catch(console.error)}else if(result!==void 0)this.__node.state.setValue(this.__node.unique,result);return result};properties.default=this.default}if(properties instanceof Graph)this.__node.source=properties}}__addLocalState(props){if(!props)return;if(!this.__node.localState){this.__node.localState={}}let localState=this.__node.localState;for(let k in props){if(this.__props&&this.__props[k])continue;if(typeof props[k]==="function"){if(!k.startsWith("_")){let fn=props[k].bind(this);props[k]=(...args)=>{if(this.__node.inputState)this.__node.state.setValue(this.__node.unique+"."+k+"input",args);let result=fn(...args);if(typeof result?.then==="function"){if(this.__node.state.triggers[this.__node.unique+"."+k])result.then(res=>{this.__node.state.setValue(this.__node.unique+"."+k,res)}).catch(console.error)}else if(this.__node.state.triggers[this.__node.unique+"."+k])this.__node.state.setValue(this.__node.unique+"."+k,result);return result};this[k]=props[k]}}else{localState[k]=props[k];let definition={get:()=>{return localState[k]},set:v2=>{localState[k]=v2;if(this.__node.state.triggers[this.__node.unique+"."+k])this.__node.state.setValue(this.__node.unique+"."+k,v2)},enumerable:true,configurable:true};Object.defineProperty(this,k,definition);if(typeof this.__node.initial==="object"){let dec=Object.getOwnPropertyDescriptor(this.__node.initial,k);if(dec===void 0||dec?.configurable){Object.defineProperty(this.__node.initial,k,definition)}}}}}__addOnconnected(callback){if(Array.isArray(this.__ondisconnected)){this.__onconnected.push(callback)}else if(typeof this.__onconnected==="function"){this.__onconnected=[callback,this.__onconnected]}else this.__onconnected=callback}__addOndisconnected(callback){if(Array.isArray(this.__ondisconnected)){this.__ondisconnected.push(callback)}else if(typeof this.__ondisconnected==="function"){this.__ondisconnected=[callback,this.__ondisconnected]}else this.__ondisconnected=callback}__callConnected(node=this){if(typeof this.__onconnected==="function"){this.__onconnected(this)}else if(Array.isArray(this.__onconnected)){this.__onconnected.forEach(o=>{o(this)})}}__callDisconnected(node=this){if(typeof this.__ondisconnected==="function")this.__ondisconnected(this);else if(Array.isArray(this.__ondisconnected)){this.__ondisconnected.forEach(o=>{o(this)})}}};var Graph=class{constructor(options){this.__node={tag:`graph${Math.floor(Math.random()*1e15)}`,nodes:new Map,state};this.init=options=>{if(options){recursivelyAssign(this.__node,options);if(options.tree)this.setTree(options.tree)}};this.setTree=tree=>{this.__node.tree=Object.assign(this.__node.tree?this.__node.tree:{},tree);let cpy=Object.assign({},tree);if(cpy.__node)delete cpy.__node;let listeners=this.recursiveSet(cpy,this,void 0,tree);if(tree.__node){if(!tree.__node.tag)tree.__node._tag=`tree${Math.floor(Math.random()*1e15)}`;else if(!this.get(tree.__node.tag)){let node=new GraphNode(tree,this,this);this.set(node.__node.tag,node);for(const l in this.__node.loaders){if(typeof this.__node.loaders[l]==="object"){if(this.__node.loaders[l].init)this.__node.loaders[l](node,parent,this,this.__node.tree,tree);if(this.__node.loaders[l].connected)node.__addOnconnected(this.__node.loaders[l].connect);if(this.__node.loaders[l].disconnected)node.__addOndisconnected(this.__node.loaders[l].disconnect)}else if(typeof this.__node.loaders==="function")this.__node.loaders[l](node,this,this,tree,tree,tree.__node.tag)}if(node.__listeners){listeners[node.__node.tag]=node.__listeners}}}else if(tree.__listeners){this.setListeners(tree.__listeners)}this.setListeners(listeners);return cpy};this.setLoaders=(loaders2,replace)=>{if(replace)this.__node.loaders=loaders2;else Object.assign(this.__node.loaders,loaders2);return this.__node.loaders};this.add=(properties,parent2)=>{let listeners={};if(typeof parent2==="string")parent2=this.get(parent2);if(typeof properties==="function"){if(isNativeClass(properties)){properties=new properties}else properties={__operator:properties}}else if(typeof properties==="string")properties=this.__node.tree[properties];let p=Object.assign({},properties);if(!p.__node)p.__node={};p.__node.initial=properties;if(typeof properties==="object"&&(!p?.__node?.tag||!this.get(p.__node.tag))){let node=new GraphNode(p,parent2,this);this.set(node.__node.tag,node);for(const l in this.__node.loaders){if(typeof this.__node.loaders[l]==="object"){if(this.__node.loaders[l].init)this.__node.loaders[l](node,parent2,this,this.__node.tree,properties,node.__node.tag);if(this.__node.loaders[l].connected)node.__addOnconnected(this.__node.loaders[l].connect);if(this.__node.loaders[l].disconnected)node.__addOndisconnected(this.__node.loaders[l].disconnect)}else if(typeof this.__node.loaders==="function")this.__node.loaders[l](node,parent2,this,this.__node.tree,properties,node.__node.tag)}this.__node.tree[node.__node.tag]=properties;if(node.__listeners){listeners[node.__node.tag]=node.__listeners}if(node.__children){node.__children=Object.assign({},node.__children);this.recursiveSet(node.__children,node,listeners,node.__children)}this.setListeners(listeners);node.__callConnected();return node}return};this.recursiveSet=(t,parent2,listeners={},origin)=>{let keys=Object.getOwnPropertyNames(origin);for(const key of keys){if(key.includes("__"))continue;let p=origin[key];if(Array.isArray(p))continue;if(typeof p==="function"){if(isNativeClass(p)){p=new p}else p={__operator:p}}else if(typeof p==="string")p=this.__node.tree[p];else if(typeof p==="boolean")p=this.__node.tree[key];if(typeof p==="object"){p=Object.assign({},p);if(!p.__node)p.__node={};if(!p.__node.tag)p.__node.tag=key;p.__node.initial=t[key];if(this.get(p.__node.tag)&&!(parent2?.__node&&this.get(parent2.__node.tag+"."+p.__node.tag))||parent2?.__node&&this.get(parent2.__node.tag+"."+p.__node.tag))continue;let node=new GraphNode(p,parent2,this);this.set(node.__node.tag,node);for(const l in this.__node.loaders){this.__node.loaders[l](node,parent2,this,t,t[key],key)}t[key]=node;this.__node.tree[node.__node.tag]=p;if(node.__listeners){listeners[node.__node.tag]=node.__listeners}if(node.__children){node.__children=Object.assign({},node.__children);this.recursiveSet(node.__children,node,listeners,node.__children)}node.__callConnected()}}return listeners};this.remove=(node,clearListeners=true)=>{this.unsubscribe(node);if(typeof node==="string")node=this.get(node);if(node instanceof GraphNode){this.delete(node.__node.tag);delete this.__node.tree[node.__node.tag];if(clearListeners){this.clearListeners(node)}node.__callDisconnected();const recursiveRemove=t=>{for(const key in t){this.unsubscribe(t[key]);this.delete(t[key].__node.tag);delete this.__node.tree[t[key].__node.tag];this.delete(key);delete this.__node.tree[key];t[key].__node.tag=t[key].__node.tag.substring(t[key].__node.tag.lastIndexOf(".")+1);if(clearListeners){this.clearListeners(t[key])}t[key].__callDisconnected();if(t[key].__children){recursiveRemove(t[key].__children)}}};if(node.__children){recursiveRemove(node.__children)}}if(node?.__node.tag&&node?.__parent){delete node?.__parent;node.__node.tag=node.__node.tag.substring(node.__node.tag.indexOf(".")+1)}return node};this.run=(node,...args)=>{if(typeof node==="string"){let nd=this.get(node);if(!nd&&node.includes(".")){nd=this.get(node.substring(0,node.lastIndexOf(".")));if(typeof nd?.[node.substring(node.lastIndexOf(".")+1)]==="function")return nd[node.substring(node.lastIndexOf(".")+1)](...args)}else if(nd?.__operator)return nd.__operator(...args)}if(node?.__operator){return node?.__operator(...args)}};this.setListeners=listeners=>{for(const key in listeners){let node=this.get(key);if(typeof listeners[key]==="object"){for(const k in listeners[key]){let n=this.get(k);let sub;if(typeof listeners[key][k]!=="object")listeners[key][k]={__callback:listeners[key][k]};else if(!listeners[key][k].__callback){for(const kk in listeners[key][k]){if(typeof listeners[key][k][kk]!=="object"){listeners[key][k][kk]={__callback:listeners[key][k][kk]};if(listeners[key][k][kk].__callback===true)listeners[key][k][kk].__callback=node.__operator}let nn=this.get(kk);if(nn){if(!nn){let tag=k.substring(0,k.lastIndexOf("."));nn=this.get(tag);if(n){sub=this.subscribe(nn,listeners[key][k][kk].__callback,k.substring(k.lastIndexOf(".")+1),listeners[key][k][kk].inputState,key,k);if(typeof node.__listeners[k][kk]!=="object")node.__listeners[k][kk]={__callback:listeners[key][k][kk].__callback,inputState:listeners[key][k][kk]?.inputState};node.__listeners[k][kk].sub=sub}}else{sub=this.subscribe(nn,listeners[key][k][kk].__callback,void 0,listeners[key][k].inputState,key,k);if(typeof node.__listeners[k][kk]!=="object")node.__listeners[k][kk]={__callback:listeners[key][k][kk].__callback,inputState:listeners[key][k][kk]?.inputState};node.__listeners[k][kk].sub=sub}}}}if(listeners[key][k].__callback){if(listeners[key][k].__callback===true)listeners[key][k].__callback=node.__operator;if(typeof listeners[key][k].__callback==="function")listeners[key][k].__callback=listeners[key][k].__callback.bind(node);if(typeof node.__listeners!=="object")node.__listeners={};if(!n){let tag=k.substring(0,k.lastIndexOf("."));n=this.get(tag);if(n){sub=this.subscribe(n,listeners[key][k].__callback,k.substring(k.lastIndexOf(".")+1),listeners[key][k].inputState,key,k);if(typeof node.__listeners[k]!=="object")node.__listeners[k]={__callback:listeners[key][k].__callback,inputState:listeners[key][k]?.inputState};node.__listeners[k].sub=sub}}else{sub=this.subscribe(n,listeners[key][k].__callback,void 0,listeners[key][k].inputState,key,k);if(typeof node.__listeners[k]!=="object")node.__listeners[k]={__callback:listeners[key][k].__callback,inputState:listeners[key][k]?.inputState};node.__listeners[k].sub=sub}}}}}};this.clearListeners=(node,listener)=>{if(typeof node==="string")node=this.get(node);if(node?.__listeners){for(const key in node.__listeners){if(listener&&key!==listener)continue;if(typeof node.__listeners[key].sub!=="number")continue;let n=this.get(key);if(!n){n=this.get(key.substring(0,key.lastIndexOf(".")));if(n){if(!node.__listeners[key].__callback){for(const k in node.__listeners[key]){this.unsubscribe(n,node.__listeners[key][k].sub,key.substring(key.lastIndexOf(".")+1),node.__listeners[key][k].inputState)}}else this.unsubscribe(n,node.__listeners[key].sub,key.substring(key.lastIndexOf(".")+1),node.__listeners[key].inputState)}}else{if(!node.__listeners[key].__callback){for(const k in node.__listeners[key]){this.unsubscribe(n,node.__listeners[key][k].sub,void 0,node.__listeners[key][k].inputState)}}else this.unsubscribe(n,node.__listeners[key].sub,void 0,node.__listeners[key].inputState)}delete node.__listeners[key]}}};this.get=tag=>{return this.__node.nodes.get(tag)};this.set=(tag,node)=>{return this.__node.nodes.set(tag,node)};this.delete=tag=>{return this.__node.nodes.delete(tag)};this.getProps=(node,getInitial)=>{if(typeof node==="string")node=this.get(node);if(node instanceof GraphNode){let cpy;if(getInitial)cpy=Object.assign({},this.__node.tree[node.__node.tag]);else{cpy=Object.assign({},node);delete cpy.__unsubscribe;delete cpy.__setOperator;delete cpy.__node;delete cpy.__subscribeState;delete cpy.__subscribe}}};this.subscribe=(node,callback,key,subInput,target,bound)=>{let nd=node;if(!(node instanceof GraphNode))nd=this.get(node);let sub;if(typeof callback==="string"){if(target){let method=this.get(target)?.[callback];if(typeof method==="function")callback=method}else callback=this.get(callback)?.__operator}if(nd instanceof GraphNode){sub=nd.__subscribe(callback,key,subInput,target,bound);let ondelete=()=>{nd.__unsubscribe(sub,key,subInput)};nd.__addOndisconnected(ondelete)}else if(typeof node==="string"){if(this.get(node)){if(callback instanceof GraphNode&&callback.__operator){sub=this.get(node).__subscribe(callback.__operator,key,subInput,target,bound);let ondelete=()=>{this.get(node).__unsubscribe(sub)};callback.__addOndisconnected(ondelete)}else if(typeof callback==="function"||typeof callback==="string"){sub=this.get(node).__subscribe(callback,key,subInput,target,bound);this.__node.state.getTrigger(this.get(node).__node.unique,sub).source=node}}else{if(typeof callback==="string")callback=this.__node.nodes.get(callback).__operator;if(typeof callback==="function")sub=this.__node.state.subscribeTrigger(node,callback)}}return sub};this.unsubscribe=(node,sub,key,subInput)=>{if(node instanceof GraphNode){return node.__unsubscribe(sub,key,subInput)}else return this.get(node)?.__unsubscribe(sub,key,subInput)};this.setState=update=>{this.__node.state.setState(update)};this.init(options)}};function recursivelyAssign(target,obj){for(const key in obj){if(obj[key]?.constructor.name==="Object"&&!Array.isArray(obj[key])){if(target[key]?.constructor.name==="Object"&&!Array.isArray(target[key]))recursivelyAssign(target[key],obj[key]);else target[key]=recursivelyAssign({},obj[key])}else{target[key]=obj[key]}}return target}function getAllProperties(obj){var allProps=[],curr=obj;do{var props=Object.getOwnPropertyNames(curr);props.forEach(function(prop){if(allProps.indexOf(prop)===-1)allProps.push(prop)})}while(curr=Object.getPrototypeOf(curr));return allProps}function isNativeClass(thing){return typeof thing==="function"&&thing.hasOwnProperty("prototype")&&!thing.hasOwnProperty("arguments")}var backprop=(node,parent2,graph)=>{if(node.__node.backward&&parent2 instanceof GraphNode){graph.setListeners({[parent2.__node.tag]:{[node.__node.tag]:parent2}})}};var loop=(node,parent2,graph)=>{if(node.__operator&&!node.__node.looperSet){node.__node.looperSet=true;if(typeof node.__node.delay==="number"){let fn=node.__operator;node.__setOperator((...args)=>{return new Promise((res,rej)=>{setTimeout(async()=>{res(await fn(...args))},node.__node.delay)})})}else if(node.__node.frame===true){let fn=node.__operator;node.__setOperator((...args)=>{return new Promise((res,rej)=>{requestAnimationFrame(async()=>{res(await fn(...args))})})})}if(typeof node.__node.repeat==="number"||typeof node.__node.recursive==="number"){let fn=node.__operator;node.__setOperator(async(...args)=>{let i=node.__node.repeat?node.__node.repeat:node.__node.recursive;let result;let repeater=async(tick,...inp)=>{while(tick>0){if(node.__node.delay||node.__node.frame){fn(...inp).then(async res=>{if(node.__node.recursive){await repeater(tick,res)}else await repeater(tick,...inp)});break}else result=await fn(...args);tick--}};await repeater(i,...args);return result})}if(node.__node.loop&&typeof node.__node.loop==="number"){let fn=node.__operator;node.__setOperator((...args)=>{if(!("looping"in node.__node))node.__node.looping=true;if(node.__node.looping){fn(...args);setTimeout(()=>{node.__operator(...args)},node.__node.loop)}});if(node.__node.looping)node.__operator();let ondelete=node2=>{if(node2.__node.looping)node2.__node.looping=false};node.__addOndisconnected(ondelete)}}};var animate=(node,parent2,graph)=>{if(node.__node.animate===true||node.__animation){let fn=node.__operator;node.__setOperator((...args)=>{if(!("animating"in node.__node))node.__node.animating=true;if(node.__node.animating){if(typeof node.__animation==="function")node.__animation(...args);else fn(...args);requestAnimationFrame(()=>{node.__operator(...args)})}});if(node.__node.animating||(!("animating"in node.__node)||node.__node.animating)&&node.__animation)setTimeout(()=>{requestAnimationFrame(node.__operator)},10);let ondelete=node2=>{if(node2.__node.animating)node2.__node.animating=false};node.__addOndisconnected(ondelete)}};var branching=(node,parent2,graph)=>{if(typeof node.__node.branch==="object"&&node.__operator&&!node.__node.branchApplied){let fn=node.__operator;node.__node.branchApplied=true;node.__operator=(...args)=>{let result=fn(...args);for(const key in node.__node.branch){let triggered=()=>{if(typeof node.__node.branch[key].then==="function"){node.__node.branch[key].then(result)}else if(node.__node.branch[key].then instanceof GraphNode&&node.__node.branch[key].then.__operator){node.__node.branch[key].then.__operator(result)}else result=node.__node.branch[key].then};if(typeof node.__node.branch[key].if==="function"){if(node.__node.branch[key].if(result)){triggered()}}else if(node.__node.branch[key].if===result){triggered()}}return result}}if(node.__listeners){for(const key in node.__listeners){if(typeof node.__listeners[key]==="object"){if(node.__listeners[key].branch&&!node.__listeners[key].branchApplied){let fn=node.__listeners[key].callback;node.__listeners[key].branchApplied=true;node.__listeners.callback=ret=>{let triggered=()=>{if(typeof node.__listeners[key].branch.then==="function"){ret=node.__listeners[key].branch.then(ret)}else if(node.__listeners[key].branch.then instanceof GraphNode&&node.__listeners[key].branch.then.__operator){ret=node.__listeners[key].branch.then.__operator(ret)}else ret=node.__listeners[key].branch.then};if(typeof node.__listeners[key].branch.if==="function"){if(node.__listeners[key].branch.if(ret)){triggered()}}else if(node.__listeners[key].branch.if===ret){triggered()}return fn(ret)}}}}}};var triggerListenerOncreate=(node,parent2,graph)=>{if(node.__listeners){for(const key in node.__listeners){if(typeof node.__listeners[key]==="object"){if(node.__listeners[key].oncreate){node.__listeners[key].callback(node.__listeners[key].oncreate)}}}}};var bindListener=(node,parent2,graph)=>{if(node.__listeners){for(const key in node.__listeners){if(typeof node.__listeners[key]==="object"){if(typeof node.__listeners[key].binding==="object"){node.__listeners.callback=node.__listeners.callback.bind(node.__listeners[key].binding)}}}}};var transformListenerResult=(node,parent2,graph)=>{if(node.__listeners){for(const key in node.__listeners){if(typeof node.__listeners[key]==="object"){if(typeof node.__listeners[key].transform==="function"&&!node.__listeners[key].transformApplied){let fn=node.__listeners[key].callback;node.__listeners[key].transformApplied=true;node.__listeners.callback=ret=>{ret=node.__listeners[key].transform(ret);return fn(ret)}}}}}};var substitute__operator=(node,parent2,graph)=>{if(node.post&&!node.__operator){node.__setOperator(node.post)}else if(!node.__operator&&typeof node.get=="function"){node.__setOperator(node.get)}if(!node.get&&node.__operator){node.get=node.__operator}if(node.aliases){node.aliases.forEach(a=>{graph.set(a,node);let ondelete=node2=>{graph.__node.nodes.delete(a)};node.__addOndisconnected(ondelete)})}if(typeof graph.__node.tree[node.__node.tag]==="object"&&node.get)graph.__node.tree[node.__node.tag].get=node.get};var loaders={backprop,loop,animate,branching,triggerListenerOncreate,bindListener,transformListenerResult,substitute__operator};var Service=class extends Graph{constructor(options){super({...options,loaders:options?.loaders?Object.assign({...loaders},options.loaders):{...loaders}});this.name=`service${Math.floor(Math.random()*1e15)}`;this.addServices=services=>{for(const s in services){if(typeof services[s]==="function")services[s]=new services[s];if(services[s]?.__node?.loaders)Object.assign(this.__node.loaders,services[s].__node.loaders);if(services[s]?.__node?.nodes){services[s].__node.nodes.forEach((n,tag)=>{if(!this.get(tag)){this.set(tag,n)}else this.set(s+"."+tag,n)});this.__node.nodes.forEach((n,k)=>{if(!services[s].__node.nodes.get(k))services[s].__node.nodes.set(k,n)});let set=this.set;this.set=(tag,node)=>{services[s].set(tag,node);return set(tag,node)};let del=this.delete;this.delete=tag=>{services[s].delete(tag);return del(tag)}}else if(typeof services[s]==="object"){this.setTree(services[s])}}};this.handleMethod=(route,method,args)=>{let m=method.toLowerCase();let src=this.__node.nodes.get(route);if(!src){src=this.__node.tree[route]}if(src?.[m]){if(!(src[m]instanceof Function)){if(args)src[m]=args;return src[m]}else return src[m](args)}else return this.handleServiceMessage({route,args,method})};this.transmit=(...args)=>{if(typeof args[0]==="object"){if(args[0].method){return this.handleMethod(args[0].route,args[0].method,args[0].args)}else if(args[0].route){return this.handleServiceMessage(args[0])}else if(args[0].node){return this.handleGraphNodeCall(args[0].node,args[0].args)}else if(this.__node.keepState){if(args[0].route)this.setState({[args[0].route]:args[0].args});if(args[0].node)this.setState({[args[0].node]:args[0].args})}return args}else return args};this.receive=(...args)=>{if(args[0]){if(typeof args[0]==="string"){let substr=args[0].substring(0,8);if(substr.includes("{")||substr.includes("[")){if(substr.includes("\\"))args[0]=args[0].replace(/\\/g,"");if(args[0][0]==='"'){args[0]=args[0].substring(1,args[0].length-1)};args[0]=JSON.parse(args[0])}}}if(typeof args[0]==="object"){if(args[0].method){return this.handleMethod(args[0].route,args[0].method,args[0].args)}else if(args[0].route){return this.handleServiceMessage(args[0])}else if(args[0].node){return this.handleGraphNodeCall(args[0].node,args[0].args)}else if(this.__node.keepState){if(args[0].route)this.setState({[args[0].route]:args[0].args});if(args[0].node)this.setState({[args[0].node]:args[0].args})}return args}else return args};this.pipe=(source,destination,endpoint,method,callback)=>{if(source instanceof GraphNode){if(callback)return this.subscribe(source,res=>{let mod=callback(res);if(mod!==void 0)this.transmit({route:destination,args:mod,method});else this.transmit({route:destination,args:res,method},endpoint)});else return this.subscribe(source,res=>{this.transmit({route:destination,args:res,method},endpoint)})}else if(typeof source==="string")return this.subscribe(source,res=>{this.transmit({route:destination,args:res,method},endpoint)})};this.pipeOnce=(source,destination,endpoint,method,callback)=>{if(source instanceof GraphNode){if(callback)return source.__node.state.subscribeTriggerOnce(source.__node.unique,res=>{let mod=callback(res);if(mod!==void 0)this.transmit({route:destination,args:mod,method});else this.transmit({route:destination,args:res,method},endpoint)});else return this.__node.state.subscribeTriggerOnce(source.__node.unique,res=>{this.transmit({route:destination,args:res,method},endpoint)})}else if(typeof source==="string")return this.__node.state.subscribeTriggerOnce(this.__node.nodes.get(source).__node.unique,res=>{this.transmit({route:destination,args:res,method},endpoint)})};this.terminate=(...args)=>{};this.isTypedArray=isTypedArray;this.recursivelyAssign=recursivelyAssign2;this.spliceTypedArray=spliceTypedArray;this.ping=()=>{console.log("pinged!");return"pong"};this.echo=(...args)=>{this.transmit(...args);return args};if(options?.services)this.addServices(options.services);this.setTree(this)}handleServiceMessage(message){let call;if(typeof message==="object"){if(message.route)call=message.route;else if(message.node)call=message.node}if(call){if(Array.isArray(message.args))return this.run(call,...message.args);else return this.run(call,message.args)}else return message}handleGraphNodeCall(route,args){if(!route)return args;if(args?.args){this.handleServiceMessage(args)}else if(Array.isArray(args))return this.run(route,...args);else return this.run(route,args)}};function isTypedArray(x3){return ArrayBuffer.isView(x3)&&Object.prototype.toString.call(x3)!=="[object DataView]"}var recursivelyAssign2=(target,obj)=>{for(const key in obj){if(typeof obj[key]==="object"&&!Array.isArray(obj[key])){if(typeof target[key]==="object"&&!Array.isArray(target[key]))recursivelyAssign2(target[key],obj[key]);else target[key]=recursivelyAssign2({},obj[key])}else target[key]=obj[key]}return target};function spliceTypedArray(arr,start,end){let s=arr.subarray(0,start);let e;if(end){e=arr.subarray(end+1)}let ta;if(s.length>0||e?.length>0)ta=new arr.constructor(s.length+e.length);if(ta){if(s.length>0)ta.set(s);if(e&&e.length>0)ta.set(e,s.length)}return ta}var randomId=prefix=>(prefix?`${prefix}`:"")+Math.floor(1e15*Math.random());var pseudoObjectId=(m=Math,d2=Date,h=16,s=s2=>m.floor(s2).toString(h))=>s(d2.now()/1e3)+" ".repeat(h).replace(/./g,()=>s(m.random()*h));var StructFrontend=class extends Service{constructor(options,user){super(options);this.name="structs";this.tablet=new DataTablet;this.collections=this.tablet.collections;this.id=randomId();this.baseServerCallback=data=>{let structs=data;if(typeof data==="object"&&data?.structType)structs=[data];if(Array.isArray(structs)){let filtered=structs.filter(o=>{if(o.structType!=="notification")return true});if(this.tablet)this.tablet.sortStructsIntoTable(filtered);structs.forEach(struct=>{if(typeof struct==="object"){if(!struct.structType||struct.structType==="USER"){if(struct.email)struct.structType="user";else struct.structType="uncategorized"}if(struct.structType==="user"||struct.structType==="authorization"||struct.structType==="group"){if(struct.structType==="user"){struct._id=struct.id}else if(struct.structType==="group"){if(this.currentUser){let uset=false;if(struct.admins[this.currentUser?._id]&&!this.currentUser.userRoles?.[struct.name+"_admin"]){this.currentUser.userRoles[struct.name+"_admin"]=true;uset=true}else if(!struct.admins[this.currentUser?._id]&&this.currentUser.userRoles?.[struct.name+"_admin"]){delete this.currentUser.userRoles[struct.name+"_admin"];uset=true}if(struct.admins[this.currentUser?._id]&&!this.currentUser.userRoles?.[struct.name+"_peer"]){this.currentUser.userRoles[struct.name+"_peer"]=true;uset=true}else if(!struct.admins[this.currentUser?._id]&&this.currentUser.userRoles?.[struct.name+"_peer"]){delete this.currentUser.userRoles[struct.name+"_peer"];uset=true}if(struct.admins[this.currentUser?._id]&&!this.currentUser.userRoles?.[struct.name+"_client"]){this.currentUser.userRoles[struct.name+"_client"]=true;uset=true}else if(!struct.admins[this.currentUser?._id]&&this.currentUser.userRoles?.[struct.name+"_client"]){delete this.currentUser.userRoles[struct.name+"_client"];uset=true}if(uset)this.setUser(this.currentUser)}}this.setLocalData(struct)}else{if(struct.structType==="notification"){let found=this.getLocalData("notification",{"ownerId":struct.ownerId,"_id":struct.parent._id});if(found){this.setLocalData(struct)}else{if(this.getLocalData(struct.structType,{"_id":struct.parent._id})){}else{this.overwriteLocalData(struct)}}if(struct.ownerId===this.currentUser?._id&&(struct.parent.structType==="user"||struct.parent.structType==="dataInstance"||struct.parent.structType==="schedule"||struct.parent.structType==="authorization")){this.resolveNotifications([struct],true)}}else{this.overwriteLocalData(struct)}}}})}if(data?.message==="notifications"){this.checkForNotifications()}if(data?.message==="deleted"){this.deleteLocalData(data.data)}this.onResult(data)};this.getUser=async(info="",callback=this.baseServerCallback)=>{if(this.currentUser?.request){let res=(await this.currentUser.request({route:"getUser",args:[this.currentUser._id,info]}))?.[0];callback(res);return res}};this.getUsers=async(ids=[],callback=this.baseServerCallback)=>{if(this.currentUser?.request){let res=await this.currentUser.request({route:"getUsersByIds",args:[this.currentUser._id,ids]});callback(res);return res}};this.getUsersByRole=async(userRole,callback=this.baseServerCallback)=>{if(this.currentUser?.request){let res=await this.currentUser.request({route:"getUsersByRole",args:[this.currentUser._id,userRole]});callback(res);return res}};this.getAllUserData=async(ownerId,excluded=[],callback=this.baseServerCallback)=>{if(this.currentUser?.request){let res=await this.currentUser.request({route:"getAllData",args:[ownerId,excluded]});callback(res);return res}};this.query=async(collection,queryObj={},findOne=false,skip=0,callback=this.baseServerCallback)=>{if(this.currentUser?.request){if(!collection||!queryObj)return void 0;let res=await this.currentUser.request({route:"query",args:[this.currentUser._id,collection,queryObj,findOne,skip]});if(typeof callback==="function")callback(res);return res}};this.getData=async(collection,ownerId,searchDict,limit=0,skip=0,callback=this.baseServerCallback)=>{if(this.currentUser?.request){let res=await this.currentUser.request({route:"getData",args:[this.currentUser._id,collection,ownerId,searchDict,limit,skip]});if(typeof callback==="function")callback(res);return res}};this.getDataByIds=async(structIds=[],ownerId,collection,callback=this.baseServerCallback)=>{if(this.currentUser?.request){let res=await this.currentUser.request({route:"getDataByIds",args:[this.currentUser._id,structIds,ownerId,collection]});if(typeof callback==="function")callback(res);return res}};this.getStructParentData=async(struct,callback=this.baseServerCallback)=>{if(!struct.parent)return;if(this.currentUser?.request){let args=[this.currentUser._id,struct.parent?.structType,"_id",struct.parent?._id];let res=(await this.currentUser.request({route:"getData",args}))?.[0];if(typeof callback==="function")callback(res);return res}};this.setUser=async(userStruct={},callback=this.baseServerCallback)=>{if(this.currentUser?.request){let res=(await this.currentUser.request({route:"setUser",args:[this.currentUser._id,this.stripStruct(userStruct)]}))?.[0];if(typeof callback==="function")callback(res);return res}};this.checkUserToken=async(usertoken,user=this.currentUser,callback=this.baseServerCallback)=>{if(!usertoken)return false;let changed=false;for(const prop in usertoken){let dummystruct=this.userStruct();if(user[prop]&&prop!=="_id"){if(Array.isArray(usertoken[prop])){for(let i=0;i<user[prop].length;i++){if(usertoken[prop].indexOf(user[prop][i])<0){user[prop]=usertoken[prop];changed=true;break}}if(!changed)for(let i=0;i<usertoken[prop].length;i++){if(user[prop].indexOf(usertoken[prop][i])<0){user[prop]=usertoken[prop];changed=true;break}}}else if(user[prop]!==usertoken[prop]){user[prop]=usertoken[prop];changed=true}}else if(!user[prop]&&dummystruct[prop]){user[prop]=usertoken[prop];changed=true}}if(changed)return await this.setUser(user,callback);return changed};this.setData=async(structs=[],notify=true,callback=this.baseServerCallback)=>{if(this.currentUser?.request){const copies=new Array;if(!Array.isArray(structs)&&typeof structs==="object")structs=[structs];structs.forEach(struct=>{copies.push(this.stripStruct(struct))});let res=await this.currentUser.request({route:"setData",args:[this.currentUser._id,copies,notify]});if(typeof callback==="function")callback(res);return res}};this.updateServerData=this.setData;this.deleteData=async(structs=[],callback=this.baseServerCallback)=>{if(this.currentUser?.request){let toDelete=[];structs.forEach(struct=>{if(typeof struct==="object"){if(struct?.structType&&struct?._id){toDelete.push({structType:struct.structType,_id:struct._id});this.deleteLocalData(struct)}}else if(typeof struct==="string"){let localstruct=this.getLocalData(void 0,{_id:struct});if(localstruct&&!Array.isArray(localstruct)){toDelete.push({structType:localstruct.structType,_id:localstruct._id})}else{toDelete.push({_id:struct})}}});let res=(await this.currentUser.request({route:"deleteData",args:[this.currentUser._id,toDelete]}))?.[0];if(typeof callback==="function")callback(res);return res}};this.deleteUser=async(userId,callback=this.baseServerCallback)=>{if(this.currentUser?.request){if(!userId)return;let res=(await this.currentUser.request({route:"deleteUser",args:[this.currentUser._id,userId]}))?.[0];if(typeof callback==="function")callback(res);return res}};this.setGroup=async(groupStruct={},callback=this.baseServerCallback)=>{if(this.currentUser?.request){let res=(await this.currentUser.request({route:"setGroup",args:[this.currentUser._id,this.stripStruct(groupStruct)]}))?.[0];if(typeof callback==="function")callback(res);return res}};this.getUserGroups=async(userId=this.currentUser._id,groupId="",callback=this.baseServerCallback)=>{if(this.currentUser?.request){let res=await this.currentUser.request({route:"getUserGroups",args:[this.currentUser._id,userId,groupId]});if(typeof callback==="function")callback(res);return res}};this.deleteGroup=async(groupId,callback=this.baseServerCallback)=>{if(this.currentUser?.request){if(!groupId)return;this.deleteLocalData(groupId);let res=(await this.currentUser.request({route:"deleteGroup",args:[this.currentUser._id,groupId]}))?.[0];if(typeof callback==="function")callback(res);return res}};this.setAuthorization=async(authorizationStruct={},callback=this.baseServerCallback)=>{if(this.currentUser?.request){let res=(await this.currentUser.request({route:"setAuthorization",args:[this.currentUser._id,this.stripStruct(authorizationStruct)]}))?.[0];if(typeof callback==="function")callback(res);return res}};this.getAuthorizations=async(userId=this.currentUser?._id,authorizationId="",callback=this.baseServerCallback)=>{if(this.currentUser?.request){if(userId===void 0)return;let res=await this.currentUser.request({route:"getAuthorizations",args:[this.currentUser._id,userId,authorizationId]});if(typeof callback==="function")callback(res);return res}};this.deleteAuthorization=async(authorizationId,callback=this.baseServerCallback)=>{if(this.currentUser?.request){if(!authorizationId)return;this.deleteLocalData(authorizationId);let res=(await this.currentUser.request({route:"deleteAuthorization",args:[authorizationId]}))?.[0];if(typeof callback==="function")callback(res);return res}};this.checkForNotifications=async(userId=this.currentUser?._id)=>{return await this.getData("notification",userId)};this.resolveNotifications=async(notifications=[],pull=true,user=this.currentUser)=>{if(!user||notifications.length===0)return;let structIds=[];let notificationIds=[];let nTypes=[];let unote=false;if(notifications.length===0)notifications=this.getLocalData("notification",{"ownerId":user._id});notifications.forEach(struct=>{if(struct.parent.structType==="user")unote=true;nTypes.push(struct.parent.structType);structIds.push(struct.parent._id);notificationIds.push(struct._id);this.deleteLocalData(struct)});this.deleteData(notifications);if(pull){nTypes.reverse().forEach((note,i)=>{if(note==="user"){this.getUser(structIds[i]);structIds.splice(structIds.length-i-1,1)}});if(structIds.length===1)return await this.getDataByIds(structIds,void 0,notifications[0].parent.structType);if(structIds.length>0)return await this.getDataByIds(structIds)}return true};this.setAuthorizationsByGroup=async(user=this.currentUser)=>{let auths=this.getLocalData("authorization",{"ownerId":user._id});let newauths=[];if(user.userRoles)await Promise.all(Object.keys(user.userRoles).map(async role=>{let split=role.split("_");let team=split[0];let otherrole;if(role.includes("client")){otherrole=team+"_peer"}else if(role.includes("peer")){otherrole=team+"_client"}else if(role.includes("admin")){otherrole=team+"_owner"}if(otherrole){let users=await this.getUsersByRole(otherrole);if(users)await Promise.all(users.map(async groupie=>{let theirname=groupie.username;if(!theirname)theirname=groupie.email;if(!theirname)theirname=groupie._id;let myname=user.username;if(!myname)myname=user.email;if(!myname)myname=user._id;if(theirname!==myname){if(role.includes("client")){let found=auths.find(a=>{if(a.authorizerId===groupie._id&&a.authorizedId===user._id)return true});if(!found){let auth=await this.authorizeUser(DataStructures_exports.ProfileStruct("user",user,user),groupie._id,theirname,user._id,myname,{"peer":true},void 0,{group:team});newauths.push(auth)}}else if(role.includes("peer")){let found=auths.find(a=>{if(a.authorizedId===groupie._id&&a.authorizerId===user._id)return true});if(!found){let auth=await this.authorizeUser(DataStructures_exports.ProfileStruct("user",user,user),user._id,myname,groupie._id,theirname,{"peer":true},void 0,{group:team});newauths.push(auth)}}}}))}}));if(newauths.length>0)return newauths;return void 0};this.deleteRoom=async roomStruct=>{if(!roomStruct)return false;let toDelete=[roomStruct];roomStruct.comments?.forEach(id=>{let struct=this.getLocalData("comment",{"_id":id});toDelete.push(struct)});if(roomStruct)return await this.deleteData(toDelete);else return false};this.deleteComment=async commentStruct=>{let allReplies=[commentStruct];let getRepliesRecursive=(head=commentStruct)=>{if(head?.replies){head.replies.forEach(replyId=>{let reply=this.getLocalData("comment",{"_id":replyId});if(reply){if(reply.replies.length>0){reply.replies.forEach(replyId2=>{getRepliesRecursive(replyId2)})}allReplies.push(reply)}})}};getRepliesRecursive(commentStruct);let parent2=this.getLocalData(commentStruct.parent?.structType,{"_id":commentStruct.parent?._id});let toUpdate=[];if(parent2){toUpdate=[parent2];allReplies.forEach(r=>{let idx=parent2.replies?.indexOf(r._id);if(idx>-1)parent2.replies.splice(idx,1);let idx2=parent2.comments?.indexOf(r._id);if(idx2>-1)parent2.comments.splice(idx2,1)})}let replyTo=this.getLocalData("comment",{"_id":commentStruct.replyTo});if(replyTo?._id!==parent2?._id){let idx=replyTo.replies?.indexOf(parent2._id);if(idx>-1)replyTo.replies.splice(idx,1);toUpdate.push(replyTo)}if(toUpdate.length>0)await this.updateServerData(toUpdate);return await this.deleteData(allReplies)};this.getUserDataByAuthorization=async(authorizationStruct,collection,searchDict,limit=0,skip=0,callback=this.baseServerCallback)=>{let u=authorizationStruct.authorizerId;if(u){return new Promise(async resolve=>{this.getUser(u,async data=>{if(!collection)await this.getAllUserData(u,["notification"],callback);else await this.getData(collection,u,searchDict,limit,skip,callback);resolve(data);callback(data)})})}else return void 0};this.getUserDataByAuthorizationGroup=async(groupId="",collection,searchDict,limit=0,skip=0,callback=this.baseServerCallback)=>{let auths=this.getLocalData("authorization");let results=[];await Promise.all(auths.map(async o=>{if(o.groups?.includes(groupId)){let u=o.authorizerId;if(u){let data;let user=await this.getUser(u,callback);if(user)results.push(user);if(!collection)data=await this.getAllUserData(u,["notification"],callback);else data=await this.getData(collection,u,searchDict,limit,skip,callback);if(data)results.push(data)}return true}}));return results};this.getLocalUserPeerIds=(user=this.currentUser)=>{if(!user)return[];let result=[];let authorizations=this.getLocalData("authorization",user._id);authorizations.forEach(a=>{if(a.authorizations["peer"]&&a.authorizerId===user._id)result.push(a.authorizedId)});return result};this.authorizeUser=async(parentUser,authorizerUserId="",authorizerUserName="",authorizedUserId="",authorizedUserName="",authorizations={},structs={},excluded={},groups={},expires=false)=>{if(!parentUser)return void 0;let newAuthorization=this.createStruct("authorization",void 0,parentUser,void 0);newAuthorization.authorizedId=authorizedUserId;newAuthorization.authorizedName=authorizedUserName;newAuthorization.authorizerId=authorizerUserId;newAuthorization.authorizerName=authorizerUserName;newAuthorization.authorizations=authorizations;newAuthorization.structs=structs;newAuthorization.excluded=excluded;newAuthorization.groups=groups;newAuthorization.expires=expires;newAuthorization.status="PENDING";newAuthorization.associatedAuthId="";newAuthorization.ownerId=parentUser._id;newAuthorization=await this.setAuthorization(newAuthorization);return newAuthorization};this.addGroup=async(parentUser,name="",details="",admins={},peers={},clients={},updateServer=true)=>{if(!parentUser)return void 0;let newGroup=this.createStruct("group",void 0,parentUser);newGroup.name=name;newGroup.details=details;newGroup.admins=admins;newGroup.peers=peers;newGroup.clients=clients;newGroup.users={};Object.assign(newGroup.users,newGroup.admins);Object.assign(newGroup.users,newGroup.peers);Object.assign(newGroup.users,newGroup.clients);newGroup.ownerId=parentUser._id;if(updateServer){newGroup=await this.setGroup(newGroup)}return newGroup};this.addData=async(parentUser,author="",title="",type="",data=[],expires=false,updateServer=true)=>{if(!parentUser)return void 0;let newDataInstance=this.createStruct("dataInstance",void 0,parentUser);newDataInstance.author=author;newDataInstance.title=title;newDataInstance.type=type;newDataInstance.data=data;newDataInstance.expires=expires;newDataInstance.ownerId=parentUser._id;if(updateServer)newDataInstance=await this.updateServerData([newDataInstance])[0];return newDataInstance};this.addEvent=async(parentUser,author="",event="",notes="",startTime=0,endTime=0,grade=0,attachments=[],users={},updateServer=true)=>{if(!parentUser)return void 0;if(Object.keys(users).length===0)users=this.getLocalUserPeerIds(parentUser);let newEvent=this.createStruct("event",void 0,parentUser);newEvent.author=author;newEvent.event=event;newEvent.notes=notes;newEvent.startTime=startTime;newEvent.endTime=endTime;newEvent.grade=grade;newEvent.attachments=attachments;newEvent.users=users;newEvent.ownerId=parentUser._id;if(updateServer)newEvent=await this.updateServerData([newEvent])[0];return newEvent};this.addChatroom=async(parentUser,authorId="",message="",attachments=[],users={},updateServer=true)=>{if(!parentUser)return void 0;if(Object.keys(users).length===0)users=this.getLocalUserPeerIds(parentUser);let newChatroom=this.createStruct("chatroom",void 0,parentUser);newChatroom.message=message;newChatroom.attachments=attachments;newChatroom.authorId=authorId;newChatroom.users=users;newChatroom.replies=[];newChatroom.comments=[];newChatroom.ownerId=parentUser._id;let update=[newChatroom];if(updateServer)newChatroom=await this.updateServerData(update)[0];return newChatroom};this.addComment=async(parentUser,roomStruct,replyTo,authorId="",message="",attachments=[],updateServer=true)=>{if(!roomStruct)return void 0;if(!replyTo)replyTo=roomStruct;if(!parentUser)return void 0;let newComment=this.createStruct("comment",void 0,parentUser,roomStruct);newComment.authorId=authorId;newComment.replyTo=replyTo?._id;newComment.message=message;newComment.attachments=attachments;newComment.users=roomStruct?.users;newComment.replies=[];newComment.ownerId=parentUser._id;if(!updateServer)replyTo?.replies.push(newComment._id);if(!updateServer)roomStruct?.comments.push(newComment._id);let update=[newComment,roomStruct];if(replyTo?._id!==roomStruct._id)update.push(replyTo);let res;if(updateServer)res=await this.updateServerData(update);let updatedComment;if(typeof res==="object"){updatedComment=res.find(s=>{if(newComment.ownerId===s.ownerId&&newComment.timestamp===s.timestamp&&newComment.message===s.message){return true}})}if(updatedComment)return updatedComment;return res};this.setTree(this);if(user instanceof Object&&Object.keys(user).length>0)this.setupUser(user)}async setupUser(userinfo,callback=currentUser=>{}){if(!userinfo){console.error('must provide a minimum info object! e.g. {_id:"abc123"}');callback(void 0);return void 0}let changed=false;if(userinfo.id&&!userinfo._id)userinfo._id=userinfo.id;else if(userinfo._id)userinfo.id=userinfo._id;let res=await this.getUser(userinfo._id);let user=res?.user;let u;let newu=false;console.log("getUser result",user);if(!user||!user._id){console.log("creating new profile");u=this.userStruct(userinfo,true);newu=true;let wasSet=await this.setUser(u);let structs=this.getLocalData(void 0,{"ownerId":u._id});if(structs?.length>0)this.updateServerData(structs);this.setAuthorizationsByGroup(u)}else{u=user;if(res?.authorizations){if(Array.isArray(res.authorizations)){this.setLocalData(res.authorizations)}}if(res?.groups){if(Array.isArray(res.groups)){this.setLocalData(res.groups)}}}if(newu){this.setLocalData(u)}else{let data=await this.getAllUserData(u._id,void 0);if(!data||data.length===0){}else{this.setLocalData(data);let notes=data.filter(s=>{if(s.structType==="notification"){if(this.getLocalData("authorization",s.parent._id)){return true}if(s.parent.structType==="user"||s.parent.structType==="authorization"){return true}if(!this.getLocalData(s.parent.structType,s.parent._id))return true}});let comments=data.filter(s=>{if(s.structType==="comment"){return true}});let toDelete=[];comments.forEach(comment=>{if(!this.getLocalData("comment",{"_id":comment._id}))toDelete.push(comment._id)});if(toDelete.length>0)this.deleteData(toDelete);if(notes.length>0){this.resolveNotifications(notes,false,void 0);changed=true}let filtered=data.filter(o=>{if(o.structType!=="notification")return true});if(this.tablet)this.tablet.sortStructsIntoTable(filtered)}this.setLocalData(u);console.log("collections",this.tablet.collections)}if(u){this.currentUser=u;callback(this.currentUser);return this.currentUser}else{callback(u);return u}}onResult(data){}randomId(tag=""){return`${tag+Math.floor(Math.random()+Math.random()*Math.random()*1e16)}`}async addStruct(structType="struct",props={},parentUser,parentStruct,updateServer=true){let newStruct=DataStructures_exports.Struct(structType,props,parentUser,parentStruct);if(updateServer)newStruct=await this.updateServerData([newStruct])[0];return newStruct}overwriteLocalData(structs){if(Array.isArray(structs)){structs.forEach(struct=>{let localdat=this.getLocalData(struct.structType,{"ownerId":struct.ownerId,"_id":struct._id});if(!localdat||localdat?.length===0){this.setLocalData(struct)}else Object.assign(localdat,struct)})}else{let localdat=this.getLocalData(structs.structType,{"ownerId":structs.ownerId,"_id":structs._id});if(!localdat||localdat?.length===0){this.setLocalData(structs)}else Object.assign(localdat,structs)}}setLocalData(structs){this.tablet.setLocalData(structs)}getLocalData(collection,query){return this.tablet.getLocalData(collection,query)}getLocalReplies(struct){let replies=[];if(!struct.replies)return replies;else if(struct.replies.reduce((a,b2)=>a*(typeof b2==="object"?1:0),1))return struct.replies;replies=this.getLocalData("comment",{"replyTo":struct._id});return replies}hasLocalAuthorization(otherUserId,ownerId=this.currentUser._id){let auths=this.getLocalData("authorization",{ownerId});let found=auths.find(a=>{if(a.authorizedId===ownerId&&a.authorizerId===otherUserId)return true;if(a.authorizerId===ownerId&&a.authorizedId===otherUserId)return true});if(found){return found}else return false}deleteLocalData(structs){if(Array.isArray(structs))structs.forEach(s=>this.deleteStruct(s));else this.deleteStruct(structs);return true}deleteStruct(struct){if(typeof struct==="string")struct=this.getLocalData(struct);if(!struct)throw new Error("Struct not supplied");if(!struct.structType||!struct._id)return false;this.tablet.collections.get(struct.structType).delete(struct._id);return true}stripStruct(struct={}){const copy=Object.assign({},struct);for(const prop in copy){if(copy[prop]===void 0||copy[prop].constructor.name==="Map"||typeof copy[prop]==="function")delete copy[prop]}return copy}createStruct(structType,props,parentUser=this.currentUser,parentStruct){let struct=DataStructures_exports.Struct(structType,props,parentUser,parentStruct);return struct}userStruct(props={},currentUser=false){let user=DataStructures_exports.ProfileStruct(void 0,props,props);if(props._id)user.id=props._id;else if(props.id)user.id=props.id;else user.id="user"+Math.floor(Math.random()*1e10);user._id=user.id;user.ownerId=user.id;for(const prop in props){if(Object.keys(DataStructures_exports.ProfileStruct()).indexOf(prop)<0){delete user[prop]}}if(currentUser)this.currentUser=user;return user}dataObject(data=void 0,type="any",timestamp=Date.now()){return{type,data,timestamp}}};var import_bson_objectid=__toESM(require_objectid());var randomId2=prefix=>(prefix?`${prefix}_`:"")+Math.floor(1e15*Math.random());var toObjectID=str2=>{return typeof str2==="string"&&str2.length===24?(0,import_bson_objectid.default)(str2):str2};var getStringId=mongoid=>{if(typeof mongoid==="object")return mongoid.toString();else return mongoid};var defaultCollections=["profile","group","authorization","discussion","chatroom","comment","dataInstance","event","notification","schedule","date"];var StructBackend=class extends Service{constructor(options,dboptions){super(options);this.name="structs";this.debug=false;this.users={};this.collections={};this.useAuths=true;this.query=async(requestingUserId,collection,queryObj,findOne,skip)=>{let user=this.users[requestingUserId];if(!user)return false;if(this.mode.indexOf("mongo")>-1){return await this.queryMongo(user,collection,queryObj,findOne,skip)}else{let res=this.getLocalData(user,collection);if(res&&!Array.isArray(res)){let passed=!this.useAuths;if(!res?.ownerId)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,res)}if(typeof skip==="number"&&Array.isArray(res)){if(res.length>skip)res.splice(0,skip)}let data=[];if(res)await Promise.all(res.map(async s=>{let struct=this.getLocalData(getStringId(s._id));let passed=!this.useAuths;if(!struct?.ownerId)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct);if(passed)data.push(struct)}));return data}};this.getUser=async(requestingUserId,lookupId)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.indexOf("mongo")>-1){data=await this.getMongoUser(user,lookupId)}else{let struct=this.getLocalData("profile",{_id:lookupId});if(!struct)data={user:{}};else{let passed=!this.useAuths;if(!struct?.ownerId)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct);if(passed){let groups=this.getLocalData("group",{ownerId:lookupId});let auths=this.getLocalData("authorization",{ownerId:lookupId});data={user:struct,groups,authorizations:auths}}else data={user:{}}}}if(this.debug)console.log("getUser: user:",user,"input:",lookupId,"output",data);return data};this.setUser=async(requestingUserId,struct)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.indexOf("mongo")>-1){data=await this.setMongoUser(user,struct)}else{let passed=!this.useAuths;if(!struct?.ownerId)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct,"WRITE");if(passed)this.setLocalData(struct);return true}if(this.debug)console.log("setUser user:",user,"input:",struct,"output",data);return data};this.getUsersByIds=async(requestingUserId,userIds)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.includes("mongo")){data=await this.getMongoUsersByIds(user,userIds)}else{data=[];if(Array.isArray(userIds)){let struct=this.getLocalData("profile",{_id:userIds});if(struct)data.push(struct)}}if(this.debug)console.log("getUserByIds: user:",user,"input:",userIds,"output",data);return data};this.getUsersByRole=async(requestingUserId,role)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.includes("mongo")){data=await this.getMongoUsersByRole(user,role)}else{let profiles=this.getLocalData("profile");data=[];profiles.forEach(struct=>{if(struct.userRoles[role]){data.push(struct)}})}if(this.debug)console.log("getUserByRoles: user:",user,"input:",role,"output",data);return data};this.deleteUser=async(requestingUserId,userId)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.includes("mongo")){data=await this.deleteMongoUser(user,userId)}else{data=false;let struct=this.getLocalData(userId);if(struct){let passed=!this.useAuths;if(!struct?.ownerId)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct,"WRITE");if(passed)data=this.deleteLocalData(struct)}}if(this.debug)console.log("deleteUser: user:",user,"input:",userId,"output",data);return data};this.setData=async(requestingUserId,structs,notify)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.includes("mongo")){data=await this.setMongoData(user,structs,notify)}else{let non_notes=[];data=[];await Promise.all(structs.map(async structId=>{let struct=this.getLocalData(structId);let passed=!this.useAuths;if(!struct?.ownerId)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct,"WRITE");if(passed){if(!this.collections[struct.structType]){this.collections[struct.structType]=this.db?{instance:this.db.collection(struct.structType)}:{};this.collections[struct.structType].reference={}}this.setLocalData(struct);data.push(struct);if(struct.structType!=="notification")non_notes.push(struct)}}));if(non_notes.length>0&&(notify===true||typeof notify==="undefined"))this.checkToNotify(user,non_notes,this.mode);if(this.debug)console.log("setData:",user,structs,data);return true}if(this.debug)console.log("setData: user:",user,"input:",structs,notify,"output",data);return data};this.getData=async(requestingUserId,collection,ownerId,dict,limit,skip)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.includes("mongo")){data=await this.getMongoData(user,collection,ownerId,dict,limit,skip)}else{data=[];let structs;if(collection)structs=this.getLocalData(collection);if(structs&&ownerId)structs=structs.filter(o=>{if(o.ownerId===ownerId)return true});if(structs)await Promise.all(structs.map(async s=>{let struct=this.getLocalData(getStringId(s._id));let passed=!this.useAuths;if(!struct?.ownerId)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct);if(passed)data.push(struct)}))}if(this.debug)console.log("getData: user:",user,"input:",collection,ownerId,dict,limit,skip,"output",data);return data};this.getDataByIds=async(requestingUserId,structIds,ownerId,collection)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.includes("mongo")){data=await this.getMongoDataByIds(user,structIds,ownerId,collection)}else{data=[];let structs;if(collection)structs=this.getLocalData(collection);if(structs&&ownerId)structs=structs.filter(o=>{if(o.ownerId===ownerId)return true});if(structs)await Promise.all(structs.map(async s=>{let struct=this.getLocalData(getStringId(s._id));let passed=!this.useAuths;if(!struct?.ownerId)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct);if(passed)data.push(struct)}))}if(this.debug)console.log("getDataByIds: user:",user,"input:",structIds,ownerId,collection,"output",data);return data};this.getAllData=async(requestingUserId,ownerId,excludedCollections)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.includes("mongo")){data=await this.getAllUserMongoData(user,ownerId,excludedCollections)}else{let result=this.getLocalData(void 0,{ownerId});data=[];await Promise.all(result.map(async struct=>{if(excludedCollections){if(excludedCollections.indexOf(struct.structType)<0){let passed=!this.useAuths;if(!struct?.ownerId)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct);if(passed)data.push(struct)}}else{let passed=!this.useAuths;if(!struct?.ownerId)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct);if(passed)data.push(struct)}}))}if(this.debug)console.log("getAllData: user:",user,"input:",ownerId,excludedCollections,"output",data);return data};this.deleteData=async(requestingUserId,structIds)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.includes("mongo")){data=await this.deleteMongoData(user,structIds)}else{data=false;await Promise.all(structIds.map(async structId=>{let struct=this.getLocalData(structId);let passed=!this.useAuths;if(!struct?.ownerId)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct,"WRITE");if(passed)this.deleteLocalData(struct);data=true}))}if(this.debug)console.log("deleteData: user:",user,"input:",structIds,"output",data);return data};this.getUserGroups=async(requestingUserId,userId,groupId)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.includes("mongo")){data=await this.getMongoGroups(user,userId,groupId)}else{if(typeof groupId==="string"){data=this.getLocalData("group",{_id:groupId})}else{data=[];let result=this.getLocalData("group");if(userId){result.forEach(struct=>{if(Object.keys(struct.users).includes(userId))data.push(struct)})}else{result.forEach(struct=>{if(Object.keys(struct.users).includes(getStringId(user._id)))data.push(struct)})}}}if(this.debug)console.log("getGroups: user:",user,"input:",userId,groupId,"output",data);return data};this.deleteGroup=async(requestingUserId,groupId)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.includes("mongo")){data=await this.deleteMongoGroup(user,groupId)}else{let struct=this.getLocalData("group",groupId);let passed=!this.useAuths;if(struct){if(!struct?.ownerId)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct,"WRITE")}if(passed){data=true}}if(this.debug)console.log("deleteGroup: user:",user,"input:",groupId,"output",data);return data};this.getAuthorizations=async(requestingUserId,ownerId,authId)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.includes("mongo")){data=await this.getMongoAuthorizations(user,ownerId,authId)}else{if(authId){let result=this.getLocalData("authorization",{_id:authId});if(result)data=[result]}else{data=this.getLocalData("authorization",{ownerId})}}if(this.debug)console.log("getAuthorizations: user:",user,"input:",ownerId,authId,"output",data);return data};this.deleteAuthorization=async(requestingUserId,authId)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.includes("mongo")){data=await this.deleteMongoAuthorization(user,authId)}else{data=true;let struct=this.getLocalData("authorization",{_id:authId});if(struct){let passed=!this.useAuths;if(!struct?.ownerId)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct,"WRITE");if(passed)data=this.deleteLocalData(struct)}}if(this.debug)console.log("deleteAuthorization: user:",user,"input:",authId,"output",data);return data};this.wipeDB=async()=>{await Promise.all(Object.values(this.collections).map(c=>{try{c.instance.remove({})}catch(err){}}));return true};this.setTree(this);if(dboptions?.users)this.users=dboptions.users;if(dboptions?.db)this.mode=this.db?dboptions.mode?dboptions.mode:"local":"local";if(dboptions?.collections)this.collections=dboptions.collections;defaultCollections.forEach(k=>{if(!this.collections[k]){this.collections[k]=this.db?{instance:this.db.collection(k)}:{};this.collections[k].reference={}}})}notificationStruct(parentStruct={}){let structType="notification";let struct={structType,timestamp:Date.now(),_id:randomId2(structType),note:"",alert:false,ownerId:"",parentUserId:"",parent:{structType:parentStruct?.structType,_id:getStringId(parentStruct?._id)}};return struct}async checkToNotify(user,structs=[],mode=this.mode){if(structs.length===0)return false;if(typeof user==="string"){for(let key in this.users){const obj=this.users[key];if(getStringId(obj._id)===user)user=obj}}if(typeof user==="string"||user==null)return false;let usersToNotify={};let newNotifications=[];structs.forEach(async struct=>{if(struct?._id){if(user?._id!==struct.ownerId){let newNotification=this.notificationStruct(struct);newNotification._id="notification_"+getStringId(struct._id);newNotification.ownerId=struct.ownerId;newNotification.note=struct.structType;newNotification.parentUserId=struct.ownerId;if(struct.alert)newNotification.alert=struct.alert;newNotifications.push(newNotification);usersToNotify[struct.ownerId]=struct.ownerId}if(struct.users){Object.keys(struct.users).forEach(usr=>{if(usr!==user._id){let newNotification=this.notificationStruct(struct);newNotification._id="notification_"+getStringId(struct._id);newNotification.ownerId=usr;newNotification.note=struct.structType;if(struct.alert)newNotification.alert=struct.alert;newNotification.parentUserId=struct.ownerId;newNotifications.push(newNotification);usersToNotify[usr]=usr}})}else{let auths=[];if(mode.includes("mongo")){let s=this.collections.authorization.instance.find({$or:[{authorizedId:user._id},{authorizerId:user._id}]});if(await s.count()>0){await s.forEach(d2=>auths.push(d2))}}else{auths=this.getLocalData("authorization",{authorizedId:user._id});auths.push(...this.getLocalData("authorization",{authorizerId:user._id}))}if(auths.length>0){auths.forEach(auth=>{if(struct.authorizerId===struct.ownerId&&!usersToNotify[struct.authorizedId]){if(auth.status==="OKAY"&&auth.authorizations["peer"]){let newNotification=this.notificationStruct(struct);newNotification.ownerId=auth.authorizedId;newNotification._id="notification_"+getStringId(struct._id);newNotification.note=struct.structType;newNotification.parentUserId=struct.ownerId;if(struct.alert)newNotification.alert=struct.alert;newNotifications.push(newNotification);usersToNotify[newNotification.ownerId]=newNotification.ownerId}}})}}}});if(newNotifications.length>0){if(mode.includes("mongo")){await this.setMongoData(user,newNotifications)}else{this.setLocalData(newNotifications)}for(const uid in usersToNotify){this.users[uid].send({route:"structNotification",args:true})}return true}else return false}async queryMongo(user,collection,queryObj={},findOne=false,skip=0){if(!collection&&!queryObj)return void 0;else if(findOne){let res=this.db.collection(collection).findOne(queryObj);if(!res)return void 0;let passed=!this.useAuths;if(!res?.ownerId){passed=true}else if(getStringId(user._id)!==res.ownerId||getStringId(user._id)===res.ownerId&&user.userRoles?.admincontrol){if(this.useAuths)passed=await this.checkAuthorization(user,res)}if(passed)return res;else return void 0}else{let res=await this.db.collection(collection).find(queryObj).sort({$natural:-1}).skip(skip);let structs=[];if(await res.count()>0){let passed=!this.useAuths;let checkedAuth="";await res.forEach(async s=>{if(!s?.ownerId){passed=true}else if((getStringId(user._id)!==s.ownerId||getStringId(user._id)===s.ownerId&&user.userRoles?.admincontrol)&&checkedAuth!==s.ownerId){if(this.useAuths)passed=await this.checkAuthorization(user,s);checkedAuth=s.ownerId}if(passed)structs.push(s)})}return structs}}async setMongoData(user,structs=[],notify=true){let firstwrite=false;if(structs.length>0){let passed=!this.useAuths;let checkedAuth="";await Promise.all(structs.map(async struct=>{let secondary={};if(Array.isArray(struct)){secondary=struct[1];struct=struct[0]}if(!struct?.ownerId)passed=true;else if((getStringId(user._id)!==struct.ownerId||getStringId(user._id)===struct.ownerId&&user.userRoles?.admincontrol)&&checkedAuth!==struct.ownerId){if(this.useAuths)passed=await this.checkAuthorization(user,struct,"WRITE");checkedAuth=struct.ownerId}if(passed){if(struct.structType){if(!this.collections[struct.structType]){this.collections[struct.structType]=this.db?{instance:this.db.collection(struct.structType)}:{};this.collections[struct.structType].reference={}}let copy=JSON.parse(JSON.stringify(struct));if(copy._id)delete copy._id;if(struct._id){if(getStringId(struct._id).includes("defaultId")){await this.db.collection(struct.structType).insertOne(copy);firstwrite=true}else if(struct.structType==="notification")await this.db.collection(struct.structType).updateOne({parent:struct.parent,_id:struct._id},{$set:copy,...secondary},{upsert:true,unique:false});else await this.db.collection(struct.structType).updateOne({_id:toObjectID(struct._id)},{$set:copy,...secondary},{upsert:true})}else if(struct.structType){this.db.collection(struct.structType).insertOne(copy)}}}}));if(firstwrite===true){let toReturn=[];await Promise.all(structs.map(async(struct,j)=>{let copy=JSON.parse(JSON.stringify(struct));if(copy._id&&copy.structType!=="profile")delete copy._id;if(struct.structType!=="comment"){let pulled;if(struct.structType!=="notification")pulled=await this.db.collection(copy.structType).findOne(copy);if(pulled){pulled._id=getStringId(pulled._id);toReturn.push(pulled)}}else if(struct.structType==="comment"){let comment=struct;let copy2=JSON.parse(JSON.stringify(comment));if(copy2._id)delete copy2._id;let pulledComment=await this.db.collection("comment").findOne(copy2);let replyToId=pulledComment?.replyTo;let replyTo=structs.find(s=>{if(getStringId(s._id)===replyToId)return true});if(replyTo){let copy3=JSON.parse(JSON.stringify(replyTo));if(copy3._id)delete copy3._id;let pulledReply;await Promise.all(["discussion","chatroom","comment"].map(async name=>{let found=await this.db.collection(name).findOne({_id:toObjectID(replyToId)});if(found)pulledReply=found}));if(pulledReply){let roomId=getStringId(pulledComment.parent._id);let room,pulledRoom;if(roomId!==replyToId){room=structs.find(s=>{if(getStringId(s._id)===roomId)return true});if(room){delete room._id;await Promise.all(["discussion","chatroom"].map(async name=>{let found=await this.db.collection(name).findOne(room);if(found)pulledRoom=found}))}}else pulledRoom=pulledReply;let toUpdate=[pulledComment];if(pulledReply){let i=pulledReply.replies.indexOf(getStringId(pulledComment._id));if(i<0){pulledReply.replies.push(getStringId(pulledComment._id));pulledComment.replyTo=getStringId(pulledReply._id)}toUpdate.push(pulledReply)}if(pulledRoom){let i=pulledRoom.comments.indexOf(pulledComment._id);if(i<0){pulledRoom.comments.push(getStringId(pulledComment._id));pulledComment.parent._id=getStringId(pulledRoom._id)}}await Promise.all(toUpdate.map(async s=>{let copy4=JSON.parse(JSON.stringify(s));delete copy4._id;await this.db.collection(s.structType).updateOne({_id:toObjectID(s._id)},{$set:copy4},{upsert:false})}));[...toReturn].reverse().forEach((s,j2)=>{if(toUpdate.find(o=>{if(getStringId(s._id)===getStringId(o._id))return true})){toReturn.splice(toReturn.length-j2-1,1)}});toReturn.push(...toUpdate)}}else if(pulledComment){toReturn.push(pulledComment)}}}));if(notify)this.checkToNotify(user,toReturn);return toReturn}else{let non_notes=[];structs.forEach(s=>{if(s.structType!=="notification")non_notes.push(s)});if(notify)this.checkToNotify(user,non_notes);return true}}else return false}async setMongoUser(user,struct){if(struct._id){const _id=toObjectID(struct._id);let usersearch=_id!==struct._id?{_id}:{id:struct.id};let userexists=await this.collections.profile.instance.findOne(usersearch);if(userexists){if(getStringId(user._id)!==struct.ownerId||getStringId(user._id)===struct.ownerId&&user.userRoles?.admincontrol){let passed=!this.useAuths;if(!struct?.ownerId)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct,"WRITE");if(!passed)return false}}let copy=JSON.parse(JSON.stringify(struct));if(this.debug)console.log("RETURNS PROFILE",struct);await this.collections.profile.instance.updateOne(usersearch,{$set:copy},{upsert:true});user=await this.collections.profile.instance.findOne(usersearch);this.checkToNotify(user,[struct]);return user}else return false}async setGroup(user,struct,mode=this.mode){if(struct?._id){let exists=void 0;if(mode.includes("mongo")){exists=await this.collections.group.instance.findOne({name:struct.name})}else{exists=this.getLocalData("group",{_id:getStringId(struct._id)})}if(exists&&(exists.ownerId!==struct.ownerId||struct.admins.indexOf(getStringId(user._id))<0))return false;if(getStringId(user._id)!==struct.ownerId){let passed=!this.useAuths;if(!struct?.ownerId)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct,"WRITE");if(!passed)return false}let allusers=[];Object.keys(struct.users).forEach(u=>{allusers.push({email:u},{id:u},{username:u})});let users={};let ids={};if(mode.includes("mongo")){let cursor=this.collections.profile.instance.find({$or:allusers});if(await cursor.count()>0){await cursor.forEach(user2=>{users[getStringId(user2._id)]=user2;ids[getStringId(user2._id)]=true})}}else{allusers.forEach(search=>{let result=this.getLocalData("profile",search);if(result.length>0){users[getStringId(result[0]._id)]=result[0];ids[getStringId(result[0]._id)]=true}})}struct.users=ids;let admins={};let peers={};let clients={};Object.keys(users).forEach(id=>{let u=users[id];if(struct.admins[getStringId(u._id)]||struct.admins[u.email]||struct.admins[u.username]||struct.admins[struct.ownerId]){if(!admins[getStringId(u._id)])admins[getStringId(u._id)]=true}if(struct.peers[getStringId(u._id)]||struct.peers[u.email]||struct.peers[u.username]||struct.peers[struct.ownerId]){if(!peers[getStringId(u._id)])peers[getStringId(u._id)]=true}if(struct.clients[getStringId(u._id)]||struct.clients[u.email]||struct.clients[u.username]||struct.clients[struct.ownerId]){if(!clients[getStringId(u._id)])clients[getStringId(u._id)]=true}});struct.admins=admins;struct.peers=peers;struct.clients=clients;let copy=JSON.parse(JSON.stringify(struct));if(copy._id)delete copy._id;if(mode.includes("mongo")){if(getStringId(struct._id).includes("defaultId")){await this.db.collection(struct.structType).insertOne(copy);delete struct._id;struct=await this.db.collection(struct.structType).findOne(struct);struct._id=getStringId(struct._id)}else await this.collections.group.instance.updateOne({_id:toObjectID(struct._id)},{$set:copy},{upsert:true})}else{this.setLocalData(struct)}this.checkToNotify(user,[struct],this.mode);if(this.debug)console.log("setGroup: user:",user,"output",struct);return struct}else return false}async getMongoUser(user,info="",bypassAuth=false){return new Promise(async resolve=>{const query=[{email:info},{id:info},{username:info}];try{query.push({_id:toObjectID(info)})}catch(e){}let u=await this.collections.profile.instance.findOne({$or:query});if(!u||u==null)resolve({});else{u._id=getStringId(u._id);if(!u.ownerId)u.ownerId=u._id;if(u&&bypassAuth===false){if(getStringId(user._id)!==u._id||getStringId(user._id)===u._id&&user.userRoles?.admincontrol){let passed=!this.useAuths;if(this.useAuths)passed=await this.checkAuthorization(user,u);if(!passed)resolve(void 0)}let authorizations=[];let auths=this.collections.authorization.instance.find({ownerId:u._id});if(await auths.count()>0){await auths.forEach(d2=>authorizations.push(d2))}let gs=this.collections.group.instance.find({users:{$all:[u._id]}});let groups=[];if(await gs.count()>0){await gs.forEach(d2=>groups.push(d2))}resolve({user:u,authorizations,groups})}else resolve({user:u})}})}async getMongoUsersByIds(user,userIds=[]){let usrs=[];userIds.forEach(u=>{try{usrs.push({_id:toObjectID(u)})}catch{}});let found=[];if(usrs.length>0){let users=this.collections.profile.instance.find({$or:usrs});if(await users.count()>0){await users.forEach(u=>{found.push(u)})}}return found}async getMongoUsersByRole(user,role){let users=this.collections.profile.instance.find({userRoles:{$all:{[role]:true}}});let found=[];if(await users.count()>0){await users.forEach(u=>{found.push(u)})}return found}async getMongoDataByIds(user,structIds,ownerId,collection){if(structIds.length>0){let query=[];structIds.forEach(_id=>{let q={_id:toObjectID(_id)};if(ownerId)q.ownerId=ownerId;query.push(q)});let found=[];if(!collection){await Promise.all(Object.keys(this.collections).map(async name=>{let cursor=await this.db.collection(name).find({$or:query});if(await cursor.count()>0){let passed=true;let checkedAuth="";await cursor.forEach(async s=>{if(!s?.ownerId)passed=true;else if((getStringId(user._id)!==s.ownerId||getStringId(user._id)===s.ownerId&&user.userRoles?.admincontrol)&&checkedAuth!==s.ownerId){if(this.useAuths)passed=await this.checkAuthorization(user,s);checkedAuth=s.ownerId}if(passed)found.push(s)})}}))}else{let cursor=await this.db.collection(collection).find({$or:query});if(await cursor.count()>0){let passed=true;let checkedAuth="";await cursor.forEach(async s=>{if(!s?.ownerId)passed=true;else if((getStringId(user._id)!==s.ownerId||getStringId(user._id)===s.ownerId&&user.userRoles?.admincontrol)&&checkedAuth!==s.ownerId){if(this.useAuths)passed=await this.checkAuthorization(user,s);checkedAuth=s.ownerId}if(passed)found.push(s)})}}return found}}async getMongoData(user,collection,ownerId,dict={},limit=0,skip=0){if(!ownerId)ownerId=dict?.ownerId;if(!dict)dict={};if(dict._id)dict._id=toObjectID(dict._id);let structs=[];let passed=true;let checkedAuth="";if(!collection&&!ownerId&&!dict)return[];else if(!collection&&ownerId&&Object.keys(dict).length===0)return await this.getAllUserMongoData(user,ownerId);else if((!dict||Object.keys(dict).length===0)&&ownerId&&collection){let cursor=this.db.collection(collection).find({ownerId}).sort({$natural:-1}).skip(skip);if(limit>0)cursor.limit(limit);if(await cursor.count()>0){await cursor.forEach(async s=>{if(!s?.ownerId)passed=true;else if((getStringId(user._id)!==s.ownerId||getStringId(user._id)===s.ownerId&&user.userRoles?.admincontrol)&&checkedAuth!==s.ownerId){if(this.useAuths)passed=await this.checkAuthorization(user,s);checkedAuth=s.ownerId}if(passed===true)structs.push(s)})}}else if(Object.keys(dict).length>0&&ownerId){let found=await this.db.collection(collection).findOne({ownerId,...dict});if(found)structs.push(found)}else if(Object.keys(dict).length>0&&!ownerId){await Promise.all(Object.keys(this.collections).map(async name=>{let found=await this.db.collection(name).findOne(dict);if(found){if(!found?.ownerId)passed=true;else if((getStringId(user._id)!==found.ownerId||getStringId(user._id)===found.ownerId&&user.userRoles?.admincontrol)&&checkedAuth!==found.ownerId){if(this.useAuths)passed=await this.checkAuthorization(user,found);checkedAuth=found.ownerId}structs.push(found);return}}))}if(!passed)return[];return structs}async getAllUserMongoData(user,ownerId,excluded=[]){let structs=[];let passed=true;let checkedId="";await Promise.all(Object.keys(this.collections).map(async(name,j)=>{if(passed&&excluded.indexOf(name)<0){let cursor=this.db.collection(name).find({ownerId});let count=await cursor.count();for(let k=0;k<count;k++){let struct=await cursor.next();if(!ownerId)passed=true;else if((getStringId(user._id)!==ownerId||getStringId(user._id)===ownerId&&user.userRoles?.admincontrol)&&checkedId!==ownerId){if(this.useAuths)passed=await this.checkAuthorization(user,struct);checkedId=ownerId}if(passed)structs.push(struct)}}}));if(!passed)return[];return structs}async getMongoDataByRefs(user,structRefs=[]){let structs=[];if(structs.length>0){let checkedAuth="";structRefs.forEach(async ref=>{if(ref.structType&&getStringId(ref._id)){let struct=await this.db.collection(ref.structType).findOne({_id:toObjectID(ref._id)});if(struct){let passed=true;if(!struct?.ownerId)passed=true;else if((getStringId(user._id)!==struct.ownerId||getStringId(user._id)===struct.ownerId&&user.userRoles?.admincontrol)&&checkedAuth!==struct.ownerId){if(this.useAuths)passed=await this.checkAuthorization(user,struct);checkedAuth=struct.ownerId}if(passed===true){structs.push(struct)}}}})}return structs}async getMongoAuthorizations(user,ownerId=getStringId(user._id),authId=""){let auths=[];if(authId.length===0){let cursor=this.collections.authorization.instance.find({ownerId});if(await cursor.count>0){await cursor.forEach(a=>{auths.push(a)})}}else auths.push(await this.collections.authorization.instance.findOne({_id:toObjectID(authId),ownerId}));if(!auths[0]?.ownerId)true;else if(getStringId(user._id)!==auths[0]?.ownerId){let passed=!this.useAuths;if(this.useAuths)passed=await this.checkAuthorization(user,auths[0]);if(!passed)return void 0}return auths}async getMongoGroups(user,userId=getStringId(user._id),groupId=""){let groups=[];if(groupId.length===0){let cursor=this.collections.group.instance.find({users:{$all:[userId]}});if(await cursor.count>0){await cursor.forEach(a=>{groups.push(a)})}}else{try{groups.push(await this.collections.group.instance.findOne({_id:toObjectID(groupId),users:{$all:[userId]}}))}catch{}}return groups}async deleteMongoData(user,structRefs=[]){let structs=[];await Promise.all(structRefs.map(async ref=>{try{let _id=toObjectID(ref._id);let struct=await this.db.collection(ref.structType).findOne({_id});if(struct){structs.push(struct);let notifications=await this.collections.notifications.instance.find({parent:{structType:ref.structType,_id:getStringId(ref._id)}});let count=await notifications.count();for(let i=0;i<count;i++){let note=await notifications.next();if(note)structs.push(note)}}}catch{}}));let checkedOwner="";await Promise.all(structs.map(async(struct,i)=>{let passed=true;if(!struct?.ownerId)passed=true;else if((struct.ownerId!==getStringId(user._id)||getStringId(user._id)===struct.ownerId&&user.userRoles?.admincontrol)&&struct.ownerId!==checkedOwner){checkedOwner=struct.ownerId;if(this.useAuths)passed=await this.checkAuthorization(user,struct,"WRITE")}if(passed){await this.db.collection(struct.structType).deleteOne({_id:toObjectID(struct._id)});if(struct.users){Object.keys(struct.users).forEach(uid=>{if(uid!==getStringId(user._id)&&uid!==struct.ownerId&&this.users[uid])this.users[uid].send({route:"structDeleted",args:getStringId(struct._id)})})}if(struct.ownerId!==user._id&&this.users[struct.ownerId]){this.users[struct.ownerId].send({route:"structDeleted",args:getStringId(struct._id)})}}}));return true}async deleteMongoUser(user,userId){if(getStringId(user._id)!==userId||getStringId(user._id)===userId&&user.userRoles?.admincontrol){let u=await this.collections.profile.instance.findOne({id:userId});let passed=!this.useAuths;if(!u?.ownerId)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,u,"WRITE");if(!passed)return false}await this.collections.profile.instance.deleteOne({id:userId});if(getStringId(user._id)!==userId&&this.users[userId])this.users[userId].send({route:"structDeleted",args:userId});return true}async deleteMongoGroup(user,groupId){let s=await this.collections.group.instance.findOne({_id:toObjectID(groupId)});if(s){if(!s?.ownerId)true;else if(getStringId(user._id)!==s.ownerId||getStringId(user._id)===s.ownerId&&user.userRoles?.admincontrol){let passed=!this.useAuths;if(this.useAuths)passed=await this.checkAuthorization(user,s,"WRITE");if(!passed)return false}if(s.users){Object.keys(s.users).forEach(u=>{this.users[s.authorizerId].send({route:"structDeleted",args:getStringId(s._id)})})}await this.collections.group.instance.deleteOne({_id:toObjectID(groupId)});return true}else return false}async deleteMongoAuthorization(user,authId){let s=await this.collections.authorization.instance.findOne({_id:toObjectID(authId)});if(s){if(getStringId(user._id)!==s.ownerId||getStringId(user._id)===s.ownerId&&user.userRoles?.admincontrol){let passed=!this.useAuths;if(!s?.ownerId)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,s,"WRITE");if(!passed)return false}if(s.associatedAuthId){if(this.debug)console.log(s);await this.collections.authorization.instance.deleteOne({_id:toObjectID(s.associatedAuthId)});if(s.authorizerId&&s.authorizerId!==getStringId(user._id))this.users[s.authorizerId].send({route:"structDeleted",args:getStringId(s._id)});else if(s.authorizedId&&s.authorizedId!==getStringId(user._id))this.users[s.authorizerId].send({route:"structDeleted",args:getStringId(s._id)})}await this.collections.authorization.instance.deleteOne({_id:toObjectID(authId)});return true}else return false}async setAuthorization(user,authStruct,mode=this.mode){let u1,u2;if(mode.includes("mongo")){u1=(await this.getMongoUser(user,authStruct.authorizedId,true)).user;u2=(await this.getMongoUser(user,authStruct.authorizerId,true)).user}else{u1=this.getLocalData("profile",{"_id":authStruct.authorizedId})[0];u2=this.getLocalData("profile",{"_id":authStruct.authorizerId})[0]}if(!u1||!u2)return false;if(authStruct.authorizedId!==getStringId(u1._id))authStruct.authorizedId=getStringId(u1._id);if(authStruct.authorizerId!==getStringId(u2._id))authStruct.authorizerId=getStringId(u2._id);if(!authStruct.authorizedName){if(u1.username)authStruct.authorizedName=u1.username;else if(u1.email)authStruct.authorizedName=u1.email}if(!authStruct.authorizerName){if(u2.username)authStruct.authorizerName=u2.username;else if(u2.email)authStruct.authorizerName=u2.email}if(!authStruct?.ownerId)true;else if((getStringId(user._id)!==authStruct.ownerId||getStringId(user._id)===authStruct.ownerId&&user.userRoles?.admincontrol)&&(getStringId(user._id)!==authStruct.authorizedId&&getStringId(user._id)!==authStruct.authorizerId)){let passed=!this.useAuths;if(this.useAuths)passed=await this.checkAuthorization(user,authStruct,"WRITE");if(!passed)return false}let auths=[];if(mode.includes("mongo")){let s=this.collections.authorization.instance.find({$and:[{authorizedId:authStruct.authorizedId},{authorizerId:authStruct.authorizerId}]});if(await s.count()>0){await s.forEach(d2=>auths.push(d2))}}else{let s=this.getLocalData("authorization",{authorizedId:authStruct.authorizedId});if(Array.isArray(s)){s.forEach(d2=>{if(d2.authorizerId===authStruct.authorizerId)auths.push(d2)})}}let otherAuthset;if(Array.isArray(auths)){auths.forEach(async auth=>{if(auth.ownerId===getStringId(user._id)){}else{if(authStruct.authorizerId===getStringId(user._id)){auth.authorizations=authStruct.authorizations;auth.structs=authStruct.structs;auth.excluded=authStruct.excluded;auth.expires=authStruct.expires;auth.status="OKAY";authStruct.status="OKAY"}else{authStruct.authorizations=auth.authorizations;authStruct.structs=auth.structs;authStruct.excluded=auth.excluded;authStruct.expires=auth.expires;auth.status="OKAY";authStruct.status="OKAY"}authStruct.associatedAuthId=getStringId(auth._id);auth.associatedAuthId=getStringId(authStruct._id);otherAuthset=auth;let copy2=JSON.parse(JSON.stringify(auth));if(mode.includes("mongo")){delete copy2._id;await this.collections.authorization.instance.updateOne({$and:[{authorizedId:authStruct.authorizedId},{authorizerId:authStruct.authorizerId},{ownerId:auth.ownerId}]},{$set:copy2},{upsert:true})}else{this.setLocalData(copy2)}}})}let copy=JSON.parse(JSON.stringify(authStruct));if(mode.includes("mongo")){delete copy._id;await this.collections.authorization.instance.updateOne({$and:[{authorizedId:authStruct.authorizedId},{authorizerId:authStruct.authorizerId},{ownerId:authStruct.ownerId}]},{$set:copy},{upsert:true})}else{this.setLocalData(copy)}if(getStringId(authStruct._id).includes("defaultId")&&mode.includes("mongo")){let replacedAuth=await this.collections.authorization.instance.findOne(copy);if(replacedAuth){authStruct._id=getStringId(replacedAuth._id);if(otherAuthset){let otherAuth=await this.collections.authorization.instance.findOne({$and:[{authorizedId:otherAuthset.authorizedId},{authorizerId:otherAuthset.authorizerId},{ownerId:otherAuthset.ownerId}]});if(otherAuth){otherAuth.associatedAuthId=getStringId(authStruct._id);let copy2=JSON.parse(JSON.stringify(otherAuth));delete copy2._id;await this.collections.authorization.instance.updateOne({$and:[{authorizedId:otherAuth.authorizedId},{authorizerId:otherAuth.authorizerId},{ownerId:otherAuth.ownerId}]},{$set:copy2},{upsert:true});this.checkToNotify(user,[otherAuth])}}}}return authStruct}async checkAuthorization(user,struct,request="READ",mode=this.mode){if(!user||!struct)return false;if(!struct.ownerId)return true;if(typeof user==="object"){if(struct.ownerId===getStringId(user._id)){if(user.userRoles?.["admincontrol"]){}else return true}}else if(typeof user==="string"){if(struct.ownerId===user){return true}else user={_id:user}}let auth1,auth2;if(mode.includes("mongo")){auth1=await this.collections.authorization.instance.findOne({$or:[{authorizedId:getStringId(user._id),authorizerId:struct.ownerId,ownerId:getStringId(user._id)},{authorizedId:struct.ownerId,authorizerId:getStringId(user._id),ownerId:getStringId(user._id)}]});auth2=await this.collections.authorization.instance.findOne({$or:[{authorizedId:getStringId(user._id),authorizerId:struct.ownerId,ownerId:struct.ownerId},{authorizedId:struct.ownerId,authorizerId:getStringId(user._id),ownerId:struct.ownerId}]})}else{auth1=this.getLocalData("authorization",{ownerId:getStringId(user._id)}).find(o=>{if(o.authorizedId===getStringId(user._id)&&o.authorizerId===struct.ownerId)return true});auth2=this.getLocalData("authorization",{ownerId:struct.ownerId}).find(o=>{if(o.authorizedId===getStringId(user._id)&&o.authorizerId===struct.ownerId)return true})}if(!auth1||!auth2){return false}let passed=false;if(auth1.status==="OKAY"&&auth2.status==="OKAY"){if(struct.structType==="group"){if(auth1.authorizations[struct.name+"_admin"]&&auth2.authorizations[struct.name+"_admin"])passed=true;else passed=false}else if(auth1.authorizations["peer"]&&auth2.authorizations["peer"])passed=true;else if(auth1.authorizations["admincontrol"]&&auth2.authorizations["admincontrol"])passed=true;else if(auth1.structIds[getStringId(struct._id)]&&auth2.structIds[getStringId(struct._id)])passed=true;else if(auth1.excluded[struct.structType]&&struct.ownerId===getStringId(user._id)&&request==="WRITE")passed=false}return passed}overwriteLocalData(structs){if(Array.isArray(structs)){structs.forEach(struct=>{let localdat=this.getLocalData(struct.structType,{"ownerId":struct.ownerId,"_id":getStringId(struct._id)});if(!localdat||localdat?.length===0){this.setLocalData(struct)}else Object.assign(localdat,struct)})}else{let localdat=this.getLocalData(structs.structType,{"ownerId":structs.ownerId,"_id":getStringId(structs._id)});if(!localdat||localdat?.length===0){this.setLocalData(structs)}else Object.assign(localdat,structs)}}setLocalData(structs){let setInCollection=s=>{let type=s.structType;let collection=this.collections[type]?.reference;if(!collection){collection={};if(!this.collections[type])this.collections[type]={};this.collections[type].reference=collection}collection[getStringId(s._id)]=s};if(Array.isArray(structs)){structs.forEach(s=>{setInCollection(s)})}else setInCollection(structs)}getLocalData(collection,query){let ownerId,key,value;if(typeof query==="object"){ownerId=query.ownerId;const keys=Object.keys(query).filter(k=>k!="ownerId");key=keys[0];value=query[key]}else value=query;if(!collection&&!ownerId&&!key&&!value)return[];let result=[];if(!collection&&(ownerId||key)){Object.values(this.collections).forEach(c=>{c=c.reference;if((key==="_id"||key==="id")&&value){let found=c[value];if(found)result.push(found)}else{Object.values(c).forEach(struct=>{if(key&&value){if(struct[key]===value&&struct.ownerId===ownerId){result.push(struct)}}else if(struct.ownerId===ownerId){result.push(struct)}})}});return result}else{let c=this.collections[collection]?.reference;if(!c)return result;if(!key&&!ownerId){Object.values(c).forEach(struct=>{result.push(struct)});return result}if((key==="_id"||key==="id")&&value)return getStringId(c[value]);else{Object.keys(c).forEach(k=>{const struct=c[k];if(key&&value&&!ownerId){if(struct[key]===value)result.push(struct)}else if(ownerId&&!key){if(struct.ownerId===ownerId)result.push(struct)}else if(ownerId&&key&&value){if(struct.ownerId===ownerId&&struct[key]){if(struct[key]===value)result.push(struct)}}})}}return result}deleteLocalData(struct){if(!struct)throw new Error("Struct not supplied");if(!struct.structType||!struct._id)return false;if(this.collections[struct.structType])delete this.collections[struct.structType].reference[struct._id];return true}};var Systems={collision:{setupEntities:function(entities){for(const key in entities){const entity=entities[key];if(entity.components){if(!entity.components[this.__node.tag])continue}this.setupEntity(entity)}return entities},setupEntity:function(entity){if(!("collisionEnabled"in entity))entity.collisionEnabled=true;if(!entity.collisionType)entity.collisionType="sphere";if(!entity.collisionRadius)entity.collisionRadius=1;if(!entity.collisionBoundsScale)entity.collisionBoundsScale={x:1,y:1,z:1};if(!entity.colliding)entity.colliding={};if(!entity.position)entity.position={x:0,y:0,z:0};return entity},__node:{tag:"collision"},__operator:function(entities){let keys=this.entityKeys;for(let i=0;i<keys.length;i++){const entity1=entities[keys[i]];if(entity1.components){if(!entity1.components[this.__node.tag]||!entity1.collisionEnabled)continue}if(!entity1.collisionEnabled)continue;for(let j=0;j<keys.length;j++){if(i===j)continue;const entity2=entities[keys[j]];if(entity2.components){if(!entity2.components[this.__node.tag])continue}if(!entity2.collisionEnabled)continue;let colliding=Systems.collision.collisionCheck(entity1,entity2);if(colliding!==false){if(!entity1.colliding)entity1.colliding={};if(!entity2.colliding)entity2.colliding={};entity1.colliding[entity2.__node.tag]=colliding;entity2.colliding[entity1.__node.tag]=colliding}}}return entities},collisionCheck:(body1,body2)=>{if(body1.collisionEnabled===false||body2.collisionEnabled===false)return false;const dist=Systems.collision.distance(body1.position,body2.position);if(dist<Math.max(...Object.values(body1.collisionBoundsScale))*body1.collisionRadius+Math.max(...Object.values(body2.collisionBoundsScale))*body2.collisionRadius){let isColliding=false;if(body1.collisionType==="sphere"){if(body2.collisionType==="sphere"){isColliding=Systems.collision.sphereCollisionCheck(body1,body2,dist)}else if(body2.collisionType==="box"){isColliding=Systems.collision.sphereBoxCollisionCheck(body1,body2,dist)}else if(body2.collisionType==="point"){isColliding=Systems.collision.isPointInsideSphere(body2.position,body1,dist)}}else if(body1.collisionType==="box"){if(body2.collisionType==="sphere"){isColliding=Systems.collision.sphereBoxCollisionCheck(body2,body1,dist)}else if(body2.collisionType==="box"){isColliding=Systems.collision.boxCollisionCheck(body1,body2)}else if(body2.collisionType==="point"){isColliding=Systems.collision.isPointInsideBox(body1.position,body1)}}else if(body1.collisionType==="point"){if(body2.collisionType==="sphere"){isColliding=Systems.collision.isPointInsideSphere(body1.position,body2,dist)}else if(body2.collisionType==="box"){isColliding=Systems.collision.isPointInsideBox(body1.position,body2)}}if(isColliding)return dist}return false},sphereCollisionCheck:(body1,body2,dist)=>{if(dist===void 0)dist=Systems.collision.distance(body1.position,body2.position);return dist<body1.collisionRadius+body2.collisionRadius},boxCollisionCheck:(body1,body2)=>{let body1minX=(body1.position.x-body1.collisionRadius)*body1.collisionBoundsScale.x;let body1maxX=(body1.position.x+body1.collisionRadius)*body1.collisionBoundsScale.x;let body1minY=(body1.position.y-body1.collisionRadius)*body1.collisionBoundsScale.y;let body1maxY=(body1.position.y+body1.collisionRadius)*body1.collisionBoundsScale.y;let body1minZ=(body1.position.z-body1.collisionRadius)*body1.collisionBoundsScale.z;let body1maxZ=(body1.position.z+body1.collisionRadius)*body1.collisionBoundsScale.z;let body2minX=(body2.position.x-body2.collisionRadius)*body1.collisionBoundsScale.x;let body2maxX=(body2.position.x+body2.collisionRadius)*body1.collisionBoundsScale.x;let body2minY=(body2.position.y-body2.collisionRadius)*body1.collisionBoundsScale.y;let body2maxY=(body2.position.y+body2.collisionRadius)*body1.collisionBoundsScale.y;let body2minZ=(body2.position.z-body2.collisionRadius)*body1.collisionBoundsScale.z;let body2maxZ=(body2.position.z+body2.collisionRadius)*body1.collisionBoundsScale.z;return(body1maxX<=body2maxX&&body1maxX>=body2minX||body1minX<=body2maxX&&body1minX>=body2minX)&&(body1maxY<=body2maxY&&body1maxY>=body2minY||body1minY<=body2maxY&&body1minY>=body2minY)&&(body1maxZ<=body2maxZ&&body1maxZ>=body2minZ||body1minZ<=body2maxZ&&body1minZ>=body2minZ)},sphereBoxCollisionCheck:(sphere,box,dist)=>{let boxMinX=(box.position.x-box.collisionRadius)*box.collisionBoundsScale.x;let boxMaxX=(box.position.x+box.collisionRadius)*box.collisionBoundsScale.x;let boxMinY=(box.position.y-box.collisionRadius)*box.collisionBoundsScale.y;let boxMaxY=(box.position.y+box.collisionRadius)*box.collisionBoundsScale.y;let boxMinZ=(box.position.z-box.collisionRadius)*box.collisionBoundsScale.z;let boxMaxZ=(box.position.z+box.collisionRadius)*box.collisionBoundsScale.z;let clamp={x:Math.max(boxMinX,Math.min(sphere.position.x,boxMaxX)),y:Math.max(boxMinY,Math.min(sphere.position.y,boxMaxY)),z:Math.max(boxMinZ,Math.min(sphere.position.z,boxMaxZ))};if(dist===void 0)dist=Systems.collision.distance(sphere.position,clamp);return dist>sphere.collisionRadius},isPointInsideSphere:(point,sphere,dist)=>{if(dist===void 0)dist=Systems.collision.distance(point,sphere.position);return dist<sphere.collisionRadius},isPointInsideBox:(point,box)=>{let boxminX=(box.position.x-box.collisionRadius)*box.collisionBoundsScale.x;let boxmaxX=(box.position.x+box.collisionRadius)*box.collisionBoundsScale.x;let boxminY=(box.position.y-box.collisionRadius)*box.collisionBoundsScale.x;let boxmaxY=(box.position.y+box.collisionRadius)*box.collisionBoundsScale.x;let boxminZ=(box.position.z-box.collisionRadius)*box.collisionBoundsScale.x;let boxmaxZ=(box.position.z+box.collisionRadius)*box.collisionBoundsScale.x;return point.x>=boxminX&&point.x<=boxmaxX&&(point.y>=boxminY&&point.y<=boxmaxY)&&(point.z>=boxminZ&&point.z<=boxmaxZ)},closestPointOnLine:(point,lineStart,lineEnd)=>{let a={x:lineEnd.x-lineStart.x,y:lineEnd.y-lineStart.y,z:lineEnd.z-lineStart.z};let b2={x:lineStart.x-point.x,y:lineStart.y-point.y,z:lineStart.z-point.z};let c={x:lineEnd.x-point.x,y:lineEnd.y-point.y,z:lineEnd.z-point.z};let bdota=Systems.collision.dot(b2,a);if(bdota<=0)return lineStart;let cdota=Systems.collision.dot(c,a);if(cdota<=0)return lineEnd;let _bdotapluscdota=1/(bdota+cdota);return{x:lineStart.x+(lineEnd.x-lineStart.x)*bdota*_bdotapluscdota,y:lineStart.y+(lineEnd.y-lineStart.y)*bdota*_bdotapluscdota,z:lineStart.z+(lineEnd.z-lineStart.z)*bdota*_bdotapluscdota}},closestPointOnPolygon:(point,t0,t1,t2)=>{let n=Systems.collision.calcNormal(t0,t1,t2);let dist=Systems.collision.dot(point,n)-Systems.collision.dot(t0,n);let projection=Systems.collision.vecadd(point,Systems.collision.vecscale(n,-dist));let v0x=t2[0]-t0[0];let v0y=t2[1]-t0[1];let v0z=t2[2]-t0[2];let v1x=t1[0]-t0[0];let v1y=t1[1]-t0[1];let v1z=t1[2]-t0[2];let v2x=projection[0]-t0[0];let v2y=projection[1]-t0[1];let v2z=projection[2]-t0[2];let dot00=v0x*v0x+v0y*v0y+v0z*v0z;let dot01=v0x*v1x+v0y*v1y+v0z*v1z;let dot02=v0x*v2x+v0y*v2y+v0z*v2z;let dot11=v1x*v1x+v1y*v1y+v1z*v1z;let dot12=v1x*v2x+v1y*v2y+v1z*v2z;let denom=dot00*dot11-dot01*dot01;if(Math.abs(denom)<1e-30){return void 0}let _denom=1/denom;let u=(dot11*dot02-dot01*dot12)*_denom;let v2=(dot00*dot12-dot01*dot02)*_denom;if(u>=0&&v2>=0&&u+v2<1){return projection}else return void 0},calcNormal:(t0,t1,t2,positive=true)=>{var QR=Systems.collision.makeVec(t0,t1);var QS=Systems.collision.makeVec(t0,t2);if(positive===true){return Systems.collision.normalize(Systems.collision.cross3D(QR,QS))}else{return Systems.collision.normalize(Systems.collision.cross3D(QS,QR))}},dot:(v1,v2)=>{let dot=0;for(const key in v1){dot+=v1[key]*v2[key]}return dot},makeVec(p1,p2){return{x:p2.x-p1.x,y:p2.y-p1.y,z:p2.z-p1.z}},vecadd:(v1,v2)=>{let result=Object.assign({},v1);for(const key in result){result[key]+=v2[key]}return result},vecsub:(v1,v2)=>{let result=Object.assign({},v1);for(const key in result){result[key]-=v2[key]}return result},vecmul:(v1,v2)=>{let result=Object.assign({},v1);for(const key in result){result[key]*=v2[key]}return result},vecdiv:(v1,v2)=>{let result=Object.assign({},v1);for(const key in result){result[key]/=v2[key]}return result},vecscale:(v1,scalar)=>{let result=Object.assign({},v1);for(const key in result){result[key]*=scalar}return result},distance:(v1,v2)=>{let distance=0;for(const key in v1){distance+=Math.pow(v1[key]-v2[key],2)}return Math.sqrt(distance)},magnitude:v2=>{let magnitude=0;for(const key in v2){magnitude+=v2[key]*v2[key]}return Math.sqrt(magnitude)},normalize:v2=>{let magnitude=Systems.collision.magnitude(v2);let _mag=magnitude?1/magnitude:0;let vn=Object.assign({},v2);for(const key in v2){vn[key]=v2[key]*_mag}return vn},distance3D(v1,v2){return Math.sqrt((v1.x-v2.x)*(v1.x-v2.x)+(v1.y-v2.y)*(v1.y-v2.y)+(v1.z-v2.z)*(v1.z-v2.z))},cross3D(v1,v2){return{x:v1.y*v2.z-v1.z*v2.y,y:v1.z*v2.x-v1.x*v2.z,z:v1.x*v2.y-v1.y*v2.x}},nearestNeighborSearch(entities,isWithinRadius=1e15){var tree={};;for(const key in entities){let newnode={tag:key,position:void 0,neighbors:[]};newnode.position=entities[key].position;tree[key]=newnode}for(const i in tree){for(const j in tree){var dist=Systems.collision.distance3D(tree[i].position,tree[j].position);if(dist<isWithinRadius){var newNeighbori={tag:j,position:entities[j].position,dist};tree[i].neighbors.push(newNeighbori);var newNeighborj={tag:j,position:entities[i].position,dist};tree[j].neighbors.push(newNeighborj)}}tree[i].neighbors.sort(function(a,b2){return a.dist-b2.dist})}return tree},generateBoundingVolumeTree(entities,mode="octree",withinRadius=1e15,minEntities=3){let dynamicBoundingVolumeTree={proto:{parent:void 0,children:{},entities:{},collisionType:"box",collisionRadius:1,collisionBoundsScale:{x:1,y:1,z:1},position:{x:0,y:0,z:0}},tree:{}};let maxX,maxY,maxZ;let minX=0,minY=0,minZ=0;let positions={};let minRadius=withinRadius;for(const key in entities){const body=entities[key];let xx=body.position.x+body.collisionRadius*body.collisionBoundsScale.x;let yy=body.position.y+body.collisionRadius*body.collisionBoundsScale.y;let zz=body.position.z+body.collisionRadius*body.collisionBoundsScale.z;if(maxX<xx)maxX=xx;if(minX>xx)minX=xx;if(maxY<yy)maxY=yy;if(minY>yy)minY=yy;if(maxZ<zz)maxZ=zz;if(minZ>zz)minZ=zz;if(minRadius>body.collisionRadius)minRadius=body.collisionRadius;positions[key]=body.position};let head=JSON.parse(JSON.stringify(dynamicBoundingVolumeTree.proto));let boxpos={x:(maxX+minX)*.5,y:(maxY+minY)*.5,z:(maxZ+minZ)*.5};let boxbounds={x:maxX-boxpos.x,y:maxY-boxpos.y,z:maxZ-boxpos.z};head.position=boxpos;head.collisionBoundsScale=boxbounds;head.entities=entities;dynamicBoundingVolumeTree.tree=head;minRadius*=2;if(mode==="octree"){let genOct=function(parentPos,halfbounds){let oct1={x:parentPos.x+halfbounds.x,y:parentPos.y+halfbounds.y,z:parentPos.z+halfbounds.z};let oct2={x:parentPos.x-halfbounds.x,y:parentPos.y+halfbounds.y,z:parentPos.z+halfbounds.z};let oct3={x:parentPos.x+halfbounds.x,y:parentPos.y-halfbounds.y,z:parentPos.z+halfbounds.z};let oct4={x:parentPos.x+halfbounds.x,y:parentPos.y+halfbounds.y,z:parentPos.z-halfbounds.z};let oct5={x:parentPos.x-halfbounds.x,y:parentPos.y-halfbounds.y,z:parentPos.z+halfbounds.z};let oct6={x:parentPos.x-halfbounds.x,y:parentPos.y+halfbounds.y,z:parentPos.z-halfbounds.z};let oct7={x:parentPos.x+halfbounds.x,y:parentPos.y-halfbounds.y,z:parentPos.z-halfbounds.z};let oct8={x:parentPos.x-halfbounds.x,y:parentPos.y-halfbounds.y,z:parentPos.z-halfbounds.z};return[oct1,oct2,oct3,oct4,oct5,oct6,oct7,oct8]},genOctTree=function(head2){let halfbounds={x:head2.collisionBoundsScale.x*.5,y:head2.collisionBoundsScale.y*.5,z:head2.collisionBoundsScale.z*.5};let octPos=genOct(head2.position,halfbounds);let check=Object.assign({},head2.bodies);for(let i=0;i<8;i++){let octquadrant=Object.assign(JSON.parse(JSON.stringify(dynamicBoundingVolumeTree.proto)),{position:octPos[i],collisionBoundsScale:halfbounds});octquadrant.parent=head2;for(const j in check){let collided=Systems.collision.collisionCheck(check[j],octquadrant);if(collided){octquadrant.entities[j]=check[j];delete check[j]}}if(Object.keys(octquadrant.entities).length>minEntities-1){head2.children[i]=octquadrant;octquadrant.parent=head2;if(Object.keys(octquadrant.entities).length>minEntities&&octquadrant.collisionRadius*.5>minRadius){genOctTree(octquadrant)}}}};genOctTree(head);return head}else{let tree=Systems.collision.nearestNeighborSearch(positions,withinRadius);let keys=Object.keys(tree);let tag=keys[Math.floor(Math.random()*keys.length)];let searching=true;let count=0;let genBoundingBoxLevel=(tree2,volumes)=>{let newVolumes={};let foundidxs={};let treekeys=Object.keys(tree2);while(searching&&count<treekeys.length){let node=tree2[tag];let i=0;let j=0;let ux=positions[node.tag].x-volumes[node.tag].collisionBoundsScale.x,uy=positions[node.tag].y-volumes[node.tag].collisionBoundsScale.y,uz=positions[node.tag].z-volumes[node.tag].collisionBoundsScale.z,mx=positions[node.tag].x+volumes[node.tag].collisionBoundsScale.x,my=positions[node.tag].y+volumes[node.tag].collisionBoundsScale.y,mz=positions[node.tag].z+volumes[node.tag].collisionBoundsScale.z;let newvolume=JSON.parse(JSON.stringify(dynamicBoundingVolumeTree.proto));newvolume.tag=`bound${Math.floor(Math.random()*1e15)}`;newvolume.children[node.tag]=volumes[node.tag];newvolume.bodies[node.tag]=entities[node.tag];volumes[node.tag].parent=newvolume;foundidxs[node.tag]=true;i++;j++;let nkeys=Object.keys(node.neighbors);while(i<nkeys.length&&j<3){if(foundidxs[node.neighbors[i].tag]){i++;continue}let uxn=positions[node.neighbors[i].tag].x-volumes[node.neighbors[i].tag].collisionBoundsScale.x,uyn=positions[node.neighbors[i].tag].y-volumes[node.neighbors[i].tag].collisionBoundsScale.y,uzn=positions[node.neighbors[i].tag].z-volumes[node.neighbors[i].tag].collisionBoundsScale.z,mxn=positions[node.neighbors[i].tag].x+volumes[node.neighbors[i].tag].collisionBoundsScale.x,myn=positions[node.neighbors[i].tag].y+volumes[node.neighbors[i].tag].collisionBoundsScale.y,mzn=positions[node.neighbors[i].tag].z+volumes[node.neighbors[i].tag].collisionBoundsScale.z;if(ux>uxn)ux=uxn;if(mx<mxn)mx=mxn;if(uy>uyn)uy=uyn;if(my<myn)my=myn;if(uz>uzn)uz=uzn;if(mz<mzn)mz=mzn;newvolume.children[node.neighbors[i].tag]=volumes[node.neighbors[i].tag];newvolume.entities[node.neighbors[i].tag]=entities[node.neighbors[i].tag];volumes[node.neighbors[i].tag].parent=newvolume;foundidxs[node.neighbors[i].tag]=true;i++;j++}let pos={x:(mx+ux)*.5,y:(my+uy)*.5,z:(mz+uz)*.5};let bounds={x:mx-pos.x,y:my-pos.y,z:mz-pos.z};newvolume.position=pos;newvolume.collisionBoundsScale=bounds;if(newvolume.bodies.length===1)newvolume=node;newVolumes[newvolume.tag]=newvolume;while(i<node.neighbors.length){if(!foundidxs[node.neighbors[i].tag])break;i++}if(i<node.neighbors.length){tag=node.neighbors[i].tag}else if(Object.keys(foundidxs).length<Object.keys(tree2).length){tag=keys[0]}else searching=false;count++}return newVolumes};let result=genBoundingBoxLevel(tree,entities);while(Object.keys(result).length>2){let nextTree=Systems.collision.nearestNeighborSearch(result,withinRadius);result=genBoundingBoxLevel(nextTree,result)}head.children=result;head.children.forEach(n=>{n.parent=head});return head}}},collider:{lastTime:performance.now(),setupEntities:function(entities){for(const key in entities){const entity=entities[key];if(entity.components){if(!entity.components[this.__node.tag])continue}this.setupEntity(entity)}return entities},setupEntity:function(entity){if(!("collisionEnabled"in entity))Systems.collision.setupEntity(entity);if(!("boundingBox"in entity))entity.boundingBox={bot:0,top:100,left:0,right:100,front:0,back:100};if(!("position"in entity)){Systems.movement.setupEntity(entity)}if(!("restitution"in entity))entity.restitution=1;if(!("useBoundingBox"in entity))entity.useBoundingBox=true;if(!entity.position.x&&!entity.position.y&&!entity.position.z){entity.position.x=Math.random()*entity.boundingBox.right;entity.position.y=Math.random()*entity.boundingBox.back;entity.position.z=Math.random()*entity.boundingBox.top}return entity},__operator:function(entities){let keys=this.entityKeys;for(let i=0;i<keys.length;i++){const entity1=entities[keys[i]];if(entity1.components){if(!entity1.components[this.__node.tag]||!entity1.collisionEnabled)continue}if(entity1.useBoundingBox)this.checkBoundingBox(entity1);if(!entity1.collisionEnabled)continue;if(entity1.colliding){for(const key2 in entity1.colliding){const entity2=entities[key2];if(entity1.colliding[key2]===false){delete entity1.colliding[key2];delete entity2.colliding[entity1.__node.tag];continue}if(!entity2.collisionEnabled)continue;if(entity2.collisionType==="box"){this.resolveBoxCollision(entity1,entity2,entity1.colliding[key2])}else{if(entity1.collisionType==="box"){entity1.fixed=true;this.resolveSphereCollisions(entity1,entity2,entity1.colliding[key2]);entity1.fixed=false}else{this.resolveSphereCollisions(entity1,entity2,entity1.colliding[key2]);delete entity2.colliding[entity1.__node.tag]}}delete entity1.colliding[entity2.__node.tag]}delete entity1.colliding}}return entities},__node:{tag:"collider"},checkBoundingBox:entity=>{const xsize=entity.collisionRadius*entity.collisionBoundsScale.x;const ysize=entity.collisionRadius*entity.collisionBoundsScale.y;const zsize=entity.collisionRadius*entity.collisionBoundsScale.z;if(entity.position.y-ysize<=entity.boundingBox.front){entity.velocity.y*=-entity.restitution;entity.position.y=entity.boundingBox.front+ysize}if(entity.position.y+ysize>=entity.boundingBox.back){entity.velocity.y*=-entity.restitution;entity.position.y=entity.boundingBox.back-ysize}if(entity.position.x-xsize<=entity.boundingBox.left){entity.velocity.x*=-entity.restitution;entity.position.x=entity.boundingBox.left+xsize}if(entity.position.x+xsize>=entity.boundingBox.right){entity.velocity.x*=-entity.restitution;entity.position.x=entity.boundingBox.right-xsize}if(entity.position.z-zsize<=entity.boundingBox.bot){entity.velocity.z*=-entity.restitution;entity.position.z=entity.boundingBox.bot+zsize}if(entity.position.z+zsize>=entity.boundingBox.top){entity.velocity.z*=-entity.restitution;entity.position.z=entity.boundingBox.top-zsize}},resolveBoxCollision:(body1,box,negate)=>{let positionVec=Systems.collision.makeVec(body1.position,box.position);var directionVec=Object.values(positionVec);let closestSide;let closestDist=Infinity;let mul=-1;if(directionVec[idx]<0)mul=1;if(negate)mul=-mul;for(const key in body1.position){let dist=Math.abs(box.position[key]-body1.position[key]);if(dist<closestDist&&Math.abs(box.position[key]-body1.position[key]+body1.velocity[key]*1e-17)<dist){closestSide=key;closestDist=dist}}var idx=directionVec.indexOf(closestSide);if(idx===0)idx="x";if(idx===1)idx="y";if(idx===2)idx="z";if(idx===3)idx="w";let boxEdgeAxisPosition=box.position[idx]+box.collisionRadius*box.collisionBoundsScale[idx]*mul;if(negate){let body1Offset=boxEdgeAxisPosition-body1.collisionRadius*body1.collisionBoundsScale[idx]*mul;body1.position[idx]=body1Offset}else{let body1Offset=boxEdgeAxisPosition+body1.collisionRadius*body1.collisionBoundsScale[idx]*mul;body1.position[idx]=body1Offset}body1.velocity[idx]=-body1.velocity[idx]*body1.restitution;if(negate)body1.force[idx]=-body1.velocity[idx];var body2AccelMag=Systems.collision.magnitude(box.acceleration);var body2AccelNormal=Systems.collision.normalize(box.acceleration);body1.force[idx]=-body2AccelNormal[idx]*body2AccelMag*box.mass;if(negate)body1.force[idx]=-body1.force[idx]},resolveSphereCollisions:(entity1,entity2,dist)=>{if(dist===void 0)dist=Systems.collision.distance(entity1.position,entity2.position);let vecn=Systems.collision.normalize(Systems.collision.makeVec(entity1.position,entity2.position));let sumMass=entity1.mass+entity2.mass;let ratio=entity1.mass/sumMass;let rmin=1-ratio;if(entity1.fixed===false){entity1.position.x+=vecn.x*rmin*1.01;entity1.position.y+=vecn.y*rmin*1.01;entity1.position.z+=vecn.z*rmin*1.001}else{entity2.position.x-=vecn.x*1.01;entity2.position.y-=vecn.y*1.01;entity2.position.z-=vecn.z*1.01}if(entity2.fixed===false){entity2.position.x+=vecn.x*ratio*1.01;entity2.position.y+=vecn.y*ratio*1.01;entity2.position.z+=vecn.z*ratio*1.01}else{entity1.position.x+=vecn.x*1.01;entity1.position.y+=vecn.y*1.01;entity1.position.z+=vecn.z*1.01}dist=Systems.collision.distance(entity1.position,entity2.position);let vrel={x:entity1.velocity.x-entity2.velocity.x,y:entity1.velocity.y-entity2.velocity.y,z:entity1.velocity.z-entity2.velocity.z};let speed=vrel.x*vecn.x+vrel.y*vecn.y+vrel.z*vecn.z;if(speed>0){let impulse=2*speed/sumMass;if(entity1.fixed===false){entity1.velocity.x-=impulse*vecn.x*entity2.mass*entity1.restitution;entity1.velocity.y-=impulse*vecn.y*entity2.mass*entity1.restitution;entity1.velocity.z-=impulse*vecn.z*entity2.mass*entity1.restitution}if(entity2.fixed===false){entity2.velocity.x+=impulse*vecn.x*entity2.mass*entity2.restitution/entity2.mass;entity2.velocity.y+=impulse*vecn.y*entity2.mass*entity2.restitution/entity2.mass;entity2.velocity.z+=impulse*vecn.z*entity2.mass*entity2.restitution/entity2.mass}}}},nbody:{lastTime:performance.now(),G:6674e-14,setupEntities:function(entities){for(const key in entities){const entity=entities[key];if(entity.components){if(!entity.components[this.__node.tag])continue}this.setupEntity(entity)}return entities},setupEntity:function(entity){if(!("collisionEnabled"in entity))Systems.collider.setupEntity(entity);entity.isAttractor=true;if(!("attractorGroup"in entity))entity.attractorGroup=0;if(!("attractorFrameSearchMax"in entity))entity.attractorFrameSearchMax=10;if(!("attractorGroupRules"in entity))entity.attractorGroupRules={0:{G:this.G,maxDist:void 0}};return entity},__operator:function(entities){let keys=this.entityKeys;for(let i=0;i<keys.length;i++){const entity=entities[keys[i]];if(entity.components){if(!entity.components[this.__node.tag])continue}if(!entity.mass)continue;let nSearched=0;nested:for(let j=0;j<keys.length;j++){let randKey=keys[Math.floor(Math.random()*keys.length)];nSearched++;const entity2=entities[randKey];if(entity2.components){if(!entity2.components[this.__node.tag])continue nested}if(!entity2.mass||!entity2.isAttractor)continue nested;this.attract(entity,entity2,void 0,this.G);if(nSearched>entity.attractorFrameSearchMax)break nested}}return entities},__node:{tag:"nbody"},attract:function(body1,body2,dist,G=this.G,vecn){if(dist===void 0)dist=Systems.collision.distance3D(body1.position,body2.position);if(vecn===void 0)vecn=Systems.collision.normalize(Systems.collision.makeVec(body1.position,body2.position));let Fg=0;if(dist<.01)dist=.01;if(body1.attractorGroupRules[body2.attractorGroup]){if(typeof body1.attractorGroupRules[body2.attractorGroup]==="object"){if(body1.attractorGroupRules[body2.attractorGroup].maxDist&&body1.attractorGroupRules[body2.attractorGroup].maxDist<dist){}else Fg=body1.attractorGroupRules[body2.attractorGroup].G*body1.mass*body2.mass/(dist*dist)}else Fg=body1.attractorGroupRules[body2.attractorGroup]*body1.mass*body2.mass/(dist*dist)}else Fg=G*body1.mass*body2.mass/(dist*dist);body1.force.x+=vecn.x*Fg;body1.force.y+=vecn.y*Fg;body1.force.z+=vecn.z*Fg;body2.force.x-=vecn.x*Fg;body2.force.y-=vecn.y*Fg;body2.force.z-=vecn.z*Fg}},boid:{lastTime:performance.now(),defaultAnchor:{x:Math.random(),y:Math.random(),z:Math.random(),mul:.006},setupEntities:function(entities){for(const key in entities){const entity=entities[key];this.setupEntity(entity)}return entities},setupEntity:function(entity){if(!entity.position){Systems.collider.setupEntity(entity)}let adjustedAnchor=Object.assign({},this.defaultAnchor);adjustedAnchor.x*=entity.boundingBox.right;adjustedAnchor.y*=entity.boundingBox.back;adjustedAnchor.z*=entity.boundingBox.top;let boidDefaults={cohesion:1e-5,separation:1e-4,alignment:.006,swirl:adjustedAnchor,attractor:Object.assign(adjustedAnchor,{mul:.002}),useCohesion:true,useSeparation:true,useAlignment:true,useSwirl:true,useAttractor:true,useAttraction:false,groupRadius:200,groupSize:5,searchLimit:5};if(!entity.boid){entity.boid=boidDefaults}else entity.boid=Object.assign(boidDefaults,entity.boid);if(this.entityKeys.length>1e3){entity.boid.groupSize=1;entity.boid.searchLimit=1}return entity},__operator:function(entities){let now=performance.now();let timeStep=now-this.lastTime;this.lastTime=now;let keys=this.entityKeys;let length=keys.length;let _timeStep=1/timeStep;let w2=-1;outer:for(let i=0;i<keys.length;i++){w2++;let p0=entities[keys[i]];const inRange=[];const distances=[];const boidVelocities=[p0.position.x,p0.position.y,p0.position.z,0,0,0,p0.velocity.x,p0.velocity.y,p0.velocity.z,0,0,0,0,0,0,0,0,0];let groupCount=1;let k=-1;nested:for(let j=0;j<keys.length;j++){k++;if(distances.length>p0.boid.groupSize||k>p0.boid.searchLimit){break nested}let randj=keys[Math.floor(Math.random()*length)];if(k===w2||randj===keys[i]||inRange.indexOf(randj)>-1){continue nested}else{let pr=entities[randj];let disttemp=Math.sqrt((p0.position.x-pr.position.x)*(p0.position.x-pr.position.x)+(p0.position.y-pr.position.y)*(p0.position.y-pr.position.y)+(p0.position.z-pr.position.z)*(p0.position.z-pr.position.z));if(disttemp>p0.boid.groupRadius){continue nested}else{distances.push(disttemp);inRange.push(randj);let distInv;if(p0.boid.useSeparation||p0.boid.useAlignment){distInv=p0.boid.groupRadius/(disttemp*disttemp);if(distInv>p0.maxSpeed)distInv=p0.maxSpeed;else if(distInv<-p0.maxSpeed)distInv=-p0.maxSpeed}if(p0.boid.useCohesion){boidVelocities[0]+=(pr.position.x-p0.position.x)*.5*disttemp*_timeStep;boidVelocities[1]+=(pr.position.y-p0.position.y)*.5*disttemp*_timeStep;boidVelocities[2]+=(pr.position.z-p0.position.z)*.5*disttemp*_timeStep}if(isNaN(disttemp)||isNaN(boidVelocities[0])||isNaN(pr.position.x)){console.log(disttemp,i,randj,p0.position,pr.position,boidVelocities);p0.position.x=NaN;return}if(p0.boid.useSeparation){boidVelocities[3]=boidVelocities[3]+(p0.position.x-pr.position.x)*distInv;boidVelocities[4]=boidVelocities[4]+(p0.position.y-pr.position.y)*distInv;boidVelocities[5]=boidVelocities[5]+(p0.position.z-pr.position.z)*distInv}if(p0.boid.useAttraction&&pr.boid.useAttraction){Systems.nbody.attract(p0,pr,disttemp)}if(p0.boid.useAlignment){boidVelocities[6]=boidVelocities[6]+pr.velocity.x*distInv;boidVelocities[7]=boidVelocities[7]+pr.velocity.y*distInv;boidVelocities[8]=boidVelocities[8]+pr.velocity.z*distInv}groupCount++}}}let _groupCount=1/groupCount;if(p0.boid.useCohesion){boidVelocities[0]=p0.boid.cohesion*(boidVelocities[0]*_groupCount);boidVelocities[1]=p0.boid.cohesion*(boidVelocities[1]*_groupCount);boidVelocities[2]=p0.boid.cohesion*(boidVelocities[2]*_groupCount)}else{boidVelocities[0]=0;boidVelocities[1]=0;boidVelocities[2]=0}if(p0.boid.useSeparation){boidVelocities[3]=p0.boid.separation*boidVelocities[3];boidVelocities[4]=p0.boid.separation*boidVelocities[4];boidVelocities[5]=p0.boid.separation*boidVelocities[5]}else{boidVelocities[3]=0;boidVelocities[4]=0;boidVelocities[5]=0}if(p0.boid.useAlignment){boidVelocities[6]=-(p0.boid.alignment*boidVelocities[6]*_groupCount);boidVelocities[7]=p0.boid.alignment*boidVelocities[7]*_groupCount;boidVelocities[8]=p0.boid.alignment*boidVelocities[8]*_groupCount}else{boidVelocities[6]=0;boidVelocities[7]=0;boidVelocities[8]=0}const swirlVec=[0,0,0];if(p0.boid.useSwirl==true){boidVelocities[9]=-(p0.position.y-p0.boid.swirl.y)*p0.boid.swirl.mul;boidVelocities[10]=(p0.position.z-p0.boid.swirl.z)*p0.boid.swirl.mul;boidVelocities[11]=(p0.position.x-p0.boid.swirl.x)*p0.boid.swirl.mul}const attractorVec=[0,0,0];if(p0.boid.useAttractor==true){boidVelocities[12]=(p0.boid.attractor.x-p0.position.x)*p0.boid.attractor.mul;if(p0.position.x>p0.boundingBox.left||p0.position.x<p0.boundingBox.right){boidVelocities[12]*=3}boidVelocities[13]=(p0.boid.attractor.y-p0.position.y)*p0.boid.attractor.mul;if(p0.position.y>p0.boundingBox.top||p0.position.y<p0.boundingBox.bottom){boidVelocities[13]*=3}boidVelocities[14]=(p0.boid.attractor.z-p0.position.z)*p0.boid.attractor.mul;if(p0.position.z>p0.boundingBox.front||p0.position.z<p0.boundingBox.back){boidVelocities[14]*=3}}p0.velocity.x=p0.velocity.x+boidVelocities[0]+boidVelocities[3]+boidVelocities[6]+boidVelocities[9]+boidVelocities[12]+boidVelocities[15],p0.velocity.y=p0.velocity.y+boidVelocities[1]+boidVelocities[4]+boidVelocities[7]+boidVelocities[10]+boidVelocities[13]+boidVelocities[16],p0.velocity.z=p0.velocity.z+boidVelocities[2]+boidVelocities[5]+boidVelocities[8]+boidVelocities[11]+boidVelocities[14]+boidVelocities[17];if(isNaN(p0.velocity.x))console.error(p0,i,groupCount,p0.position,p0.velocity,swirlVec,attractorVec)}return entities},__node:{tag:"boid"}},movement:{__node:{tag:"movement"},lastTime:performance.now(),setupEntities:function(entities){for(const key in entities){const entity=entities[key];if(entity.components){if(!entity.components[this.__node.tag])continue}this.setupEntity(entity)}},setupEntity:function(entity){if(!("mass"in entity))entity.mass=1;if(!("fixed"in entity))entity.fixed=false;if(!entity.force)entity.force={x:0,y:0,z:0};if(!("mass"in entity))entity.mass=1;if(!("gravity"in entity))entity.gravity=-9.81;if(!entity.acceleration)entity.acceleration={x:0,y:0,z:0};if(!entity.velocity)entity.velocity={x:0,y:0,z:0};if(!("maxSpeed"in entity))entity.maxSpeed=10;if(!entity.position)entity.position={x:0,y:0,z:0};return entity},__operator:function(entities){let now=performance.now();let timeStep=(now-this.lastTime)*.001;this.lastTime=now;let keys=this.entityKeys;for(let i=0;i<keys.length;i++){const entity=entities[keys[i]];if(entity.components){if(!entity.components[this.__node.tag])continue}if(entity.fixed)continue;if(entity.mass){if(entity.force.x){entity.acceleration.x+=entity.force.x/entity.mass;entity.force.x=0}if(entity.force.y){entity.acceleration.y+=entity.force.y/entity.mass;entity.force.y=0}if(entity.force.z){entity.acceleration.z+=entity.force.z/entity.mass+entity.gravity;entity.force.z=0}}if(entity.drag){if(entity.acceleration.x)entity.acceleration.x-=entity.acceleration.x*entity.drag*timeStep;if(entity.acceleration.y)entity.acceleration.y-=entity.acceleration.y*entity.drag*timeStep;if(entity.acceleration.z)entity.acceleration.z-=entity.acceleration.z*entity.drag*timeStep}if(entity.acceleration.x)entity.velocity.x+=entity.acceleration.x*timeStep;if(entity.acceleration.y)entity.velocity.y+=entity.acceleration.y*timeStep;if(entity.acceleration.z)entity.velocity.z+=entity.acceleration.z*timeStep;if(entity.maxSpeed>0){let magnitude=Systems.collision.magnitude(entity.velocity);if(magnitude>entity.maxSpeed){let scalar=entity.maxSpeed/magnitude;entity.velocity.x*=scalar;entity.velocity.y*=scalar;entity.velocity.z*=scalar}}if(entity.velocity.x)entity.position.x+=entity.velocity.x*timeStep;if(entity.velocity.y)entity.position.y+=entity.velocity.y*timeStep;if(entity.velocity.z)entity.position.z+=entity.velocity.z*timeStep}return entities}}};var b=class{constructor(e,t,s,h){this.r=e,this.g=t,this.b=s,this.a=h}};var x2=class{constructor(){this.scaleX=1,this.scaleY=1,this.offsetX=0,this.offsetY=0,this.loop=false,this._vbuffer=0,this._coord=0,this.visible=true,this.intensity=1,this.xy=new Float32Array([]),this.numPoints=0,this.color=new b(0,0,0,1),this.webglNumPoints=0}};var v=class extends x2{constructor(e,t){super(),this.currentIndex=0,this.webglNumPoints=t,this.numPoints=t,this.color=e,this.xy=new Float32Array(2*this.webglNumPoints)}setX(e,t){this.xy[e*2]=t}setY(e,t){this.xy[e*2+1]=t}getX(e){return this.xy[e*2]}getY(e){return this.xy[e*2+1]}lineSpaceX(e,t){for(let s=0;s<this.numPoints;s++)this.setX(s,e+t*s)}arrangeX(){this.lineSpaceX(-1,2/this.numPoints)}constY(e){for(let t=0;t<this.numPoints;t++)this.setY(t,e)}shiftAdd(e){let t=e.length;for(let s=0;s<this.numPoints-t;s++)this.setY(s,this.getY(s+t));for(let s=0;s<t;s++)this.setY(s+this.numPoints-t,e[s])}addArrayY(e){if(this.currentIndex+e.length<=this.numPoints)for(let t=0;t<e.length;t++)this.setY(this.currentIndex,e[t]),this.currentIndex++}replaceArrayY(e){if(e.length==this.numPoints)for(let t=0;t<this.numPoints;t++)this.setY(t,e[t])}};var Y=(c,e,t)=>{let s={x:0,y:0};return s.x=c.x+e.x*t,s.y=c.y+e.y*t,s};var _=c=>P(-c.y,c.x);var w=(c,e)=>{let t=T(c,e);return t=M(t),t};var S=(c,e)=>{let t={x:0,y:0};return t.x=c.x+e.x,t.y=c.y+e.y,t};var R=(c,e)=>c.x*e.x+c.y*e.y;var M=c=>{let e={x:0,y:0},t=c.x*c.x+c.y*c.y;return t>0&&(t=1/Math.sqrt(t),e.x=c.x*t,e.y=c.y*t),e};var P=(c,e)=>{let t={x:0,y:0};return t.x=c,t.y=e,t};var T=(c,e)=>{let t={x:0,y:0};return t.x=c.x-e.x,t.y=c.y-e.y,t};var C=c=>{let e,t={x:0,y:0},s={x:0,y:0},h=[],r=(n,l)=>{h.push({vec2:n,miterLength:l})},a=n=>({x:c[n*2],y:c[n*2+1]});t=w(a(1),a(0)),e=_(t),r(e,1);let o=c.length/2;for(let n=1;n<o-1;n++){let l=a(n-1),i=a(n),f=a(n+1);t=w(i,l),e=_(t),s=w(f,i);let u=F(t,s),g=N(t,u,1);r(u,g)}return t=w(a(o-1),a(o-2)),e=_(t),r(e,1),h};var F=(c,e)=>{let t=S(c,e);return t=M(t),P(-t.y,t.x)};var N=(c,e,t)=>{let s=P(-c.y,c.x);return t/R(e,s)};var d=class extends x2{constructor(e,t,s){super(),this.currentIndex=0,this._thicknessRequested=0,this._actualThickness=0,this.webglNumPoints=t*2,this.numPoints=t,this.color=e,this._thicknessRequested=s,this._linePoints=new Float32Array(t*2),this.xy=new Float32Array(2*this.webglNumPoints)}convertToTriPoints(){let e=this._actualThickness/2,t=C(this._linePoints);for(let s=0;s<this.numPoints;s++){let h=this._linePoints[2*s],r=this._linePoints[2*s+1],a={x:h,y:r},o=Y(a,t[s].vec2,t[s].miterLength*e),n=Y(a,t[s].vec2,-t[s].miterLength*e);this.xy[s*4]=o.x,this.xy[s*4+1]=o.y,this.xy[s*4+2]=n.x,this.xy[s*4+3]=n.y}}setX(e,t){this._linePoints[e*2]=t}setY(e,t){this._linePoints[e*2+1]=t}lineSpaceX(e,t){for(let s=0;s<this.numPoints;s++)this.setX(s,e+t*s)}setThickness(e){this._thicknessRequested=e}getThickness(){return this._thicknessRequested}setActualThickness(e){this._actualThickness=e}};var A=class{constructor(e,t){this.debug=false,this.addLine=this.addDataLine,t==null?this.webgl=e.getContext("webgl",{antialias:true,transparent:false}):(this.webgl=e.getContext("webgl",{antialias:t.antialias,transparent:t.transparent,desynchronized:t.deSync,powerPerformance:t.powerPerformance,preserveDrawing:t.preserveDrawing}),this.debug=t.debug==null?false:t.debug),this.log("canvas type is: "+e.constructor.name),this.log(`[webgl-plot]:width=${e.width}, height=${e.height}`),this._linesData=[],this._linesAux=[],this._thickLines=[],this._surfaces=[],this.gScaleX=1,this.gScaleY=1,this.gXYratio=1,this.gOffsetX=0,this.gOffsetY=0,this.gLog10X=false,this.gLog10Y=false,this.webgl.clear(this.webgl.COLOR_BUFFER_BIT),this.webgl.viewport(0,0,e.width,e.height),this._progLine=this.webgl.createProgram(),this.initThinLineProgram(),this.webgl.enable(this.webgl.BLEND),this.webgl.blendFunc(this.webgl.SRC_ALPHA,this.webgl.ONE_MINUS_SRC_ALPHA)}get linesData(){return this._linesData}get linesAux(){return this._linesAux}get thickLines(){return this._thickLines}get surfaces(){return this._surfaces}_drawLines(e){let t=this.webgl;e.forEach(s=>{if(s.visible){t.useProgram(this._progLine);let h=t.getUniformLocation(this._progLine,"uscale");t.uniformMatrix2fv(h,false,new Float32Array([s.scaleX*this.gScaleX*(this.gLog10X?1/Math.log(10):1),0,0,s.scaleY*this.gScaleY*this.gXYratio*(this.gLog10Y?1/Math.log(10):1)]));let r=t.getUniformLocation(this._progLine,"uoffset");t.uniform2fv(r,new Float32Array([s.offsetX+this.gOffsetX,s.offsetY+this.gOffsetY]));let a=t.getUniformLocation(this._progLine,"is_log");t.uniform2iv(a,new Int32Array([this.gLog10X?1:0,this.gLog10Y?1:0]));let o=t.getUniformLocation(this._progLine,"uColor");t.uniform4fv(o,[s.color.r,s.color.g,s.color.b,s.color.a]),t.bufferData(t.ARRAY_BUFFER,s.xy,t.STREAM_DRAW),t.drawArrays(s.loop?t.LINE_LOOP:t.LINE_STRIP,0,s.webglNumPoints)}})}_drawSurfaces(e){let t=this.webgl;e.forEach(s=>{if(s.visible){t.useProgram(this._progLine);let h=t.getUniformLocation(this._progLine,"uscale");t.uniformMatrix2fv(h,false,new Float32Array([s.scaleX*this.gScaleX*(this.gLog10X?1/Math.log(10):1),0,0,s.scaleY*this.gScaleY*this.gXYratio*(this.gLog10Y?1/Math.log(10):1)]));let r=t.getUniformLocation(this._progLine,"uoffset");t.uniform2fv(r,new Float32Array([s.offsetX+this.gOffsetX,s.offsetY+this.gOffsetY]));let a=t.getUniformLocation(this._progLine,"is_log");t.uniform2iv(a,new Int32Array([this.gLog10X?1:0,this.gLog10Y?1:0]));let o=t.getUniformLocation(this._progLine,"uColor");t.uniform4fv(o,[s.color.r,s.color.g,s.color.b,s.color.a]),t.bufferData(t.ARRAY_BUFFER,s.xy,t.STREAM_DRAW),t.drawArrays(t.TRIANGLE_STRIP,0,s.webglNumPoints)}})}_drawTriangles(e){let t=this.webgl;t.bufferData(t.ARRAY_BUFFER,e.xy,t.STREAM_DRAW),t.useProgram(this._progLine);let s=t.getUniformLocation(this._progLine,"uscale");t.uniformMatrix2fv(s,false,new Float32Array([e.scaleX*this.gScaleX*(this.gLog10X?1/Math.log(10):1),0,0,e.scaleY*this.gScaleY*this.gXYratio*(this.gLog10Y?1/Math.log(10):1)]));let h=t.getUniformLocation(this._progLine,"uoffset");t.uniform2fv(h,new Float32Array([e.offsetX+this.gOffsetX,e.offsetY+this.gOffsetY]));let r=t.getUniformLocation(this._progLine,"is_log");t.uniform2iv(r,new Int32Array([0,0]));let a=t.getUniformLocation(this._progLine,"uColor");t.uniform4fv(a,[e.color.r,e.color.g,e.color.b,e.color.a]),t.drawArrays(t.TRIANGLE_STRIP,0,e.xy.length/2)}_drawThickLines(){this._thickLines.forEach(e=>{if(e.visible){let t=Math.min(this.gScaleX,this.gScaleY);e.setActualThickness(e.getThickness()/t),e.convertToTriPoints(),this._drawTriangles(e)}})}update(){this.clear(),this.draw()}draw(){this._drawLines(this.linesData),this._drawLines(this.linesAux),this._drawThickLines(),this._drawSurfaces(this.surfaces)}clear(){this.webgl.clear(this.webgl.COLOR_BUFFER_BIT)}_addLine(e){e._vbuffer=this.webgl.createBuffer(),this.webgl.bindBuffer(this.webgl.ARRAY_BUFFER,e._vbuffer),this.webgl.bufferData(this.webgl.ARRAY_BUFFER,e.xy,this.webgl.STREAM_DRAW),e._coord=this.webgl.getAttribLocation(this._progLine,"coordinates"),this.webgl.vertexAttribPointer(e._coord,2,this.webgl.FLOAT,false,0,0),this.webgl.enableVertexAttribArray(e._coord)}addDataLine(e){this._addLine(e),this.linesData.push(e)}addAuxLine(e){this._addLine(e),this.linesAux.push(e)}addThickLine(e){this._addLine(e),this._thickLines.push(e)}addSurface(e){this._addLine(e),this.surfaces.push(e)}initThinLineProgram(){let e=`
      attribute vec2 coordinates;
      uniform mat2 uscale;
      uniform vec2 uoffset;
      uniform ivec2 is_log;

      void main(void) {
         float x = (is_log[0]==1) ? log(coordinates.x) : coordinates.x;
         float y = (is_log[1]==1) ? log(coordinates.y) : coordinates.y;
         vec2 line = vec2(x, y);
         gl_Position = vec4(uscale*line + uoffset, 0.0, 1.0);
      }`,t=this.webgl.createShader(this.webgl.VERTEX_SHADER);this.webgl.shaderSource(t,e),this.webgl.compileShader(t);let s=`
         precision mediump float;
         uniform highp vec4 uColor;
         void main(void) {
            gl_FragColor =  uColor;
         }`,h=this.webgl.createShader(this.webgl.FRAGMENT_SHADER);this.webgl.shaderSource(h,s),this.webgl.compileShader(h),this._progLine=this.webgl.createProgram(),this.webgl.attachShader(this._progLine,t),this.webgl.attachShader(this._progLine,h),this.webgl.linkProgram(this._progLine)}popDataLine(){this.linesData.pop()}removeAllLines(){this._linesData=[],this._linesAux=[],this._thickLines=[],this._surfaces=[]}removeDataLines(){this._linesData=[]}removeAuxLines(){this._linesAux=[]}viewport(e,t,s,h){this.webgl.viewport(e,t,s,h)}log(e){this.debug&&console.log("[webgl-plot]:"+e)}};var y=class{constructor(){this.plots={}}initPlot(e,t){if(t||(t=new A(e.canvas,e.webglOptions)),!e._id)e._id=`plot${Math.floor(Math.random()*1e15)}`;else if(this.plots[e._id]){let l=this.plots[e._id].initial;if(e.lines){for(let i in e.lines)if(l.lines[i]&&Array.isArray(e.lines[i])){let f=e.lines[i];e.lines[i]=l.lines[i]}}e=Object.assign(l,e)}e.overlay&&(typeof e.overlay!="object"&&(e.overlay=document.createElement("canvas"),e.overlay.style.position="absolute",e.overlay.width=e.canvas.width,e.overlay.height=e.canvas.height,e.canvas.appendChild(e.overlay)),e.overlayCtx||(e.overlayCtx=e.overlay.getContext("2d"))),e.width&&(e.canvas.width=e.width,e.canvas.style&&(e.canvas.style.width=e.width+"px"),typeof e.overlay=="object"&&(e.overlay.width=e.width,e.overlay.style&&(e.overlay.style.width=e.width+"px"))),e.height&&(e.canvas.height=e.height,e.canvas.style&&(e.canvas.style.height=e.height+"px"),typeof e.overlay=="object"&&(e.overlay.height=e.height,e.overlay.style&&(e.overlay.style.height=e.height+"px"))),e.lines?.timestamp&&delete e.lines.timestamp;let s={};for(let l in e.lines)s[l]=Object.assign({},s[l]),"viewing"in e.lines[l]||(e.lines[l].viewing=true),s[l].viewing=e.lines[l].viewing,s[l].sps=e.lines[l].sps,s[l].nSec=e.lines[l].nSec,s[l].nPoints=e.lines[l].nPoints,s[l].ymin=e.lines[l].ymin,s[l].ymax=e.lines[l].ymax,s[l].units=e.lines[l].units;let h={plot:t,settings:e,initial:Object.assign(Object.assign({},e),{lines:s}),anim:()=>{t.update()}};this.plots[e._id]=h;let r=0,a=0;Object.keys(e.lines).forEach(l=>{e.lines[l]?.viewing!==false&&a++}),e.nLines=a;let o,n;typeof e.overlay=="object"&&(o=e.overlay,n=e.overlayCtx,n.clearRect(0,0,e.overlay.width,e.overlay.height),n.font=e.overlayFont?e.overlayFont:"1em Courier",n.fillStyle=e.overlayColor?e.overlayColor:"white");for(let l in e.lines){let i=e.lines[l];if(Array.isArray(i)&&(i={values:i},e.lines[l]=i),"viewing"in i||(i.viewing=true),i.color)Array.isArray(i.color)&&(i.color=new b(...i.color));else{let m=y.HSLToRGB(360*(r/a)%360,100,50,1);h.initial.lines[l].color=[...m,1],i.color=new b(...m,1)}let f;if(i.nSec&&i.sps?f=Math.ceil(i.nSec*i.sps):i.nPoints?f=i.nPoints:i.points?f=i.points:e.linePoints?f=e.linePoints:i.values?f=i.values.length:f=1e3,i.points=f,e.lines[l].viewing===false)continue;if((i.width||e.lineWidth)&&i.width!==0){let m=e.lineWidth;m||(m=i.width),i.width?i.line=new d(i.color,f,i.width):e.lineWidth&&(i.line=new d(i.color,f,e.lineWidth)),i.line.lineSpaceX(-1,2/i.line.numPoints)}else i.line=new v(i.color,f),i.line.arrangeX();i.values?.length===i.points?i.values.length!==f&&(i.interpolate?i.values.length>f?i.values=y.downsample(i.values,f):i.values.length<f&&(i.values=y.upsample(i.values,f)):i.values.length>i.points?i.values=i.values.slice(i.values.length-i.points):i.values=[...new Array(i.points-i.values.length).fill(0),...i.values]):Array.isArray(i.values)?i.values=[...new Array(f-i.values.length).fill(0),...i.values]:i.values=new Array(i.points).fill(0);let u=i.ymin,g=i.ymax;if(u===g?(g=i.values.length<=1e5?Math.max(...i.values):1,u=i.values.length<=1e5?Math.min(...i.values):0):isNaN(g)&&(g=i.values.length<=1e5?Math.max(...i.values):1),isNaN(u)&&(u=i.values.length<=1e5?Math.min(...i.values):0),u>g){let m=u;g=u,u=m}let p=Math.abs(u);if(i.absmax=p>g?p:g,"autoscale"in i||(i.autoscale=true),i.position||(i.position=e.nLines-r-1),i.autoscale?i.autoscale===2?("clamp"in i||(i.clamp=true),i.scaled=y.autoscale(i.values,i.position,a,i.centerZero,u,g,i.clamp)):(i.scaled=i.values,i.line.scaleY=y.getYScalar(i.values,a,i.centerZero,u,g),i.line.offsetY=y.getYOffset(i.position,a,u,i.line.scaleY)):i.scaled=i.values,i.scaled.forEach((m,L)=>i.line.setY(L,m)),i.line instanceof d?t.addThickLine(i.line):i.line instanceof v&&t.addDataLine(i.line),"xAxis"in i||(i.xAxis=true),i.xAxis){i.xColor?Array.isArray(i.xColor)&&(i.xColor=new b(...i.xColor)):i.xColor=new b(1,1,1,.3);let m=new v(i.xColor,2),L=i.autoscale?(r+1)*2/a-1-1/a:0;m.constY(L),m.arrangeX(),m.xy[2]=1,i.x=m,t.addAuxLine(m)}if(a>1&&i.autoscale&&r!==a-1){e.dividerColor?Array.isArray(e.dividerColor)&&(e.dividerColor=new b(...e.dividerColor)):e.dividerColor=new b(1,1,1,1);let m=new v(e.dividerColor,2);m.constY(i.autoscale?(r+1)*2/a-1:1),m.arrangeX(),m.xy[2]=1,i.divider=m,t.addAuxLine(m)}if(typeof e.overlay=="object"&&(i.useOverlay||!("useOverlay"in i))){let m=e.nLines-i.position-1;n.fillText(l,20,o.height*(m+.2)/e.nLines),n.fillText(`${Math.floor(g)===g?g:g?.toFixed(5)} ${i.units?i.units:""}`,o.width-100,o.height*(m+.2)/e.nLines),n.fillText(`${Math.floor(u)===u?u:u?.toFixed(5)} ${i.units?i.units:""}`,o.width-100,o.height*(m+.9)/e.nLines)}r++}return requestAnimationFrame(h.anim),this.plots[e._id]}deinitPlot(e){return typeof e=="string"&&(e=this.plots[e]),e.plot.clear(),e.plot.removeAllLines(),true}reinitPlot(e,t){if(typeof e=="string"){let s=e;e=this.plots[e],t._id||(t._id=s)}if(!!e.plot)return e.plot.clear(),e.plot.removeAllLines(),e.settings.overlayCtx&&e.settings.overlayCtx.clearRect(0,0,e.settings.overlay?.width,e.settings.overlay?.height),this.initPlot(t,e.plot)}getChartSettings(e,t){let s=this.plots[e];if(s){let h=Object.assign({},s.initial);for(let r in s.initial.lines)typeof s.initial.lines[r]?.ymax!="number"&&(h.lines[r].ymax=s.settings.lines[r]?.ymax),typeof s.initial.lines[r]?.ymin!="number"&&(h.lines[r].ymin=s.settings.lines[r]?.ymin),t&&(h.lines[r].values=s.settings.lines[r].values);return delete h.canvas,delete h.overlay,delete h.overlayCtx,h}}update(e,t,s=true){if(typeof e=="string"&&(e=this.plots[e]),!e)return false;if(t){let h=false,r,a;typeof e.settings.overlay=="object"&&(r=e.settings.overlay,a=e.settings.overlayCtx,a.font=e.settings.overlayFont?e.settings.overlayFont:"1em Courier",a.fillStyle=e.settings.overlayColor?e.settings.overlayColor:"white");for(let o in t)if(e.settings.lines[o]&&e.settings.lines[o].line){if(e.settings.lines[o]?.viewing===false)continue;let n=e.settings.lines[o];if(Array.isArray(t[o])&&n.values.length<1e5?t[o].length===n.values.length?n.values=t[o]:y.circularBuffer(n.values,t[o]):typeof t[o]=="number"?(n.values.push(t[o]),n.values.shift()):t[o]?.values&&(t[o].values.length===n.values.length?n.values=t[o].values:y.circularBuffer(n.values,t[o].values)),n.values){n.values.length!==n.points&&(n.interpolate?n.values.length>n.points?n.values=y.downsample(n.values,n.points):n.scaled.length<n.points&&(n.values=y.upsample(n.values,n.points)):n.values.length>n.points?n.values.splice(0,n.values.length-n.points):n.values=new Array(n.points).fill(0).splice(n.points-n.values.length,0,n.values));let l=n.ymin,i=n.ymax;if(l===i?(i=n.values.length<=1e5?Math.max(...n.values):1,l=n.values.length<=1e5?Math.min(...n.values):0):isNaN(i)&&(i=n.values.length<=1e5?Math.max(...n.values):1),isNaN(l)&&(l=n.values.length<=1e5?Math.min(...n.values):0),l>i){let u=l;i=l,l=u}let f=Math.abs(l);if(n.absmax=f>i?f:i,n.autoscale?n.autoscale===2?n.scaled=y.autoscale(n.values,n.position,e.settings.nLines,n.centerZero,l,i,n.clamp):(n.scaled=n.values,n.line.scaleY=y.getYScalar(n.values,e.settings.nLines,n.centerZero,l,i),n.line.offsetY=y.getYOffset(n.position,e.settings.nLines,l,n.line.scaleY)):n.scaled=n.values,n.scaled.forEach((u,g)=>{!n.autoscale&&n.absmax>1?n.line.setY(g,u/n.absmax):n.line.setY(g,u)}),typeof e.settings.overlay=="object"&&(n.useOverlay||!("useOverlay"in n))){let u=e.settings.nLines-n.position-1;a.clearRect(0,r.height*u/e.settings.nLines,r.width,r.height/e.settings.nLines),a.fillText(o,20,r.height*(u+.2)/e.settings.nLines),a.fillText(`${Math.floor(i)===i?i:i?.toFixed(5)} ${n.units?n.units:""}`,r.width-100,r.height*(u+.2)/e.settings.nLines),a.fillText(`${Math.floor(l)===l?l:l?.toFixed(5)} ${n.units?n.units:""}`,r.width-100,r.height*(u+.9)/e.settings.nLines)}}}else e.settings.generateNewLines&&!o.includes("timestamp")&&(Array.isArray(t[o])&&(t[o]={values:t[o]}),!t[o].nSec&&!t[o].nPoints&&!e.settings.linePoints&&(t[o].nPoints=1e3),h=true);if(h)return e.settings.cleanGeneration||Object.keys(e.initial.lines).forEach(o=>{t[o]?t[o]=Object.assign(e.initial.lines[o],t[o]):t[o]=e.initial.lines[o]}),this.reinitPlot(e,{_id:e.settings._id,lines:t}),true}return s&&requestAnimationFrame(e.anim),true}updateLine(e,t,s,h,r,a,o){return e.numPoints!==t.length&&(s?e.numPoints>t.length?t=y.downsample(t,e.numPoints):e.numPoints<t.length&&(t=y.upsample(t,e.numPoints)):t.length>e.numPoints?t=t.slice(t.length-e.numPoints):t=[...new Array(t.length).fill(0),...t]),h&&(t=y.autoscale(t,r,a,o)),t.forEach((n,l)=>e.setY(l,n)),true}static autoscale(e,t=0,s=1,h=false,r,a,o){if(e?.length===0)return e;let n=typeof a=="number"?a:e.length<=1e5?Math.max(...e):1,l=typeof r=="number"?r:e.length<=1e5?Math.min(...e):0,i=1/s,f=1;if(h){let u=Math.max(Math.abs(l),Math.abs(n));return u!==0&&(f=i/u),e.map(g=>(o&&(g<l&&(g=l),g>n&&(g=n)),g*f+(i*(t+1)*2-1-i)))}else return n===l?n!==0?f=i/n:l!==0&&(f=i/Math.abs(l)):f=i/(n-l),e.map(u=>(o&&(u<l&&(u=l),u>n&&(u=n)),2*((u-l)*f-1/(2*s))+(i*(t+1)*2-1-i)))}static getYScalar(e,t=1,s=false,h,r){if(e?.length===0)return e;let a=typeof r=="number"?r:e.length<=1e5?Math.max(...e):1,o=typeof h=="number"?h:e.length<=1e5?Math.min(...e):0,n=1/t,l=1;if(s){let i=Math.max(Math.abs(o),Math.abs(a));return i!==0&&(l=n/i),2*l}else return a===o?a!==0?l=n/a:o!==0&&(l=n/Math.abs(o)):l=n/(a-o),2*l}static getYOffset(e=0,t=1,s=0,h=1){let r=1/t,a=r*(e+1)*2-1-r;return s>0&&(a-=s*h+1/t),a}static absmax(e){return Math.max(Math.abs(Math.min(...e)),Math.max(...e))}static downsample(e,t,s=1){if(e.length>t){let h=new Array(t),r=e.length/t,a=e.length-1,o=0,n=0;for(let l=r;l<e.length;l+=r){let i=Math.round(l);i>a&&(i=a);for(let f=o;f<i;f++)h[n]+=e[f];h[n]/=(i-o)*s,n++,o=i}return h}else return e}static upsample(e,t,s=1){var h=function(u,g,p){return(u+(g-u)*p)*s},r=new Array(t),a=(e.length-1)/(t-1);r[0]=e[0];for(var o=1;o<t-1;o++){var n=o*a,l=Math.floor(n),i=Math.ceil(n),f=n-l;r[o]=h(e[l],e[i],f)}return r[t-1]=e[e.length-1],r}static interpolate(e,t,s=1){return e.length>t?y.downsample(e,t,s):e.length<t?y.upsample(e,t,s):e}static HSLToRGB(e,t,s,h=255){t/=100,s/=100;let r=(1-Math.abs(2*s-1))*t,a=r*(1-Math.abs(e/60%2-1)),o=s-r/2,n=0,l=0,i=0;return 0<=e&&e<60?(n=r,l=a,i=0):60<=e&&e<120?(n=a,l=r,i=0):120<=e&&e<180?(n=0,l=r,i=a):180<=e&&e<240?(n=0,l=a,i=r):240<=e&&e<300?(n=a,l=0,i=r):300<=e&&e<360&&(n=r,l=0,i=a),n=(n+o)*h,l=(l+o)*h,i=(i+o)*h,[n,l,i]}static circularBuffer(e,t){if(t.length<e.length){let s=e.slice(t.length),h=e.length;e.splice(0,h,...s,...t)}else if(t.length>e.length){let s=e.length;e.splice(0,s,t.slice(s-t.length))}else e.splice(0,e.length,...t);return e}static formatDataForCharts(e,t){if(Array.isArray(e)){if(Array.isArray(e[0])){let s={};if(e.forEach((h,r)=>{s[r]=h}),e=s,isNaN(e[0][0]))return}else if(t){if(e={[t]:e},isNaN(e[t][0]))return}else if(e={0:e},isNaN(e[0][0]))return}else if(typeof e=="object"){for(let s in e)if(typeof e[s]=="number"?e[s]=[e[s]]:e[s]?.values&&typeof e[s].values=="number"&&(e[s].values=[e[s].values]),isNaN(e[s][0]))return}else if(typeof e=="string"){let s;if(e.includes(`\r
`)){let h=e.split(`\r
`);e={},h.forEach((r,a)=>{r.includes("	")?s=r.split("	"):r.includes(",")?s=r.split(","):r.includes("|")&&(s=r.split("|")),s&&s.forEach((o,n)=>{if(o.includes(":")){let[l,i]=o.split(":"),f=parseFloat(i);isNaN(f)||(e[l]=[f])}else{let l=parseFloat(o);isNaN(l)||(e[n]=[l])}})})}else e.includes("	")?s=e.split("	"):e.includes(",")?s=e.split(","):e.includes("|")&&(s=e.split("|"));e={},s&&s.forEach((h,r)=>{if(h.includes(":")){let[a,o]=h.split(":"),n=parseFloat(o);isNaN(n)||(e[a]=[n])}else{let a=parseFloat(h);isNaN(a)||(e[r]=[a])}})}else typeof e=="number"&&(t?e={[t]:[e]}:e={0:[e]});return e}static padTime(e,t,s,h){let r=(e[0]-t)/s/h;return[...new Array(h-e.length).map((o,n)=>t+r*(n+1)),...e]}static interpolateForTime(e,t,s){return y.interpolate(e,Math.ceil(s*t))}};var webglPlotRoutes={setupChart:function setupChart(settings){console.log("initializing chart",settings);if(!this?.__node?.graph?.plotter){this.__node.graph.plotter=new y;return this.__node.graph.plotter.initPlot(settings).settings._id}else{globalThis.plotter=new y;return globalThis.plotter.initPlot(settings).settings._id}},updateChartData:function updateChartData(plot,lines,draw=true){if(typeof lines==="object"){if(globalThis.plotter)globalThis.plotter.update(plot,lines,draw);else if(this?.__node?.graph?.plotter)this.__node.graph.plotter.update(plot,lines,draw);return true}return false},clearChart:function clearChart(plot){if(globalThis.plotter)globalThis.plotter.deinitPlot(plot);else if(this?.__node?.graph?.plotter)this.__node.graph.plotter.deinitPlot(plot);return true},resetChart:function resetChart(plot,settings){if(globalThis.plotter)globalThis.plotter.reinitPlot(plot,settings);else if(this?.__node?.graph?.plotter)this.__node.graph.plotter.reinitPlot(plot,settings);return settings._id},getChartSettings:function getChartSettings(plotId){let settings;if(globalThis.plotter)settings=globalThis.plotter.getChartSettings(plotId);else if(this?.__node?.graph?.plotter)settings=this.__node.graph.plotter.getChartSettings(plotId);return settings}};async function setSignalControls(controlsDiv,plotId,streamworker,chartworker,chartSettings,filterSettings){let controls=controlsDiv;if(!controls)return false;if(!chartSettings&&chartworker)chartSettings=await chartworker.run("getChartSettings",plotId);if(!filterSettings&&streamworker)filterSettings=await streamworker.run("getFilterSettings");if(chartSettings?.lines){let body=``;let viewingall=true;let scalingall=true;let n50all=true;let n60all=true;let dcall=true;let lpall=true;let bpall=true;for(const prop in chartSettings.lines){let line=chartSettings.lines[prop];body+=`
            <tr>
                <td id='${plotId}${prop}name'><input id='${plotId}${prop}viewing' type='checkbox' ${line.viewing?"checked":""}>${prop}</td>
                <td><input id='${plotId}${prop}sps' type='number' step='1' value='${line.sps?line.sps:100}'></td>
                <td><input id='${plotId}${prop}nSec' type='number' step='1' value='${line.nSec?line.nSec:line.nPoints?Math.floor(line.nPoints/(line.sps?line.sps:100)):10}'></td>
                <td><input id='${plotId}${prop}scalar'  type='number' value='${filterSettings[prop]?.scalar?filterSettings[prop].scalar:1}'><input id='${plotId}${prop}useScaling' type='checkbox' ${filterSettings[prop]?.useScaling?"checked":""}></td>
                <td><input id='${plotId}${prop}units' type='text' value='${line.units?line.units:""}'></td>
                <td><input id='${plotId}${prop}ymin' type='number' value='${line.ymin?line.ymin:"0"}'></td>
                <td><input id='${plotId}${prop}ymax' type='number' value='${line.ymax?line.ymax:"1"}'></td>
                <td><input id='${plotId}${prop}useNotch50' type='checkbox' ${filterSettings[prop]?.useNotch50?"checked":""}></td>
                <td><input id='${plotId}${prop}useNotch60' type='checkbox' ${filterSettings[prop]?.useNotch60?"checked":""}></td>
                <td><input id='${plotId}${prop}useDCBlock' type='checkbox' ${filterSettings[prop]?.useDCBlock?"checked":""}></td>
                <td><input id='${plotId}${prop}lowpassHz'  type='number' value='${filterSettings[prop]?.lowpassHz?filterSettings[prop].lowpassHz:100}'>Hz<input id='${plotId}${prop}useLowpass' type='checkbox' ${filterSettings[prop]?.useLowpass?"checked":""}></td>
                <td><input id='${plotId}${prop}bandpassLower'  type='number' value='${filterSettings[prop]?.bandpassLower?filterSettings[prop].bandpassLower:3}'>Hz to <input id='${plotId}${prop}bandpassUpper'  type='number' value='${filterSettings[prop]?.bandpassUpper?filterSettings[prop].bandpassUpper:45}'>Hz<input id='${plotId}${prop}useBandpass' type='checkbox' ${filterSettings[prop]?.useBandpass?"checked":""}></td>
            </tr>`;if(!line.viewing)viewingall=false;if(!filterSettings[prop]?.useScaling)scalingall=false;if(!filterSettings[prop]?.useNotch50)n50all=false;if(!filterSettings[prop]?.useNotch60)n60all=false;if(!filterSettings[prop]?.useDCBlock)dcall=false;if(!filterSettings[prop]?.useLowpass)lpall=false;if(!filterSettings[prop]?.useBandpass)bpall=false}let head=`
        <tr>
            <th>Name <input type='checkbox' id='${plotId}viewing' ${viewingall?"checked":""}></th>
            <th>SPS</th>
            <th>Plot nSec</th>
            <th>Scalar <input type='checkbox' id='${plotId}useScaling' ${scalingall?"checked":""}></th>
            <th>Units</th>
            <th>Lower Bound</th>
            <th>Upper Bound</th>
            <th>50Hz Notch <input type='checkbox' id='${plotId}useNotch50' ${n50all?"checked":""}></th>
            <th>60Hz Notch <input type='checkbox' id='${plotId}useNotch60' ${n60all?"checked":""}></th>
            <th>DC Block <input type='checkbox' id='${plotId}useDCBlock' ${dcall?"checked":""}></th>
            <th>Lowpass <input type='checkbox' id='${plotId}useLowpass' ${lpall?"checked":""}></th>
            <th>Bandpass <input type='checkbox' id='${plotId}useBandpass' ${bpall?"checked":""}></th>
        </tr>
        `;controls.innerHTML=head+body;let viewall=document.getElementById(plotId+"viewing");let usescalar=document.getElementById(plotId+"useScaling");let usen50=document.getElementById(plotId+"useNotch50");let usen60=document.getElementById(plotId+"useNotch60");let usedcb=document.getElementById(plotId+"useDCBlock");let uselp=document.getElementById(plotId+"useLowpass");let usebp=document.getElementById(plotId+"useBandpass");let headeronchange=(checked,idsuffix)=>{for(const prop in chartSettings.lines){let elm=document.getElementById(plotId+prop+idsuffix);if(elm?.checked!==checked)elm.click()}};viewall.onchange=ev2=>{headeronchange(ev2.target.checked,"viewing")};usescalar.onchange=ev2=>{headeronchange(ev2.target.checked,"useScaling")};usen50.onchange=ev2=>{headeronchange(ev2.target.checked,"useNotch50")};usen60.onchange=ev2=>{headeronchange(ev2.target.checked,"useNotch60")};usedcb.onchange=ev2=>{headeronchange(ev2.target.checked,"useDCBlock")};uselp.onchange=ev2=>{headeronchange(ev2.target.checked,"useLowpass")};usebp.onchange=ev2=>{headeronchange(ev2.target.checked,"useBandpass")};for(const prop in chartSettings.lines){let viewing=document.getElementById(plotId+prop+"viewing");let sps=document.getElementById(plotId+prop+"sps");let nSec=document.getElementById(plotId+prop+"nSec");let useScaling=document.getElementById(plotId+prop+"useScaling");let scalar=document.getElementById(plotId+prop+"scalar");let units=document.getElementById(plotId+prop+"units");let ymin=document.getElementById(plotId+prop+"ymin");let ymax=document.getElementById(plotId+prop+"ymax");let useNotch50=document.getElementById(plotId+prop+"useNotch50");let useNotch60=document.getElementById(plotId+prop+"useNotch60");let useDCBlock=document.getElementById(plotId+prop+"useDCBlock");let useLowpass=document.getElementById(plotId+prop+"useLowpass");let lowpassHz=document.getElementById(plotId+prop+"lowpassHz");let useBandpass=document.getElementById(plotId+prop+"useBandpass");let bandpassLower=document.getElementById(plotId+prop+"bandpassLower");let bandpassUpper=document.getElementById(plotId+prop+"bandpassUpper");viewing.onchange=()=>{if(!Array.isArray(chartSettings.lines?.[prop])){(chartSettings.lines?.[prop]).viewing=viewing.checked;chartSettings.generateNewLines=false;chartworker.run("resetChart",[plotId,chartSettings])}};let filteronchange=()=>{let setting={[prop]:{sps:sps.value?parseFloat(sps.value):100,useScaling:useScaling.checked,scalar:scalar.value?parseFloat(scalar.value):1,useNotch50:useNotch50.checked,useNotch60:useNotch60.checked,useDCBlock:useDCBlock.checked,useLowpass:useLowpass.checked,lowpassHz:lowpassHz.value?parseFloat(lowpassHz.value):100,useBandpass:useBandpass.checked,bandpassLower:bandpassLower.value?parseFloat(bandpassLower.value):3,bandpassUpper:bandpassUpper.value?parseFloat(bandpassUpper.value):45,trimOutliers:filterSettings[prop]?.trimOutliers,outlierTolerance:filterSettings[prop]?.outlierTolerance}};streamworker.post("setFilters",setting)};sps.onchange=()=>{filteronchange();(chartSettings.lines?.[prop]).sps=parseFloat(sps.value);(chartSettings.lines?.[prop]).nSec=parseFloat(nSec.value);delete(chartSettings.lines?.[prop]).points;delete(chartSettings.lines?.[prop]).nPoints;chartworker.run("resetChart",[plotId,chartSettings])};units.onchange=()=>{if(!Array.isArray(chartSettings.lines?.[prop])){(chartSettings.lines?.[prop]).units=units.value;chartworker.run("resetChart",[plotId,chartSettings])}};ymax.onchange=()=>{if(!Array.isArray(chartSettings.lines?.[prop])){(chartSettings.lines?.[prop]).ymax=ymax.value?parseFloat(ymax.value):1;(chartSettings.lines?.[prop]).ymin=ymin.value?parseFloat(ymin.value):0;chartworker.run("resetChart",[plotId,chartSettings])}};ymin.onchange=()=>{if(!Array.isArray(chartSettings.lines?.[prop])){(chartSettings.lines?.[prop]).ymax=ymax.value?parseFloat(ymax.value):1;(chartSettings.lines?.[prop]).ymin=ymin.value?parseFloat(ymin.value):0;chartworker.run("resetChart",[plotId,chartSettings])}};nSec.onchange=()=>{if(!Array.isArray(chartSettings.lines?.[prop])){(chartSettings.lines?.[prop]).sps=parseFloat(sps.value);(chartSettings.lines?.[prop]).nSec=parseFloat(nSec.value);delete(chartSettings.lines?.[prop]).points;delete(chartSettings.lines?.[prop]).nPoints;chartworker.run("resetChart",[plotId,chartSettings])}};useScaling.onchange=filteronchange;useNotch50.onchange=filteronchange;useNotch60.onchange=filteronchange;useDCBlock.onchange=filteronchange;useLowpass.onchange=filteronchange;useBandpass.onchange=filteronchange;lowpassHz.onchange=filteronchange;scalar.onchange=filteronchange;bandpassLower.onchange=filteronchange;bandpassUpper.onchange=filteronchange}}}var url=URL.createObjectURL(new Blob([String('(()=>{var __create=Object.create;var __defProp=Object.defineProperty;var __getOwnPropDesc=Object.getOwnPropertyDescriptor;var __getOwnPropNames=Object.getOwnPropertyNames;var __getProtoOf=Object.getPrototypeOf;var __hasOwnProp=Object.prototype.hasOwnProperty;var __commonJS=(cb,mod)=>function __require(){return mod||(0,cb[__getOwnPropNames(cb)[0]])((mod={exports:{}}).exports,mod),mod.exports};var __copyProps=(to,from,except,desc)=>{if(from&&typeof from==="object"||typeof from==="function"){for(let key of __getOwnPropNames(from))if(!__hasOwnProp.call(to,key)&&key!==except)__defProp(to,key,{get:()=>from[key],enumerable:!(desc=__getOwnPropDesc(from,key))||desc.enumerable})}return to};var __toESM=(mod,isNodeMode,target)=>(target=mod!=null?__create(__getProtoOf(mod)):{},__copyProps(isNodeMode||!mod||!mod.__esModule?__defProp(target,"default",{value:mod,enumerable:true}):target,mod));var require_browser=__commonJS({"../node_modules/web-worker/cjs/browser.js"(exports,module){module.exports=Worker}});var EventHandler=class{constructor(data){this.pushToState={};this.data={};this.triggers={};this.setState=updateObj=>{Object.assign(this.data,updateObj);for(const prop of Object.getOwnPropertyNames(updateObj)){if(this.triggers[prop])this.triggers[prop].forEach(obj=>obj.onchange(this.data[prop]))}return this.data};this.setValue=(key,value)=>{this.data[key]=value;if(this.triggers[key])this.triggers[key].forEach(obj=>obj.onchange(this.data[key]))};this.subscribeTrigger=(key,onchange)=>{if(key){if(!this.triggers[key]){this.triggers[key]=[]}let l=this.triggers[key].length;this.triggers[key].push({sub:l,onchange});return this.triggers[key].length-1}else return void 0};this.unsubscribeTrigger=(key,sub)=>{let triggers=this.triggers[key];if(triggers){if(!sub)delete this.triggers[key];else{let sub2=void 0;let obj=triggers.find((o,i)=>{if(o.sub===sub2){sub2=i;return true}});if(obj)triggers.splice(sub2,1);if(this.onRemoved)this.onRemoved(obj);return true}}};this.subscribeTriggerOnce=(key,onchange)=>{let sub;let changed=value=>{onchange(value);this.unsubscribeTrigger(key,sub)};sub=this.subscribeTrigger(key,changed)};this.getTrigger=(key,sub)=>{for(const s in this.triggers[key]){if(this.triggers[key][s].sub===sub)return this.triggers[key][s]}};if(typeof data==="object")this.data=data}};var state=new EventHandler;var GraphNode=class{constructor(properties,parent2,graph){this.__node={tag:`node${Math.floor(Math.random()*1e15)}`,unique:`${Math.random()}`,state};this.__subscribe=(callback,key,subInput,bound,target)=>{const subscribeToFunction=(k,setTarget=(callback2,target2)=>callback2,triggerCallback=callback)=>{let sub=this.__node.state.subscribeTrigger(k,triggerCallback);let trigger=this.__node.state.getTrigger(k,sub);trigger.source=this.__node.tag;if(key)trigger.key=key;trigger.target=setTarget(callback);if(bound)trigger.bound=bound;return sub};const subscribeToGraph=callback2=>{let fn=this.__node.graph.get(callback2);if(!fn&&callback2.includes(".")){let n=this.__node.graph.get(callback2.substring(0,callback2.lastIndexOf(".")));let key2=callback2.substring(callback2.lastIndexOf(".")+1);if(n&&typeof n[key2]==="function")callback2=(...args)=>{return n[key2](...args)}}};if(key){if(!this.__node.localState){this.__addLocalState(this)}if(typeof callback==="string"){if(typeof this[callback]==="function")callback=this[callback];else if(this.__node.graph)subscribeToGraph(callback)}let sub;let k=subInput?this.__node.unique+"."+key+"input":this.__node.unique+"."+key;if(typeof callback==="function")sub=subscribeToFunction(k);else if(callback?.__node)sub=subscribeToFunction(k,(callback2,target2)=>target2?target2:callback2.__node.unique,state2=>{if(callback.__operator)callback.__operator(state2)});return sub}else{if(typeof callback==="string"){if(this.__node.graph)callback=this.__node.graph.get(callback);else callback=this.__node.graph.nodes.get(callback)}let sub;let k=subInput?this.__node.unique+"input":this.__node.unique;if(typeof callback==="function")sub=subscribeToFunction(k);else if(callback?.__node)sub=subscribeToFunction(k,(callback2,target2)=>target2?target2:callback2.__node.unique,state2=>{if(callback.__operator)callback.__operator(state2)});return sub}};this.__unsubscribe=(sub,key,subInput)=>{if(key){return this.__node.state.unsubscribeTrigger(subInput?this.__node.unique+"."+key+"input":this.__node.unique+"."+key,sub)}else return this.__node.state.unsubscribeTrigger(subInput?this.__node.unique+"input":this.__node.unique,sub)};this.__setOperator=fn=>{fn=fn.bind(this);this.__operator=(...args)=>{if(this.__node.inputState)this.__node.state.setValue(this.__node.unique+"input",args);let result=fn(...args);if(this.__node.state.triggers[this.__node.unique]){if(typeof result?.then==="function"){result.then(res=>{if(res!==void 0)this.__node.state.setValue(this.__node.unique,res)}).catch(console.error)}else if(result!==void 0)this.__node.state.setValue(this.__node.unique,result)}return result};if(!this.__subscribedToParent){if(this.__parent instanceof GraphNode&&this.__parent.__operator){let sub=this.__parent.__subscribe(this);let ondelete=()=>{this.__parent?.__unsubscribe(sub);delete this.__subscribedToParent};this.__addOndisconnected(ondelete);this.__subscribedToParent=true}}return this.__operator};this.__proxyObject=obj=>{let allProps=getAllProperties(obj);for(const k of allProps){if(typeof this[k]==="undefined"){if(typeof obj[k]==="function"){this[k]=(...args)=>{if(this.__node.inputState)this.__node.state.setValue(this.__node.unique+"."+k+"input",args);let result=obj[k](...args);if(this.__node.state.triggers[this.__node.unique+"."+k]){if(typeof result?.then==="function"){result.then(res=>{this.__node.state.setValue(this.__node.unique+"."+k,res)}).catch(console.error)}else this.__node.state.setValue(this.__node.unique+"."+k,result)}return result}}else{let definition={get:()=>{return obj[k]},set:value=>{obj[k]=value;if(this.__node.state.triggers[this.__node.unique+"."+k])this.__node.state.setValue(this.__node.unique+"."+k,value)},enumerable:true,configurable:true};Object.defineProperty(this,k,definition)}}}};let orig=properties;if(typeof properties==="function"){if(isNativeClass(properties)){console.log(properties);properties=new properties}else properties={__operator:properties,__node:{forward:true,tag:properties.name}}}else if(typeof properties==="string"){if(graph?.get(properties)){properties=graph.get(properties)}}if(!properties.__node.initial)properties.__node.initial=orig;if(typeof properties==="object"){if(properties.__props){if(typeof properties.__props==="function")properties.__props=new properties.__props;if(typeof properties.__props==="object"){this.__proxyObject(properties.__props)}}if(typeof properties.__node==="string"){if(graph?.get(properties.__node.tag)){properties=graph.get(properties.__node.tag)}else properties.__node={}}else if(!properties.__node)properties.__node={};if(!properties.__parent&&parent2)properties.__parent=parent2;if(graph){properties.__node.graph=graph}if(properties.__operator){if(typeof properties.__operator==="string"){if(graph){let n=graph.get(properties.__operator);if(n)properties.__operator=n.__operator;if(!properties.__node.tag&&properties.__operator.name)properties.__node.tag=properties.__operator.name}}if(typeof properties.__operator==="function")properties.__operator=this.__setOperator(properties.__operator)}if(!properties.__node.tag){if(properties.__operator?.name)properties.__node.tag=properties.__operator.name;else properties.__node.tag=`node${Math.floor(Math.random()*1e15)}`}if(parent2?.__node&&!(parent2 instanceof Graph||properties instanceof Graph))properties.__node.tag=parent2.__node.tag+"."+properties.__node.tag;if(parent2 instanceof Graph&&properties instanceof Graph){if(properties.__node.loaders)Object.assign(parent2.__node.loaders?parent2.__node.loaders:{},properties.__node.loaders);if(parent2.__node.mapGraphs){properties.__node.nodes.forEach(n=>{parent2.set(properties.__node.tag+"."+n.__node.tag,n)});let ondelete=()=>{properties.__node.nodes.forEach(n=>{parent2.__node.nodes.delete(properties.__node.tag+"."+n.__node.tag)})};this.__addOndisconnected(ondelete)}}properties.__node=Object.assign(this.__node,properties.__node);let keys=Object.getOwnPropertyNames(properties);for(const key of keys){this[key]=properties[key]}if(typeof properties.default==="function"&&!properties.__operator){let fn=properties.default.bind(this);this.default=(...args)=>{if(this.__node.inputState)this.__node.state.setValue(this.__node.unique+"input",args);let result=fn(...args);if(typeof result?.then==="function"){result.then(res=>{if(res!==void 0)this.__node.state.setValue(this.__node.unique,res)}).catch(console.error)}else if(result!==void 0)this.__node.state.setValue(this.__node.unique,result);return result};properties.default=this.default}if(properties instanceof Graph)this.__node.source=properties}}__addLocalState(props){if(!props)return;if(!this.__node.localState){this.__node.localState={}}let localState=this.__node.localState;for(let k in props){if(this.__props&&this.__props[k])continue;if(typeof props[k]==="function"){if(!k.startsWith("_")){let fn=props[k].bind(this);props[k]=(...args)=>{if(this.__node.inputState)this.__node.state.setValue(this.__node.unique+"."+k+"input",args);let result=fn(...args);if(typeof result?.then==="function"){if(this.__node.state.triggers[this.__node.unique+"."+k])result.then(res=>{this.__node.state.setValue(this.__node.unique+"."+k,res)}).catch(console.error)}else if(this.__node.state.triggers[this.__node.unique+"."+k])this.__node.state.setValue(this.__node.unique+"."+k,result);return result};this[k]=props[k]}}else{localState[k]=props[k];let definition={get:()=>{return localState[k]},set:v=>{localState[k]=v;if(this.__node.state.triggers[this.__node.unique+"."+k])this.__node.state.setValue(this.__node.unique+"."+k,v)},enumerable:true,configurable:true};Object.defineProperty(this,k,definition);if(typeof this.__node.initial==="object"){let dec=Object.getOwnPropertyDescriptor(this.__node.initial,k);if(dec===void 0||dec?.configurable){Object.defineProperty(this.__node.initial,k,definition)}}}}}__addOnconnected(callback){if(Array.isArray(this.__ondisconnected)){this.__onconnected.push(callback)}else if(typeof this.__onconnected==="function"){this.__onconnected=[callback,this.__onconnected]}else this.__onconnected=callback}__addOndisconnected(callback){if(Array.isArray(this.__ondisconnected)){this.__ondisconnected.push(callback)}else if(typeof this.__ondisconnected==="function"){this.__ondisconnected=[callback,this.__ondisconnected]}else this.__ondisconnected=callback}__callConnected(node=this){if(typeof this.__onconnected==="function"){this.__onconnected(this)}else if(Array.isArray(this.__onconnected)){this.__onconnected.forEach(o=>{o(this)})}}__callDisconnected(node=this){if(typeof this.__ondisconnected==="function")this.__ondisconnected(this);else if(Array.isArray(this.__ondisconnected)){this.__ondisconnected.forEach(o=>{o(this)})}}};var Graph=class{constructor(options){this.__node={tag:`graph${Math.floor(Math.random()*1e15)}`,nodes:new Map,state};this.init=options=>{if(options){recursivelyAssign(this.__node,options);if(options.tree)this.setTree(options.tree)}};this.setTree=tree=>{this.__node.tree=Object.assign(this.__node.tree?this.__node.tree:{},tree);let cpy=Object.assign({},tree);if(cpy.__node)delete cpy.__node;let listeners=this.recursiveSet(cpy,this,void 0,tree);if(tree.__node){if(!tree.__node.tag)tree.__node._tag=`tree${Math.floor(Math.random()*1e15)}`;else if(!this.get(tree.__node.tag)){let node=new GraphNode(tree,this,this);this.set(node.__node.tag,node);for(const l in this.__node.loaders){if(typeof this.__node.loaders[l]==="object"){if(this.__node.loaders[l].init)this.__node.loaders[l](node,parent,this,this.__node.tree,tree);if(this.__node.loaders[l].connected)node.__addOnconnected(this.__node.loaders[l].connect);if(this.__node.loaders[l].disconnected)node.__addOndisconnected(this.__node.loaders[l].disconnect)}else if(typeof this.__node.loaders==="function")this.__node.loaders[l](node,this,this,tree,tree,tree.__node.tag)}if(node.__listeners){listeners[node.__node.tag]=node.__listeners}}}else if(tree.__listeners){this.setListeners(tree.__listeners)}this.setListeners(listeners);return cpy};this.setLoaders=(loaders2,replace)=>{if(replace)this.__node.loaders=loaders2;else Object.assign(this.__node.loaders,loaders2);return this.__node.loaders};this.add=(properties,parent2)=>{let listeners={};if(typeof parent2==="string")parent2=this.get(parent2);if(typeof properties==="function"){if(isNativeClass(properties)){properties=new properties}else properties={__operator:properties}}else if(typeof properties==="string")properties=this.__node.tree[properties];let p=Object.assign({},properties);if(!p.__node)p.__node={};p.__node.initial=properties;if(typeof properties==="object"&&(!p?.__node?.tag||!this.get(p.__node.tag))){let node=new GraphNode(p,parent2,this);this.set(node.__node.tag,node);for(const l in this.__node.loaders){if(typeof this.__node.loaders[l]==="object"){if(this.__node.loaders[l].init)this.__node.loaders[l](node,parent2,this,this.__node.tree,properties,node.__node.tag);if(this.__node.loaders[l].connected)node.__addOnconnected(this.__node.loaders[l].connect);if(this.__node.loaders[l].disconnected)node.__addOndisconnected(this.__node.loaders[l].disconnect)}else if(typeof this.__node.loaders==="function")this.__node.loaders[l](node,parent2,this,this.__node.tree,properties,node.__node.tag)}this.__node.tree[node.__node.tag]=properties;if(node.__listeners){listeners[node.__node.tag]=node.__listeners}if(node.__children){node.__children=Object.assign({},node.__children);this.recursiveSet(node.__children,node,listeners,node.__children)}this.setListeners(listeners);node.__callConnected();return node}return};this.recursiveSet=(t,parent2,listeners={},origin)=>{let keys=Object.getOwnPropertyNames(origin);for(const key of keys){if(key.includes("__"))continue;let p=origin[key];if(Array.isArray(p))continue;if(typeof p==="function"){if(isNativeClass(p)){p=new p}else p={__operator:p}}else if(typeof p==="string")p=this.__node.tree[p];else if(typeof p==="boolean")p=this.__node.tree[key];if(typeof p==="object"){p=Object.assign({},p);if(!p.__node)p.__node={};if(!p.__node.tag)p.__node.tag=key;p.__node.initial=t[key];if(this.get(p.__node.tag)&&!(parent2?.__node&&this.get(parent2.__node.tag+"."+p.__node.tag))||parent2?.__node&&this.get(parent2.__node.tag+"."+p.__node.tag))continue;let node=new GraphNode(p,parent2,this);this.set(node.__node.tag,node);for(const l in this.__node.loaders){this.__node.loaders[l](node,parent2,this,t,t[key],key)}t[key]=node;this.__node.tree[node.__node.tag]=p;if(node.__listeners){listeners[node.__node.tag]=node.__listeners}if(node.__children){node.__children=Object.assign({},node.__children);this.recursiveSet(node.__children,node,listeners,node.__children)}node.__callConnected()}}return listeners};this.remove=(node,clearListeners=true)=>{this.unsubscribe(node);if(typeof node==="string")node=this.get(node);if(node instanceof GraphNode){this.delete(node.__node.tag);delete this.__node.tree[node.__node.tag];if(clearListeners){this.clearListeners(node)}node.__callDisconnected();const recursiveRemove=t=>{for(const key in t){this.unsubscribe(t[key]);this.delete(t[key].__node.tag);delete this.__node.tree[t[key].__node.tag];this.delete(key);delete this.__node.tree[key];t[key].__node.tag=t[key].__node.tag.substring(t[key].__node.tag.lastIndexOf(".")+1);if(clearListeners){this.clearListeners(t[key])}t[key].__callDisconnected();if(t[key].__children){recursiveRemove(t[key].__children)}}};if(node.__children){recursiveRemove(node.__children)}}if(node?.__node.tag&&node?.__parent){delete node?.__parent;node.__node.tag=node.__node.tag.substring(node.__node.tag.indexOf(".")+1)}return node};this.run=(node,...args)=>{if(typeof node==="string"){let nd=this.get(node);if(!nd&&node.includes(".")){nd=this.get(node.substring(0,node.lastIndexOf(".")));if(typeof nd?.[node.substring(node.lastIndexOf(".")+1)]==="function")return nd[node.substring(node.lastIndexOf(".")+1)](...args)}else if(nd?.__operator)return nd.__operator(...args)}if(node?.__operator){return node?.__operator(...args)}};this.setListeners=listeners=>{for(const key in listeners){let node=this.get(key);if(typeof listeners[key]==="object"){for(const k in listeners[key]){let n=this.get(k);let sub;if(typeof listeners[key][k]!=="object")listeners[key][k]={__callback:listeners[key][k]};else if(!listeners[key][k].__callback){for(const kk in listeners[key][k]){if(typeof listeners[key][k][kk]!=="object"){listeners[key][k][kk]={__callback:listeners[key][k][kk]};if(listeners[key][k][kk].__callback===true)listeners[key][k][kk].__callback=node.__operator}let nn=this.get(kk);if(nn){if(!nn){let tag=k.substring(0,k.lastIndexOf("."));nn=this.get(tag);if(n){sub=this.subscribe(nn,listeners[key][k][kk].__callback,k.substring(k.lastIndexOf(".")+1),listeners[key][k][kk].inputState,key,k);if(typeof node.__listeners[k][kk]!=="object")node.__listeners[k][kk]={__callback:listeners[key][k][kk].__callback,inputState:listeners[key][k][kk]?.inputState};node.__listeners[k][kk].sub=sub}}else{sub=this.subscribe(nn,listeners[key][k][kk].__callback,void 0,listeners[key][k].inputState,key,k);if(typeof node.__listeners[k][kk]!=="object")node.__listeners[k][kk]={__callback:listeners[key][k][kk].__callback,inputState:listeners[key][k][kk]?.inputState};node.__listeners[k][kk].sub=sub}}}}if(listeners[key][k].__callback){if(listeners[key][k].__callback===true)listeners[key][k].__callback=node.__operator;if(typeof listeners[key][k].__callback==="function")listeners[key][k].__callback=listeners[key][k].__callback.bind(node);if(typeof node.__listeners!=="object")node.__listeners={};if(!n){let tag=k.substring(0,k.lastIndexOf("."));n=this.get(tag);if(n){sub=this.subscribe(n,listeners[key][k].__callback,k.substring(k.lastIndexOf(".")+1),listeners[key][k].inputState,key,k);if(typeof node.__listeners[k]!=="object")node.__listeners[k]={__callback:listeners[key][k].__callback,inputState:listeners[key][k]?.inputState};node.__listeners[k].sub=sub}}else{sub=this.subscribe(n,listeners[key][k].__callback,void 0,listeners[key][k].inputState,key,k);if(typeof node.__listeners[k]!=="object")node.__listeners[k]={__callback:listeners[key][k].__callback,inputState:listeners[key][k]?.inputState};node.__listeners[k].sub=sub}}}}}};this.clearListeners=(node,listener)=>{if(typeof node==="string")node=this.get(node);if(node?.__listeners){for(const key in node.__listeners){if(listener&&key!==listener)continue;if(typeof node.__listeners[key].sub!=="number")continue;let n=this.get(key);if(!n){n=this.get(key.substring(0,key.lastIndexOf(".")));if(n){if(!node.__listeners[key].__callback){for(const k in node.__listeners[key]){this.unsubscribe(n,node.__listeners[key][k].sub,key.substring(key.lastIndexOf(".")+1),node.__listeners[key][k].inputState)}}else this.unsubscribe(n,node.__listeners[key].sub,key.substring(key.lastIndexOf(".")+1),node.__listeners[key].inputState)}}else{if(!node.__listeners[key].__callback){for(const k in node.__listeners[key]){this.unsubscribe(n,node.__listeners[key][k].sub,void 0,node.__listeners[key][k].inputState)}}else this.unsubscribe(n,node.__listeners[key].sub,void 0,node.__listeners[key].inputState)}delete node.__listeners[key]}}};this.get=tag=>{return this.__node.nodes.get(tag)};this.set=(tag,node)=>{return this.__node.nodes.set(tag,node)};this.delete=tag=>{return this.__node.nodes.delete(tag)};this.getProps=(node,getInitial)=>{if(typeof node==="string")node=this.get(node);if(node instanceof GraphNode){let cpy;if(getInitial)cpy=Object.assign({},this.__node.tree[node.__node.tag]);else{cpy=Object.assign({},node);delete cpy.__unsubscribe;delete cpy.__setOperator;delete cpy.__node;delete cpy.__subscribeState;delete cpy.__subscribe}}};this.subscribe=(node,callback,key,subInput,target,bound)=>{let nd=node;if(!(node instanceof GraphNode))nd=this.get(node);let sub;if(typeof callback==="string"){if(target){let method=this.get(target)?.[callback];if(typeof method==="function")callback=method}else callback=this.get(callback)?.__operator}if(nd instanceof GraphNode){sub=nd.__subscribe(callback,key,subInput,target,bound);let ondelete=()=>{nd.__unsubscribe(sub,key,subInput)};nd.__addOndisconnected(ondelete)}else if(typeof node==="string"){if(this.get(node)){if(callback instanceof GraphNode&&callback.__operator){sub=this.get(node).__subscribe(callback.__operator,key,subInput,target,bound);let ondelete=()=>{this.get(node).__unsubscribe(sub)};callback.__addOndisconnected(ondelete)}else if(typeof callback==="function"||typeof callback==="string"){sub=this.get(node).__subscribe(callback,key,subInput,target,bound);this.__node.state.getTrigger(this.get(node).__node.unique,sub).source=node}}else{if(typeof callback==="string")callback=this.__node.nodes.get(callback).__operator;if(typeof callback==="function")sub=this.__node.state.subscribeTrigger(node,callback)}}return sub};this.unsubscribe=(node,sub,key,subInput)=>{if(node instanceof GraphNode){return node.__unsubscribe(sub,key,subInput)}else return this.get(node)?.__unsubscribe(sub,key,subInput)};this.setState=update=>{this.__node.state.setState(update)};this.init(options)}};function recursivelyAssign(target,obj){for(const key in obj){if(obj[key]?.constructor.name==="Object"&&!Array.isArray(obj[key])){if(target[key]?.constructor.name==="Object"&&!Array.isArray(target[key]))recursivelyAssign(target[key],obj[key]);else target[key]=recursivelyAssign({},obj[key])}else{target[key]=obj[key]}}return target}function getAllProperties(obj){var allProps=[],curr=obj;do{var props=Object.getOwnPropertyNames(curr);props.forEach(function(prop){if(allProps.indexOf(prop)===-1)allProps.push(prop)})}while(curr=Object.getPrototypeOf(curr));return allProps}function isNativeClass(thing){return typeof thing==="function"&&thing.hasOwnProperty("prototype")&&!thing.hasOwnProperty("arguments")}var backprop=(node,parent2,graph)=>{if(node.__node.backward&&parent2 instanceof GraphNode){graph.setListeners({[parent2.__node.tag]:{[node.__node.tag]:parent2}})}};var loop=(node,parent2,graph)=>{if(node.__operator&&!node.__node.looperSet){node.__node.looperSet=true;if(typeof node.__node.delay==="number"){let fn=node.__operator;node.__setOperator((...args)=>{return new Promise((res,rej)=>{setTimeout(async()=>{res(await fn(...args))},node.__node.delay)})})}else if(node.__node.frame===true){let fn=node.__operator;node.__setOperator((...args)=>{return new Promise((res,rej)=>{requestAnimationFrame(async()=>{res(await fn(...args))})})})}if(typeof node.__node.repeat==="number"||typeof node.__node.recursive==="number"){let fn=node.__operator;node.__setOperator(async(...args)=>{let i=node.__node.repeat?node.__node.repeat:node.__node.recursive;let result;let repeater=async(tick,...inp)=>{while(tick>0){if(node.__node.delay||node.__node.frame){fn(...inp).then(async res=>{if(node.__node.recursive){await repeater(tick,res)}else await repeater(tick,...inp)});break}else result=await fn(...args);tick--}};await repeater(i,...args);return result})}if(node.__node.loop&&typeof node.__node.loop==="number"){let fn=node.__operator;node.__setOperator((...args)=>{if(!("looping"in node.__node))node.__node.looping=true;if(node.__node.looping){fn(...args);setTimeout(()=>{node.__operator(...args)},node.__node.loop)}});if(node.__node.looping)node.__operator();let ondelete=node2=>{if(node2.__node.looping)node2.__node.looping=false};node.__addOndisconnected(ondelete)}}};var animate=(node,parent2,graph)=>{if(node.__node.animate===true||node.__animation){let fn=node.__operator;node.__setOperator((...args)=>{if(!("animating"in node.__node))node.__node.animating=true;if(node.__node.animating){if(typeof node.__animation==="function")node.__animation(...args);else fn(...args);requestAnimationFrame(()=>{node.__operator(...args)})}});if(node.__node.animating||(!("animating"in node.__node)||node.__node.animating)&&node.__animation)setTimeout(()=>{requestAnimationFrame(node.__operator)},10);let ondelete=node2=>{if(node2.__node.animating)node2.__node.animating=false};node.__addOndisconnected(ondelete)}};var branching=(node,parent2,graph)=>{if(typeof node.__node.branch==="object"&&node.__operator&&!node.__node.branchApplied){let fn=node.__operator;node.__node.branchApplied=true;node.__operator=(...args)=>{let result=fn(...args);for(const key in node.__node.branch){let triggered=()=>{if(typeof node.__node.branch[key].then==="function"){node.__node.branch[key].then(result)}else if(node.__node.branch[key].then instanceof GraphNode&&node.__node.branch[key].then.__operator){node.__node.branch[key].then.__operator(result)}else result=node.__node.branch[key].then};if(typeof node.__node.branch[key].if==="function"){if(node.__node.branch[key].if(result)){triggered()}}else if(node.__node.branch[key].if===result){triggered()}}return result}}if(node.__listeners){for(const key in node.__listeners){if(typeof node.__listeners[key]==="object"){if(node.__listeners[key].branch&&!node.__listeners[key].branchApplied){let fn=node.__listeners[key].callback;node.__listeners[key].branchApplied=true;node.__listeners.callback=ret=>{let triggered=()=>{if(typeof node.__listeners[key].branch.then==="function"){ret=node.__listeners[key].branch.then(ret)}else if(node.__listeners[key].branch.then instanceof GraphNode&&node.__listeners[key].branch.then.__operator){ret=node.__listeners[key].branch.then.__operator(ret)}else ret=node.__listeners[key].branch.then};if(typeof node.__listeners[key].branch.if==="function"){if(node.__listeners[key].branch.if(ret)){triggered()}}else if(node.__listeners[key].branch.if===ret){triggered()}return fn(ret)}}}}}};var triggerListenerOncreate=(node,parent2,graph)=>{if(node.__listeners){for(const key in node.__listeners){if(typeof node.__listeners[key]==="object"){if(node.__listeners[key].oncreate){node.__listeners[key].callback(node.__listeners[key].oncreate)}}}}};var bindListener=(node,parent2,graph)=>{if(node.__listeners){for(const key in node.__listeners){if(typeof node.__listeners[key]==="object"){if(typeof node.__listeners[key].binding==="object"){node.__listeners.callback=node.__listeners.callback.bind(node.__listeners[key].binding)}}}}};var transformListenerResult=(node,parent2,graph)=>{if(node.__listeners){for(const key in node.__listeners){if(typeof node.__listeners[key]==="object"){if(typeof node.__listeners[key].transform==="function"&&!node.__listeners[key].transformApplied){let fn=node.__listeners[key].callback;node.__listeners[key].transformApplied=true;node.__listeners.callback=ret=>{ret=node.__listeners[key].transform(ret);return fn(ret)}}}}}};var substitute__operator=(node,parent2,graph)=>{if(node.post&&!node.__operator){node.__setOperator(node.post)}else if(!node.__operator&&typeof node.get=="function"){node.__setOperator(node.get)}if(!node.get&&node.__operator){node.get=node.__operator}if(node.aliases){node.aliases.forEach(a=>{graph.set(a,node);let ondelete=node2=>{graph.__node.nodes.delete(a)};node.__addOndisconnected(ondelete)})}if(typeof graph.__node.tree[node.__node.tag]==="object"&&node.get)graph.__node.tree[node.__node.tag].get=node.get};var loaders={backprop,loop,animate,branching,triggerListenerOncreate,bindListener,transformListenerResult,substitute__operator};var Service=class extends Graph{constructor(options){super({...options,loaders:options?.loaders?Object.assign({...loaders},options.loaders):{...loaders}});this.name=`service${Math.floor(Math.random()*1e15)}`;this.addServices=services=>{for(const s in services){if(typeof services[s]==="function")services[s]=new services[s];if(services[s]?.__node?.loaders)Object.assign(this.__node.loaders,services[s].__node.loaders);if(services[s]?.__node?.nodes){services[s].__node.nodes.forEach((n,tag)=>{if(!this.get(tag)){this.set(tag,n)}else this.set(s+"."+tag,n)});this.__node.nodes.forEach((n,k)=>{if(!services[s].__node.nodes.get(k))services[s].__node.nodes.set(k,n)});let set=this.set;this.set=(tag,node)=>{services[s].set(tag,node);return set(tag,node)};let del=this.delete;this.delete=tag=>{services[s].delete(tag);return del(tag)}}else if(typeof services[s]==="object"){this.setTree(services[s])}}};this.handleMethod=(route,method,args)=>{let m=method.toLowerCase();let src=this.__node.nodes.get(route);if(!src){src=this.__node.tree[route]}if(src?.[m]){if(!(src[m]instanceof Function)){if(args)src[m]=args;return src[m]}else return src[m](args)}else return this.handleServiceMessage({route,args,method})};this.transmit=(...args)=>{if(typeof args[0]==="object"){if(args[0].method){return this.handleMethod(args[0].route,args[0].method,args[0].args)}else if(args[0].route){return this.handleServiceMessage(args[0])}else if(args[0].node){return this.handleGraphNodeCall(args[0].node,args[0].args)}else if(this.__node.keepState){if(args[0].route)this.setState({[args[0].route]:args[0].args});if(args[0].node)this.setState({[args[0].node]:args[0].args})}return args}else return args};this.receive=(...args)=>{if(args[0]){if(typeof args[0]==="string"){let substr=args[0].substring(0,8);if(substr.includes("{")||substr.includes("[")){if(substr.includes("\\\\"))args[0]=args[0].replace(/\\\\/g,"");if(args[0][0]===\'"\'){args[0]=args[0].substring(1,args[0].length-1)};args[0]=JSON.parse(args[0])}}}if(typeof args[0]==="object"){if(args[0].method){return this.handleMethod(args[0].route,args[0].method,args[0].args)}else if(args[0].route){return this.handleServiceMessage(args[0])}else if(args[0].node){return this.handleGraphNodeCall(args[0].node,args[0].args)}else if(this.__node.keepState){if(args[0].route)this.setState({[args[0].route]:args[0].args});if(args[0].node)this.setState({[args[0].node]:args[0].args})}return args}else return args};this.pipe=(source,destination,endpoint,method,callback)=>{if(source instanceof GraphNode){if(callback)return this.subscribe(source,res=>{let mod=callback(res);if(mod!==void 0)this.transmit({route:destination,args:mod,method});else this.transmit({route:destination,args:res,method},endpoint)});else return this.subscribe(source,res=>{this.transmit({route:destination,args:res,method},endpoint)})}else if(typeof source==="string")return this.subscribe(source,res=>{this.transmit({route:destination,args:res,method},endpoint)})};this.pipeOnce=(source,destination,endpoint,method,callback)=>{if(source instanceof GraphNode){if(callback)return source.__node.state.subscribeTriggerOnce(source.__node.unique,res=>{let mod=callback(res);if(mod!==void 0)this.transmit({route:destination,args:mod,method});else this.transmit({route:destination,args:res,method},endpoint)});else return this.__node.state.subscribeTriggerOnce(source.__node.unique,res=>{this.transmit({route:destination,args:res,method},endpoint)})}else if(typeof source==="string")return this.__node.state.subscribeTriggerOnce(this.__node.nodes.get(source).__node.unique,res=>{this.transmit({route:destination,args:res,method},endpoint)})};this.terminate=(...args)=>{};this.isTypedArray=isTypedArray;this.recursivelyAssign=recursivelyAssign2;this.spliceTypedArray=spliceTypedArray;this.ping=()=>{console.log("pinged!");return"pong"};this.echo=(...args)=>{this.transmit(...args);return args};if(options?.services)this.addServices(options.services);this.setTree(this)}handleServiceMessage(message){let call;if(typeof message==="object"){if(message.route)call=message.route;else if(message.node)call=message.node}if(call){if(Array.isArray(message.args))return this.run(call,...message.args);else return this.run(call,message.args)}else return message}handleGraphNodeCall(route,args){if(!route)return args;if(args?.args){this.handleServiceMessage(args)}else if(Array.isArray(args))return this.run(route,...args);else return this.run(route,args)}};function isTypedArray(x2){return ArrayBuffer.isView(x2)&&Object.prototype.toString.call(x2)!=="[object DataView]"}var recursivelyAssign2=(target,obj)=>{for(const key in obj){if(typeof obj[key]==="object"&&!Array.isArray(obj[key])){if(typeof target[key]==="object"&&!Array.isArray(target[key]))recursivelyAssign2(target[key],obj[key]);else target[key]=recursivelyAssign2({},obj[key])}else target[key]=obj[key]}return target};function spliceTypedArray(arr,start,end){let s=arr.subarray(0,start);let e;if(end){e=arr.subarray(end+1)}let ta;if(s.length>0||e?.length>0)ta=new arr.constructor(s.length+e.length);if(ta){if(s.length>0)ta.set(s);if(e&&e.length>0)ta.set(e,s.length)}return ta}var import_web_worker=__toESM(require_browser());var WorkerService=class extends Service{constructor(options){super();this.name="worker";this.workers={};this.threadRot=0;this.loadWorkerRoute=(rt,routeKey)=>{if(rt.workerUrl)rt.url=rt.workerUrl;if(rt.workerId)rt.__node.tag=rt.workerId;if(!rt.__node.tag)rt.__node.tag=routeKey;rt._id=rt.__node.tag;let worker;if(this.workers[rt._id])worker=this.workers[rt._id];else if(rt.worker)worker=rt.worker;if(!worker){worker=this.addWorker(rt);let ondelete=rt2=>{rt2.worker?.terminate()};rt.__addOndisconnected(ondelete)}rt.worker=worker;if(rt.transferFunctions){for(const prop in rt.transferFunctions){this.transferFunction(worker,rt.transferFunctions[prop],prop)}}if(rt.transferClasses){for(const prop in rt.transferClasses){this.transferClass(worker,rt.transferClasses[prop],prop)}}if(worker){if(!rt.__operator){rt.__operator=(...args)=>{if(rt.callback){if(!this.__node.nodes.get(rt.__node.tag)?.__children)worker.post(rt.callback,args);else return worker.run(rt.callback,args)}else{if(!this.__node.nodes.get(rt.__node.tag)?.__children)worker.send(args);else return worker.request(args)}}}if(rt.init){worker.run(rt.init,rt.initArgs,rt.initTransfer)}return worker}};this.workerloader={"workers":(node,parent2,graph,tree)=>{let rt=node;if(!node.parentRoute&&(parent2?.callback&&parent2?.worker))node.parentRoute=parent2?.callback;if(rt?.worker||rt?.workerId||rt?.workerUrl){let worker=this.loadWorkerRoute(rt,rt.__node.tag);if(worker){if(!rt.parentRoute&&rt.__parent?.callback)rt.parentRoute=rt.__parent.callback;if(rt.__parent&&!rt.portId){if(typeof rt.__parent==="string"){if(rt.__node.tag!==rt.__parent&&worker._id!==rt.__parent)rt.portId=this.establishMessageChannel(worker,rt.__parent)}else if(rt.__node.tag!==rt.__parent?.__node?.tag&&worker._id!==rt.__parent.tag){rt.portId=this.establishMessageChannel(worker,rt.__parent.worker)}};if(rt.parentRoute){if(!rt.stopped){if(typeof rt.__parent==="string"&&rt.__parent===worker._id){worker.run("subscribe",[rt.parentRoute,void 0,rt.callback])}else if(rt.__node.tag===rt.__parent?.__node?.tag||worker._id===rt.__parent?.__node?.tag){worker.run("subscribe",[rt.parentRoute,void 0,rt.callback])}else worker.run("subscribeToWorker",[rt.parentRoute,rt.portId,rt.callback,rt.blocking]).then(sub=>{worker.workerSubs[rt.parentRoute+rt.portId].sub=sub})}if(!(typeof rt.__parent==="string"&&rt.__parent===worker._id)&&!(rt.__node.tag===rt.__parent?.__node?.tag||worker._id===rt.__parent?.__node?.tag))worker.workerSubs[rt.parentRoute+rt.portId]={sub:null,route:rt.parentRoute,portId:rt.portId,callback:rt.callback,blocking:rt.blocking}}else if(rt.__parent){if(typeof rt.__parent==="string"){if(!rt.stopped){if(rt.__parent===worker._id){worker.run("subscribe",[rt.__parent,void 0,rt.callback])}else worker.run("subscribeToWorker",[rt.__parent,rt.portId,rt.callback,rt.blocking]).then(sub=>{worker.workerSubs[rt.__parent+rt.portId].sub=sub})}if(!(typeof rt.__parent==="string"&&rt.__parent===worker._id))worker.workerSubs[rt.__parent+rt.portId]={sub:null,route:worker._id,portId:rt.portId,callback:rt.callback,blocking:rt.blocking}}else if(rt.__parent?.__node?.tag&&rt.__parent?.worker){if(!rt.stopped){if(rt.__node.tag===rt.__parent.__node.tag||worker._id===rt.__parent.__node.tag){worker.run("subscribe",[rt.__parent.__node.tag,void 0,rt.callback])}else worker.run("subscribeToWorker",[rt.__parent.__node.tag,rt.portId,rt.callback,rt.blocking]).then(sub=>{worker.workerSubs[rt.__parent.__node.tag+rt.portId].sub=sub})}if(!(rt.__node.tag===rt.__parent?.__node?.tag||worker._id===rt.__parent?.__node?.tag))worker.workerSubs[rt.__parent.__node.tag+rt.portId]={sub:null,route:rt.__parent.__node.tag,portId:rt.portId,callback:rt.callback,blocking:rt.blocking}}}}}else if(rt.__parent&&rt.parentRoute){if(typeof rt.__parent==="string"&&tree[rt.__parent]?.worker){tree[rt.__parent].worker.subscribe(rt.parentRoute,rt.__operator,rt.blocking)}else if(rt.__parent?.worker){rt.__parent.worker.subscribe(rt.parentRoute,rt.__operator,rt.blocking)}}return rt}};this.addDefaultMessageListener=()=>{globalThis.onmessage=ev2=>{let result=this.receive(ev2.data);if(this.__node.keepState)this.setState({[this.name]:result})}};this.postMessage=(message,target,transfer)=>{if(this.workers[target]){this.workers[target].send(message,transfer)}else{globalThis.postMessage(message,target,transfer)}};this.addWorker=options=>{let worker;if(!options._id)options._id=`worker${Math.floor(Math.random()*1e15)}`;if(options.url)worker=new import_web_worker.default(options.url);else if(options.port){worker=options.port}else if(this.workers[options._id]){if(this.workers[options._id].port)worker=this.workers[options._id].port;else worker=this.workers[options._id].worker}if(!worker)return;let send=(message,transfer)=>{return this.transmit(message,worker,transfer)};let post=(route,args,transfer,method)=>{let message={route,args};if(method)message.method=method;return this.transmit(message,worker,transfer)};let run=(route,args,transfer,method)=>{return new Promise((res,rej)=>{let callbackId=Math.random();let req={route:"runRequest",args:[{route,args},options._id,callbackId]};if(method)req.args[0].method=method;let onmessage=ev2=>{if(typeof ev2.data==="object"){if(ev2.data.callbackId===callbackId){worker.removeEventListener("message",onmessage);res(ev2.data.args)}}};worker.addEventListener("message",onmessage);this.transmit(req,worker,transfer)})};let request=(message,transfer,method)=>{return new Promise((res,rej)=>{let callbackId=Math.random();let req={route:"runRequest",args:[message,options._id,callbackId]};if(method)req.method=method;let onmessage=ev2=>{if(typeof ev2.data==="object"){if(ev2.data.callbackId===callbackId){worker.removeEventListener("message",onmessage);res(ev2.data.args)}}};worker.addEventListener("message",onmessage);this.transmit(req,worker,transfer)})};let workerSubs={};let subscribe=(route,callback,blocking)=>{return this.subscribeToWorker(route,options._id,callback,blocking)};let unsubscribe=(route,sub)=>{return run("unsubscribe",[route,sub])};let start=async(route,portId,callback,blocking)=>{if(route)await run("subscribeToWorker",[route,portId,callback,blocking]).then(sub=>{if(sub)workerSubs[route+portId]={sub,route,portId,callback,blocking}});else for(const key in workerSubs){if(typeof workerSubs[key].sub!=="number")await run("subscribeToWorker",[workerSubs[key].route,workerSubs[key].portId,workerSubs[key].callback,workerSubs[key].blocking]).then(sub=>{workerSubs[key].sub=sub})}return true};let stop=async(route,portId)=>{if(route&&portId&&workerSubs[route+portId]){await run("unsubscribe",[route,workerSubs[route+portId].sub]);workerSubs[route+portId].sub=false}else{for(const key in workerSubs){if(typeof workerSubs[key].sub==="number"){await run("unpipeWorkers",[workerSubs[key].route,workerSubs[key].portId,workerSubs[key].sub])}workerSubs[key].sub=false}}return true};let terminate=()=>{for(const key in workerSubs){if(typeof workerSubs[key].sub==="number"){run("unpipeWorkers",[workerSubs[key].route,workerSubs[key].portId,workerSubs[key].sub])}workerSubs[key].sub=false}return this.terminate(options._id)};if(!options.onmessage)options.onmessage=ev2=>{this.receive(ev2.data);this.setState({[options._id]:ev2.data})};if(!options.onerror){options.onerror=ev2=>{console.error(ev2.data)}}worker.onmessage=options.onmessage;worker.onerror=options.onerror;this.workers[options._id]={worker,send,post,run,request,subscribe,unsubscribe,terminate,start,stop,postMessage:worker.postMessage,workerSubs,graph:this,...options};return this.workers[options._id]};this.toObjectURL=scriptTemplate=>{let blob=new Blob([scriptTemplate],{type:"text/javascript"});return URL.createObjectURL(blob)};this.transmit=(message,worker,transfer)=>{if(!transfer){transfer=this.getTransferable(message)}if(worker instanceof import_web_worker.default||worker instanceof MessagePort){worker.postMessage(message,transfer)}else if(typeof worker==="string"){if(this.workers[worker]){if(this.workers[worker].port)this.workers[worker].port.postMessage(message,transfer);else if(this.workers[worker].worker)this.workers[worker].worker.postMessage(message,transfer)}}else{let keys=Object.keys(this.workers);this.workers[keys[this.threadRot]].worker.postMessage(message,transfer);this.threadRot++;if(this.threadRot===keys.length)this.threadRot=0}return message};this.terminate=worker=>{let onclose;if(typeof worker==="string"){let obj=this.workers[worker];if(obj){delete this.workers[worker];worker=obj.worker;if(obj.onclose)onclose=obj.onclose}}if(worker instanceof import_web_worker.default){worker.terminate();if(onclose)onclose(worker);return true}if(worker instanceof MessagePort){worker.close();if(onclose)onclose(worker);return true}return false};this.establishMessageChannel=(worker,worker2)=>{let workerId;if(typeof worker==="string"){workerId=worker;if(this.workers[worker]){if(this.workers[worker].port)worker=this.workers[worker].port;else worker2=this.workers[worker].worker}}else if(worker?.worker){worker=worker.worker}if(typeof worker2==="string"){if(this.workers[worker2]){if(this.workers[worker2].port)worker2=this.workers[worker2].port;else worker2=this.workers[worker2].worker}}else if(worker2?.worker){worker2=worker2.worker}if(worker instanceof import_web_worker.default||worker instanceof MessagePort){let channel=new MessageChannel;let portId=`port${Math.floor(Math.random()*1e15)}`;worker.postMessage({route:"addWorker",args:{port:channel.port1,_id:portId}},[channel.port1]);if(worker2 instanceof import_web_worker.default||worker2 instanceof MessagePort){worker2.postMessage({route:"addWorker",args:{port:channel.port2,_id:portId}},[channel.port2])}else if(workerId&&this.workers[workerId]){channel.port2.onmessage=this.workers[workerId].onmessage;this.workers[workerId].port=channel.port2}return portId}return false};this.request=(message,workerId,transfer,method)=>{let worker=this.workers[workerId].worker;return new Promise((res,rej)=>{let callbackId=Math.random();let req={route:"runRequest",args:[message,callbackId]};if(method)req.method=method;let onmessage=ev2=>{if(typeof ev2.data==="object"){if(ev2.data.callbackId===callbackId){worker.removeEventListener("message",onmessage);res(ev2.data.args)}}};worker.addEventListener("message",onmessage);this.transmit(req,worker,transfer)})};this.runRequest=(message,worker,callbackId)=>{let res=this.receive(message);if(typeof worker==="string"&&this.workers[worker]){if(this.workers[worker].port)worker=this.workers[worker].port;else worker=this.workers[worker].worker}if(res instanceof Promise){res.then(r=>{if(worker instanceof import_web_worker.default||worker instanceof MessagePort)worker.postMessage({args:r,callbackId});else if(typeof WorkerGlobalScope!=="undefined"&&self instanceof WorkerGlobalScope)globalThis.postMessage({args:r,callbackId})})}else{if(worker instanceof import_web_worker.default||worker instanceof MessagePort)worker.postMessage({args:res,callbackId});else if(typeof WorkerGlobalScope!=="undefined"&&self instanceof WorkerGlobalScope)globalThis.postMessage({args:res,callbackId})}return res};this.subscribeWorker=(route,worker,blocking,key,subInput)=>{let callback;if(blocking){let blocked=false;callback=res=>{if(!blocked){blocked=true;if(res instanceof Promise){res.then(r=>{if(worker?.run)worker.run("triggerSubscription",[route,worker._id,r]).then(ret=>{blocked=false})})}else{if(worker?.run)worker.run("triggerSubscription",[route,worker._id,res]).then(ret=>{blocked=false})}}}}else{callback=res=>{if(res instanceof Promise){res.then(r=>{if(worker?.postMessage)worker.postMessage({args:r,callbackId:route});else if(globalThis.postMessage)globalThis.postMessage({args:r,callbackId:route})})}else{if(worker?.postMessage)worker.postMessage({args:res,callbackId:route});else if(globalThis.postMessage)globalThis.postMessage({args:res,callbackId:route})}}}if(!blocking&&worker?.port){worker=worker.port}else if(!blocking&&worker?.worker){worker=worker.worker}else if(typeof worker==="string"&&this.workers[worker]){if(blocking)worker=this.workers[worker];else if(this.workers[worker].port)worker=this.workers[worker].port;else worker=this.workers[worker].worker}return this.subscribe(route,callback,key,subInput)};this.subscribeToWorker=(route,workerId,callback,blocking,key,subInput)=>{if(typeof workerId==="string"&&this.workers[workerId]){this.__node.state.subscribeTrigger(workerId,res=>{if(res?.callbackId===route){if(!callback)this.setState({[workerId]:res.args});else if(typeof callback==="string"){this.run(callback,res.args)}else callback(res.args)}});return this.workers[workerId].run("subscribeWorker",[route,workerId,blocking,key,subInput])}};this.triggerSubscription=async(route,workerId,result)=>{if(this.__node.state.triggers[workerId])for(let i=0;i<this.__node.state.triggers[workerId].length;i++){await this.__node.state.triggers[workerId][i].onchange({args:result,callbackId:route})}return true};this.pipeWorkers=(sourceWorker,listenerWorker,sourceRoute,listenerRoute,portId,blocking)=>{if(typeof sourceWorker==="string")sourceWorker=this.workers[sourceWorker];if(typeof listenerWorker==="string")listenerWorker=this.workers[listenerWorker];if(!portId){portId=this.establishMessageChannel(sourceWorker.worker,listenerWorker.worker)}return listenerWorker.run("subscribeToWorker",[sourceRoute,portId,listenerRoute,blocking])};this.unpipeWorkers=(sourceRoute,sourceWorker,sub)=>{if(typeof sourceWorker==="string")sourceWorker=this.workers[sourceWorker];if(sourceWorker)return sourceWorker.run("unsubscribe",[sourceRoute,sub])};this.connections={workers:this.workers};if(options?.services)this.addServices(options.services);this.setTree(this);this.setLoaders(this.workerloader);if(options)this.init(options);if(typeof WorkerGlobalScope!=="undefined"&&globalThis instanceof WorkerGlobalScope){this.addDefaultMessageListener()}}getTransferable(message){let transfer;if(typeof message==="object"){if(message.args){if(message.args?.constructor?.name==="Object"){for(const key in message.args){if(ArrayBuffer.isView(message.args[key])){if(!transfer)transfer=[message.args[key].buffer];else transfer.push(message.args[key].buffer)}else if(message.args[key]?.constructor?.name==="ArrayBuffer"){if(!transfer)transfer=[message.args[key]];else transfer.push(message.args[key])}}}else if(Array.isArray(message.args)&&message.args.length<11){message.args.forEach(arg=>{if(ArrayBuffer.isView(arg)){transfer=[arg.buffer]}else if(arg?.constructor?.name==="ArrayBuffer")transfer=[arg]})}else if(ArrayBuffer.isView(message.args)){transfer=[message.args.buffer]}else if(message.args?.constructor?.name==="ArrayBuffer"){transfer=[message]}}else if(message?.constructor?.name==="Object"){for(const key in message){if(ArrayBuffer.isView(message[key])){if(!transfer)transfer=[message[key].buffer];else transfer.push(message[key].buffer)}else if(message[key]?.constructor?.name==="ArrayBuffer"){if(!transfer)transfer=[message[key]];else transfer.push(message[key])}}}else if(Array.isArray(message)&&message.length<11){message.forEach(arg=>{if(ArrayBuffer.isView(arg)){transfer=[arg.buffer]}else if(arg.constructor?.name==="ArrayBuffer")transfer=[arg]})}else if(ArrayBuffer.isView(message)){transfer=[message.buffer]}else if(message.constructor?.name==="ArrayBuffer"){transfer=[message]}}return transfer}transferFunction(worker,fn,fnName){if(!fnName)fnName=fn.name;return worker.request({route:"setRoute",args:[fn.toString(),fnName]})}transferClass(worker,cls,className){if(!className)className=cls.name;return worker.request({route:"receiveClass",args:[cls.toString(),className]})}};var mouseEventHandler=makeSendPropertiesHandler(["ctrlKey","metaKey","shiftKey","button","pointerType","clientX","clientY","pageX","pageY"]);var wheelEventHandlerImpl=makeSendPropertiesHandler(["deltaX","deltaY"]);var keydownEventHandler=makeSendPropertiesHandler(["ctrlKey","metaKey","shiftKey","keyCode"]);function wheelEventHandler(event,sendFn){event.preventDefault();wheelEventHandlerImpl(event,sendFn)}function preventDefaultHandler(event){event.preventDefault()}function copyProperties(src,properties,dst){for(const name of properties){dst[name]=src[name]}}function makeSendPropertiesHandler(properties){return function sendProperties(event,sendFn){const data={type:event.type};copyProperties(event,properties,data);sendFn(data)}}function touchEventHandler(event,sendFn){const touches=[];const data={type:event.type,touches};for(let i=0;i<event.touches.length;++i){const touch=event.touches[i];touches.push({pageX:touch.pageX,pageY:touch.pageY})}sendFn(data)}var orbitKeys={"37":true,"38":true,"39":true,"40":true};function filteredKeydownEventHandler(event,sendFn){const{keyCode}=event;if(orbitKeys[keyCode]){event.preventDefault();keydownEventHandler(event,sendFn)}}var eventHandlers={contextmenu:preventDefaultHandler,mousedown:mouseEventHandler,mousemove:mouseEventHandler,mouseup:mouseEventHandler,pointerdown:mouseEventHandler,pointermove:mouseEventHandler,pointerup:mouseEventHandler,touchstart:touchEventHandler,touchmove:touchEventHandler,touchend:touchEventHandler,wheel:wheelEventHandler,keydown:filteredKeydownEventHandler};function initProxyElement(element,worker,id){if(!id)id="proxy"+Math.floor(Math.random()*1e15);const sendEvent=data=>{if(!worker){handleProxyEvent(data,id)}else worker.postMessage({route:"handleProxyEvent",args:[data,id]})};let entries=Object.entries(eventHandlers);for(const[eventName,handler]of entries){element.addEventListener(eventName,function(event){handler(event,sendEvent)})}const sendSize=()=>{const rect=element.getBoundingClientRect();sendEvent({type:"resize",left:rect.left,top:rect.top,width:element.clientWidth,height:element.clientHeight})};sendSize();globalThis.addEventListener("resize",sendSize);return id}var EventDispatcher=class{addEventListener(type,listener){if(this.__listeners===void 0)this.__listeners={};const listeners=this.__listeners;if(listeners[type]===void 0){listeners[type]=[]}if(listeners[type].indexOf(listener)===-1){listeners[type].push(listener)}}hasEventListener(type,listener){if(this.__listeners===void 0)return false;const listeners=this.__listeners;return listeners[type]!==void 0&&listeners[type].indexOf(listener)!==-1}removeEventListener(type,listener){if(this.__listeners===void 0)return;const listeners=this.__listeners;const listenerArray=listeners[type];if(listenerArray!==void 0){const index=listenerArray.indexOf(listener);if(index!==-1){listenerArray.splice(index,1)}}}dispatchEvent(event,target){if(this.__listeners===void 0)return;const listeners=this.__listeners;const listenerArray=listeners[event.type];if(listenerArray!==void 0){if(!target)event.target=this;else event.target=target;const array=listenerArray.slice(0);for(let i=0,l=array.length;i<l;i++){array[i].call(this,event)}event.target=null}}};function noop(){}var ElementProxyReceiver=class extends EventDispatcher{constructor(){super();this.__listeners={};this.style={};this.setPointerCapture=()=>{};this.releasePointerCapture=()=>{};this.getBoundingClientRect=()=>{return{left:this.left,top:this.top,width:this.width,height:this.height,right:this.left+this.width,bottom:this.top+this.height}};this.handleEvent=data=>{if(data.type==="resize"){this.left=data.left;this.top=data.top;this.width=data.width;this.height=data.height;if(typeof this.proxied==="object"){this.proxied.style.width=this.width+"px";this.proxied.style.height=this.height+"px";this.proxied.clientWidth=this.width;this.proxied.clientHeight=this.height}}data.preventDefault=noop;data.stopPropagation=noop;this.dispatchEvent(data,this.proxied)};this.style={}}get clientWidth(){return this.width}get clientHeight(){return this.height}focus(){}};var ProxyManager=class{constructor(){this.targets={};this.makeProxy=(id,addTo=void 0)=>{if(!id)id=`proxyReceiver${Math.floor(Math.random()*1e15)}`;let proxy;if(this.targets[id])proxy=this.targets[id];else{proxy=new ElementProxyReceiver;this.targets[id]=proxy}if(typeof addTo==="object"){addTo.proxy=proxy;proxy.proxied=addTo;if(typeof WorkerGlobalScope!=="undefined")addTo.style=proxy.style;if(proxy.width){addTo.style.width=proxy.width+"px";addTo.clientWidth=proxy.width}if(proxy.height){addTo.style.height=proxy.height+"px";addTo.clientHeight=proxy.height}addTo.setPointerCapture=proxy.setPointerCapture.bind(proxy);addTo.releasePointerCapture=proxy.releasePointerCapture.bind(proxy);addTo.getBoundingClientRect=proxy.getBoundingClientRect.bind(proxy);addTo.addEventListener=proxy.addEventListener.bind(proxy);addTo.removeEventListener=proxy.removeEventListener.bind(proxy);addTo.handleEvent=proxy.handleEvent.bind(proxy);addTo.dispatchEvent=proxy.dispatchEvent.bind(proxy);addTo.focus=proxy.focus.bind(proxy)}};this.getProxy=id=>{return this.targets[id]};this.handleEvent=(data,id)=>{if(!this.targets[id])this.makeProxy(id);if(this.targets[id]){this.targets[id].handleEvent(data);return true}return void 0};if(!globalThis.document)globalThis.document={}}};function makeProxy(id,elm){if(this?.__node?.graph){if(!this.__node.graph.ProxyManager)this.__node.graph.ProxyManager=new ProxyManager;this.__node.graph.ProxyManager.makeProxy(id,elm)}else{if(!globalThis.ProxyManager)globalThis.ProxyManager=new ProxyManager;globalThis.ProxyManager.makeProxy(id,elm)}return id}function handleProxyEvent(data,id){if(this?.__node?.graph){if(!this.__node.graph.ProxyManager)this.__node.graph.ProxyManager=new ProxyManager;if(this.__node.graph.ProxyManager.handleEvent(data,id))return data}else{if(!globalThis.ProxyManager)globalThis.ProxyManager=new ProxyManager;if(globalThis.ProxyManager.handleEvent(data,id))return data}}var proxyElementWorkerRoutes={initProxyElement,makeProxy,handleProxyEvent};function Renderer(options){if(options.worker){let worker=options.worker;let route=options.route;if(worker instanceof Blob||typeof worker==="string"){worker=new Worker(worker)}delete options.worker;delete options.route;return transferCanvas(worker,options,route)}else{initProxyElement(options.canvas,void 0,options._id);return setupCanvas(options)}}function transferCanvas(worker,options,route){if(!options)return void 0;if(!options._id)options._id=`canvas${Math.floor(Math.random()*1e15)}`;let offscreen=options.canvas.transferControlToOffscreen();if(!options.width)options.width=options.canvas.clientWidth;if(!options.height)options.height=options.canvas.clientHeight;let message={route:route?route:"setupCanvas",args:{...options,canvas:offscreen}};if(this?.__node?.graph)this.__node.graph.run("initProxyElement",options.canvas,worker,options._id);else initProxyElement(options.canvas,worker,options._id);if(options.draw){if(typeof options.draw==="function")message.args.draw=options.draw.toString();else message.args.draw=options.draw}if(options.update){if(typeof options.update==="function")message.args.update=options.update.toString();else message.args.update=options.update}if(options.init){if(typeof options.init==="function")message.args.init=options.init.toString();else message.args.init=options.init}if(options.clear){if(typeof options.clear==="function")message.args.clear=options.clear.toString();else message.args.clear=options.clear}let transfer=[offscreen];if(options.transfer){transfer.push(...options.transfer);delete options.transfer}worker.postMessage(message,transfer);const canvascontrols={_id:options._id,width:options.width,height:options.height,worker,draw:props=>{worker.postMessage({route:"drawFrame",args:[props,options._id]})},update:props=>{worker.postMessage({route:"updateCanvas",args:[props,options._id]})},clear:()=>{worker.postMessage({route:"clearCanvas",args:options._id})},init:()=>{worker.postMessage({route:"initCanvas",args:options._id})},stop:()=>{worker.postMessage({route:"stopAnim",args:options._id})},start:()=>{worker.postMessage({route:"startAnim",args:options._id})},set:newDrawProps=>{worker.postMessage({route:"setDraw",args:[newDrawProps,options._id]})},terminate:()=>{worker.terminate()}};return canvascontrols}function setDraw(settings,_id){let canvasopts;if(this?.__node?.graph){if(_id)canvasopts=this.__node.graph.CANVASES?.[settings._id];else if(settings._id)canvasopts=this.__node.graph.CANVASES?.[settings._id];else canvasopts=this.__node.graph.CANVASES?.[Object.keys(this.__node.graph.CANVASES)[0]]}else{if(_id)canvasopts=globalThis.CANVASES?.[settings._id];else if(settings._id)canvasopts=globalThis.CANVASES?.[settings._id];else canvasopts=globalThis.CANVASES?.[Object.keys(globalThis.CANVASES)[0]]}if(canvasopts){if(settings.canvas){canvasopts.canvas=settings.canvas;if(this?.__node?.graph)this.__node.graph.run("makeProxy",canvasopts._id,canvasopts.canvas);else proxyElementWorkerRoutes.makeProxy(canvasopts._id,canvasopts.canvas)}if(typeof settings.context==="string")canvasopts.context=canvasopts.canvas.getContext(settings.context);else if(settings.context)canvasopts.context=settings.context;if(settings.width)canvasopts.canvas.width=settings.width;if(settings.height)canvasopts.canvas.height=settings.height;if(typeof settings.draw==="string")settings.draw=parseFunctionFromText(settings.draw);if(typeof settings.draw==="function"){canvasopts.draw=settings.draw}if(typeof settings.update==="string")settings.update=parseFunctionFromText(settings.update);if(typeof settings.update==="function"){canvasopts.update=settings.update}if(typeof settings.init==="string")settings.init=parseFunctionFromText(settings.init);if(typeof settings.init==="function"){canvasopts.init=settings.init}if(typeof settings.clear==="string")settings.clear=parseFunctionFromText(settings.clear);if(typeof settings.clear==="function"){canvasopts.clear=settings.clear}return settings._id}return void 0}function setupCanvas(options){if(this?.__node?.graph){if(!this.__node.graph.CANVASES)this.__node.graph.CANVASES={}}else if(!globalThis.CANVASES)globalThis.CANVASES={};let canvasOptions=options;options._id?canvasOptions._id=options._id:canvasOptions._id=`canvas${Math.floor(Math.random()*1e15)}`;typeof options.context==="string"?canvasOptions.context=options.canvas.getContext(options.context):canvasOptions.context=options.context;"animating"in options?canvasOptions.animating=options.animating:canvasOptions.animating=true;if(this?.__node?.graph?.CANVASES[canvasOptions._id]){this.__node.graph.run("setDraw",canvasOptions)}else if(globalThis.CANVASES?.[canvasOptions._id]){setDraw(canvasOptions)}else{if(this?.__node?.graph)canvasOptions.graph=this.__node.graph;if(this?.__node?.graph)this.__node.graph.CANVASES[canvasOptions._id]=canvasOptions;else globalThis.CANVASES[canvasOptions._id]=canvasOptions;if(this?.__node?.graph)this.__node.graph.run("makeProxy",canvasOptions._id,canvasOptions.canvas);else proxyElementWorkerRoutes.makeProxy(canvasOptions._id,canvasOptions.canvas);if(options.width)canvasOptions.canvas.width=options.width;if(options.height)canvasOptions.canvas.height=options.height;if(typeof canvasOptions.draw==="string"){canvasOptions.draw=parseFunctionFromText(canvasOptions.draw)}else if(typeof canvasOptions.draw==="function"){canvasOptions.draw=canvasOptions.draw}if(typeof canvasOptions.update==="string"){canvasOptions.update=parseFunctionFromText(canvasOptions.update)}else if(typeof canvasOptions.update==="function"){canvasOptions.update=canvasOptions.update}if(typeof canvasOptions.init==="string"){canvasOptions.init=parseFunctionFromText(canvasOptions.init)}else if(typeof canvasOptions.init==="function"){canvasOptions.init=canvasOptions.init}if(typeof canvasOptions.clear==="string"){canvasOptions.clear=parseFunctionFromText(canvasOptions.clear)}else if(typeof canvasOptions.clear==="function"){canvasOptions.clear=canvasOptions.clear}if(typeof canvasOptions.init==="function")canvasOptions.init(canvasOptions,canvasOptions.canvas,canvasOptions.context);canvasOptions.stop=()=>{stopAnim(canvasOptions._id)};canvasOptions.start=draw=>{startAnim(canvasOptions._id,draw)};canvasOptions.set=settings=>{setDraw(settings,canvasOptions._id)};if(typeof canvasOptions.draw==="function"&&canvasOptions.animating){let draw=(s,canvas,context)=>{if(s.animating){s.draw(s,canvas,context);requestAnimationFrame(()=>{draw(s,canvas,context)})}};draw(canvasOptions,canvasOptions.canvas,canvasOptions.context)}}if(typeof WorkerGlobalScope!=="undefined"&&self instanceof WorkerGlobalScope)return canvasOptions._id;else{const canvascontrols={_id:options._id,width:options.width,height:options.height,draw:props=>{drawFrame(props,options._id)},update:props=>{updateCanvas(props,options._id)},clear:()=>{clearCanvas(options._id)},init:()=>{initCanvas(options._id)},stop:()=>{stopAnim(options._id)},start:()=>{startAnim(options._id)},set:newDrawProps=>{setDraw(newDrawProps,options._id)},terminate:()=>{stopAnim(options._id)}};return canvascontrols}}function drawFrame(props,_id){let canvasopts;if(this?.__node?.graph){if(!_id)canvasopts=this.__node.graph.CANVASES?.[Object.keys(this.__node.graph.CANVASES)[0]];else canvasopts=this.__node.graph.CANVASES?.[_id]}else{if(!_id)canvasopts=globalThis.CANVASES?.[Object.keys(globalThis.CANVASES)[0]];else canvasopts=globalThis.CANVASES?.[_id]}if(canvasopts){if(props)Object.assign(canvasopts,props);if(canvasopts.draw){canvasopts.draw(canvasopts,canvasopts.canvas,canvasopts.context);return _id}}return void 0}function clearCanvas(_id){let canvasopts;if(this?.__node?.graph){if(!_id)canvasopts=this.__node.graph.CANVASES?.[Object.keys(this.__node.graph.CANVASES)[0]];else canvasopts=this.__node.graph.CANVASES?.[_id]}else{if(!_id)canvasopts=globalThis.CANVASES?.[Object.keys(globalThis.CANVASES)[0]];else canvasopts=globalThis.CANVASES?.[_id]}if(canvasopts?.clear){canvasopts.clear(canvasopts,canvasopts.canvas,canvasopts.context);return _id}return void 0}function initCanvas(_id){let canvasopts;if(this?.__node?.graph){if(!_id)canvasopts=this.__node.graph.CANVASES?.[Object.keys(this.__node.graph.CANVASES)[0]];else canvasopts=this.__node.graph.CANVASES?.[_id]}else{if(!_id)canvasopts=globalThis.CANVASES?.[Object.keys(globalThis.CANVASES)[0]];else canvasopts=globalThis.CANVASES?.[_id]}if(canvasopts?.init){canvasopts.init(canvasopts,canvasopts.canvas,canvasopts.context);return _id}return void 0}function updateCanvas(input,_id){let canvasopts;if(this?.__node?.graph){if(!_id)canvasopts=this.__node.graph.CANVASES?.[Object.keys(this.__node.graph.CANVASES)[0]];else canvasopts=this.__node.graph.CANVASES?.[_id]}else{if(!_id)canvasopts=globalThis.CANVASES?.[Object.keys(globalThis.CANVASES)[0]];else canvasopts=globalThis.CANVASES?.[_id]}if(canvasopts?.update){canvasopts.update(canvasopts,canvasopts.canvas,canvasopts.context,input);return _id}return void 0}function setProps(props,_id){let canvasopts;if(this?.__node?.graph){if(!_id)canvasopts=this.__node.graph.CANVASES?.[Object.keys(this.__node.graph.CANVASES)[0]];else canvasopts=this.__node.graph.CANVASES?.[_id]}else{if(!_id)canvasopts=globalThis.CANVASES?.[Object.keys(globalThis.CANVASES)[0]];else canvasopts=globalThis.CANVASES?.[_id]}if(canvasopts){Object.assign(canvasopts,props);if(props.width)canvasopts.canvas.width=props.width;if(props.height)canvasopts.canvas.height=props.height;return _id}return void 0}function startAnim(_id,draw){let canvasopts;if(this?.__node?.graph){if(!_id)canvasopts=this.__node.graph.CANVASES?.[Object.keys(this.__node.graph.CANVASES)[0]];else canvasopts=this.__node.graph.CANVASES?.[_id]}else{if(!_id)canvasopts=globalThis.CANVASES?.[Object.keys(globalThis.CANVASES)[0]];else canvasopts=globalThis.CANVASES?.[_id]}canvasopts.animating=true;if(canvasopts&&draw){if(typeof draw==="string")draw=parseFunctionFromText(draw);if(typeof draw==="function"){canvasopts.draw=draw}return _id}if(typeof canvasopts?.draw==="function"){let draw2=(s,canvas,context)=>{if(s.animating){s.draw(s,canvas,context);requestAnimationFrame(()=>{draw2(s,canvas,context)})}};if(typeof canvasopts.clear==="function")canvasopts.clear(canvasopts,canvasopts.canvas,canvasopts.context);if(typeof canvasopts.init==="function")canvasopts.init(canvasopts,canvasopts.canvas,canvasopts.context);draw2(canvasopts,canvasopts.canvas,canvasopts.context);return _id}return void 0}function stopAnim(_id){let canvasopts;if(this?.__node?.graph){if(!_id)canvasopts=this.__node.graph.CANVASES?.[Object.keys(this.__node.graph.CANVASES)[0]];else canvasopts=this.__node.graph.CANVASES?.[_id]}else{if(!_id)canvasopts=globalThis.CANVASES?.[Object.keys(globalThis.CANVASES)[0]];else canvasopts=globalThis.CANVASES?.[_id]}if(canvasopts){canvasopts.animating=false;if(typeof canvasopts.clear==="function")canvasopts.clear(canvasopts,canvasopts.canvas,canvasopts.context);return _id}return void 0}var workerCanvasRoutes={...proxyElementWorkerRoutes,Renderer,transferCanvas,setupCanvas,setDraw,drawFrame,clearCanvas,initCanvas,updateCanvas,setProps,startAnim,stopAnim};function parseFunctionFromText(method=""){let getFunctionBody=methodString=>{return methodString.replace(/^\\W*(function[^{]+\\{([\\s\\S]*)\\}|[^=]+=>[^{]*\\{([\\s\\S]*)\\}|[^=]+=>(.+))/i,"$2$3$4")};let getFunctionHead=methodString=>{let startindex=methodString.indexOf("=>")+1;if(startindex<=0){startindex=methodString.indexOf("){")}if(startindex<=0){startindex=methodString.indexOf(") {")}return methodString.slice(0,methodString.indexOf("{",startindex)+1)};let newFuncHead=getFunctionHead(method);let newFuncBody=getFunctionBody(method);let newFunc;if(newFuncHead.includes("function")){let varName=newFuncHead.split("(")[1].split(")")[0];newFunc=new Function(varName,newFuncBody)}else{if(newFuncHead.substring(0,6)===newFuncBody.substring(0,6)){let varName=newFuncHead.split("(")[1].split(")")[0];newFunc=new Function(varName,newFuncBody.substring(newFuncBody.indexOf("{")+1,newFuncBody.length-1))}else{try{newFunc=(0,eval)(newFuncHead+newFuncBody+"}")}catch{}}}return newFunc}function parseFunctionFromText2(method=""){let getFunctionBody=methodString=>{return methodString.replace(/^\\W*(function[^{]+\\{([\\s\\S]*)\\}|[^=]+=>[^{]*\\{([\\s\\S]*)\\}|[^=]+=>(.+))/i,"$2$3$4")};let getFunctionHead=methodString=>{let startindex=methodString.indexOf("=>")+1;if(startindex<=0){startindex=methodString.indexOf("){")}if(startindex<=0){startindex=methodString.indexOf(") {")}return methodString.slice(0,methodString.indexOf("{",startindex)+1)};let newFuncHead=getFunctionHead(method);let newFuncBody=getFunctionBody(method);let newFunc;if(newFuncHead.includes("function")){let varName=newFuncHead.split("(")[1].split(")")[0];newFunc=new Function(varName,newFuncBody)}else{if(newFuncHead.substring(0,6)===newFuncBody.substring(0,6)){let varName=newFuncHead.split("(")[1].split(")")[0];newFunc=new Function(varName,newFuncBody.substring(newFuncBody.indexOf("{")+1,newFuncBody.length-1))}else{try{newFunc=(0,eval)(newFuncHead+newFuncBody+"}")}catch{}}}return newFunc}var stringifyWithCircularRefs=function(){const refs=new Map;const parents=[];const path=["this"];function clear(){refs.clear();parents.length=0;path.length=1}function updateParents(key,value){var idx=parents.length-1;var prev=parents[idx];if(typeof prev==="object"){if(prev[key]===value||idx===0){path.push(key);parents.push(value.pushed)}else{while(idx-->=0){prev=parents[idx];if(typeof prev==="object"){if(prev[key]===value){idx+=2;parents.length=idx;path.length=idx;--idx;parents[idx]=value;path[idx]=key;break}}idx--}}}}function checkCircular(key,value){if(value!=null){if(typeof value==="object"){if(key){updateParents(key,value)}let other=refs.get(value);if(other){return"[Circular Reference]"+other}else{refs.set(value,path.join("."))}}}return value}return function stringifyWithCircularRefs2(obj,space){try{parents.push(obj);return JSON.stringify(obj,checkCircular,space)}finally{clear()}}}();if(JSON.stringifyWithCircularRefs===void 0){JSON.stringifyWithCircularRefs=stringifyWithCircularRefs}var stringifyFast=function(){const refs=new Map;const parents=[];const path=["this"];function clear(){refs.clear();parents.length=0;path.length=1}function updateParents(key,value){var idx=parents.length-1;if(parents[idx]){var prev=parents[idx];if(typeof prev==="object"){if(prev[key]===value||idx===0){path.push(key);parents.push(value.pushed)}else{while(idx-->=0){prev=parents[idx];if(typeof prev==="object"){if(prev[key]===value){idx+=2;parents.length=idx;path.length=idx;--idx;parents[idx]=value;path[idx]=key;break}}idx++}}}}}function checkValues(key,value){let val;if(value!=null){if(typeof value==="object"){let c=value.constructor.name;if(key&&c==="Object"){updateParents(key,value)}let other=refs.get(value);if(other){return"[Circular Reference]"+other}else{refs.set(value,path.join("."))}if(c==="Array"){if(value.length>20){val=value.slice(value.length-20)}else val=value}else if(c.includes("Set")){val=Array.from(value)}else if(c!=="Object"&&c!=="Number"&&c!=="String"&&c!=="Boolean"){val="instanceof_"+c}else if(c==="Object"){let obj={};for(const prop in value){if(value[prop]==null){obj[prop]=value[prop]}else if(Array.isArray(value[prop])){if(value[prop].length>20)obj[prop]=value[prop].slice(value[prop].length-20);else obj[prop]=value[prop]}else if(value[prop].constructor.name==="Object"){obj[prop]={};for(const p in value[prop]){if(Array.isArray(value[prop][p])){if(value[prop][p].length>20)obj[prop][p]=value[prop][p].slice(value[prop][p].length-20);else obj[prop][p]=value[prop][p]}else{if(value[prop][p]!=null){let con=value[prop][p].constructor.name;if(con.includes("Set")){obj[prop][p]=Array.from(value[prop][p])}else if(con!=="Number"&&con!=="String"&&con!=="Boolean"){obj[prop][p]="instanceof_"+con}else{obj[prop][p]=value[prop][p]}}else{obj[prop][p]=value[prop][p]}}}}else{let con=value[prop].constructor.name;if(con.includes("Set")){obj[prop]=Array.from(value[prop])}else if(con!=="Number"&&con!=="String"&&con!=="Boolean"){obj[prop]="instanceof_"+con}else{obj[prop]=value[prop]}}}val=obj}else{val=value}}else{val=value}}return val}return function stringifyFast2(obj,space){parents.push(obj);let res=JSON.stringify(obj,checkValues,space);clear();return res}}();if(JSON.stringifyFast===void 0){JSON.stringifyFast=stringifyFast}var unsafeRoutes={setRoute:function(fn,fnName){if(typeof fn==="string")fn=parseFunctionFromText2(fn);if(typeof fn==="function"){if(!fnName)fnName=fn.name;if(this.__node.graph.get(fnName)){this.__node.graph.get(fnName).__setOperator(fn)}else{let node=this.__node.graph.add({__node:{tag:fnName},__operator:fn})}return true}return false},setNode:function(fn,fnName){if(typeof fn==="string")fn=parseFunctionFromText2(fn);if(typeof fn==="function"){if(!fnName)fnName=fn.name;if(this.__node.graph.get(fnName)){this.__node.graph.get(fnName).__setOperator(fn)}else this.__node.graph.add({__node:{tag:fnName},__operator:fn});return true}return false},setMethod:function(route,fn,fnName){if(typeof fn==="string")fn=parseFunctionFromText2(fn);if(typeof fn==="function"){if(!fnName)fnName=fn.name;if(this.__node.graph.get(route)){this.__node.graph.get(route)[fnName]=fn}else this.__node.graph.add({__node:{tag:fnName,[fnName]:fn}});return true}return false},assignRoute:function(route,source){if(this.__node.graph.get(route)&&typeof source==="object"){Object.assign(this.__node.graph.get(route),source)}},transferClass:(classObj,className)=>{if(typeof classObj==="object"){let str=classObj.toString();let message={route:"receiveClass",args:[str,className]};return message}return false},receiveClass:function(stringified,className){if(typeof stringified==="string"){if(stringified.indexOf("class")===0){let cls=(0,eval)("("+stringified+")");let name=className;if(!name)name=cls.name;this.__node.graph[name]=cls;return true}}return false},setGlobal:(key,value)=>{globalThis[key]=value;return true},assignGlobalObject:(target,source)=>{if(!globalThis[target])return false;if(typeof source==="object")Object.assign(globalThis[target],source);return true},setValue:function(key,value){this.__node.graph[key]=value;return true},assignObject:function(target,source){if(!this.__node.graph[target])return false;if(typeof source==="object")Object.assign(this.__node.graph[target],source);return true},setGlobalFunction:(fn,fnName)=>{if(typeof fn==="string")fn=parseFunctionFromText2(fn);if(typeof fn==="function"){if(!fnName)fnName=fn.name;globalThis[fnName]=fn;return true}return false},assignFunctionToGlobalObject:function(globalObjectName,fn,fnName){if(!globalThis[globalObjectName])return false;if(typeof fn==="string")fn=parseFunctionFromText2(fn);if(typeof fn==="function"){if(!fnName)fnName=fn.name;this.__node.graph[globalObjectName][fnName]=fn;return true}return false},setFunction:function(fn,fnName){if(typeof fn==="string")fn=parseFunctionFromText2(fn);if(typeof fn==="function"){if(!fnName)fnName=fn.name;this.__node.graph[fnName]=fn;return true}return false},assignFunctionToObject:function(objectName,fn,fnName){if(!this.__node.graph[objectName])return false;if(typeof fn==="string")fn=parseFunctionFromText2(fn);if(typeof fn==="function"){if(!fnName)fnName=fn.name;this.__node.graph[objectName][fnName]=fn;return true}return false}};var __defProp2=Object.defineProperty;var __defNormalProp=(obj,key,value)=>key in obj?__defProp2(obj,key,{enumerable:true,configurable:true,writable:true,value}):obj[key]=value;var __publicField=(obj,key,value)=>{__defNormalProp(obj,typeof key!=="symbol"?key+"":key,value);return value};var _Math2=class{constructor(){}static genSineWave(freq=20,peakAmp=1,nSec=1,fs=512,freq2=0,peakAmp2=1){var sineWave=[];var t=[];var increment=1/fs;for(var ti=0;ti<nSec;ti+=increment){var amplitude=Math.sin(2*Math.PI*freq*ti)*peakAmp;amplitude+=Math.sin(2*Math.PI*freq2*ti)*peakAmp2;sineWave.push(amplitude);t.push(ti)}return[t,sineWave]}static getSineAmplitude(frequency=20,peakAmplitude=1,ti=0,tOffset=0){return Math.sin(this.TWO_PI*frequency*ti+tOffset)*peakAmplitude}static mean(arr){var sum=arr.reduce((prev,curr)=>curr+=prev);return sum/arr.length}static mode(arr){return arr.sort((a,b)=>arr.filter(v=>v===a).length-arr.filter(v=>v===b).length).pop()}static std(arr,mean=void 0){let avg=mean;if(!mean)avg=this.mean(arr);let summed=0;for(let i=0;i<arr.length;i++){let subbed=arr[i]-avg;summed+=subbed*subbed}return Math.sqrt(summed/arr.length)}static relError(actual=[],forecast=[],abs=true){if(actual.length!==forecast.length)throw new Error("Input arrays of same length!");let i=actual.length;let d=new Array(actual.length);for(let j=0;j<i;j++){let dd=(actual[j]-forecast[j])/actual[j];if(abs)dd=Math.abs(dd);d[j]=dd}return d}static informationEntropy(probabilities=[]){let len=probabilities.length;let entropy=new Array(len);for(let i=0;i<len;i++){let ent=probabilities[i]*Math.log(probabilities[i]);if(isNaN(ent))ent=0;entropy[i]=ent}return entropy}static zscore(arr){let mean=this.mean(arr);let std=this.std(arr,mean);let z=new Array().length(arr.length);for(let i=0;i<arr.length;i++){z[i]=(arr[i]-mean)/std}return z}static variance(arr){var mean=this.mean(arr);return arr.reduce((a,b)=>a+(b-mean)**2,0)/arr.length}static dot(vec1,vec2){var dot=0;for(var i=0;i<vec1.length;i++){dot+=vec1[i]*vec2[i]}return dot}static cross3D(vec1,vec2){return[vec1[1]*vec2[2]-vec1[2]*vec2[1],vec1[2]*vec2[0]-vec1[0]*vec2[2],vec1[0]*vec2[1]-vec1[1]*vec2[0]]}static magnitude(vec){var sqrd=0;vec.forEach(c=>{sqrd+=c*c});return Math.sqrt(sqrd)}static distance(point1,point2){var dsqrd=0;point1.forEach((c,i)=>{dsqrd+=(point2[i]-c)*(point2[i]-c)});return Math.sqrt(dsqrd)}static midpoint(point1=[1,2,3],point2=[3,4,5]){return point1.map((c,i)=>{return(c+point2[i])*.5})}static normalize(vec){var norm=0;norm=this.magnitude(vec);var vecn=new Array(vec.length);vec.forEach((c,i)=>{vecn[i]=c*norm});return vecn}static normalizeSeries(arr=[],fromZero=true){let max=Math.max(...arr);let min=Math.min(...arr);if(fromZero==false){max=Math.max(max,Math.abs(min));min=0}if(max-min===0){min=0;if(max===0)max=1e-13}return arr.map(v=>(v-min)/(max-min))}static quadraticFormula(a,b,c){let bbmac4=Math.sqrt(b*b-4*a*c);if(!isNaN(bbmac4))return["complex","complex"];let _a2=1/(2*a);if(bbmac4===0)return[b*_a2];let nb=-b;return[(nb+bbmac4)*_a2,(nb-bbmac4)*_a2]}static newtonsMethod(foo=x2=>{return Math.pow(x2,5)+x2*x2-x2-.2},start=0,end=1,precision=.01,attempts=10){let roots=[];for(let i=0;i<attempts;i++){let seedx=Math.random()*(end-start);let guess=foo(seedx);let guess2=foo(seedx+precision);let slope=(guess2-guess)/precision;let xn=seedx+precision;while(Math.abs(slope)>precision){let step=-guess/slope2;let xn12=xn+step;guess=guess2;guess2=foo(xn12);let slope2=(guess2-guess)/(xn12-xn)}let idx;let f=roots.find((root,i2)=>{if(Math.abs(xn1-root)<precision){idx=i2;return true}});if(f)roots[idx]=(xn1+f)*.5;else roots.push(xn1)}return roots}static makeVec(point1,point2){var vec=[];point1.forEach((c,i)=>{vec.push(point2[i]-c)});return vec}static getBufferedValueByCoordinates(vb=new Array(300).fill(1),dims=[10,10,2],coordinate=[1,2,1],cardinal=void 0){let getIdx=(foundIdx=0,dimIdx=0)=>{if(dimIdx===dims.length)return foundIdx;if(dimIdx==0)foundIdx+=coordinate[dimIdx];else if(dims[dimIdx]==0)dimsAt0++;else{let reMul=(val=coordinate[dimIdx],di=dimIdx-1)=>{val*=dims[di];di--;if(di==0)return val;else return reMul(val,di)};foundIdx+=reMul(coordinate[dimIdx]+1,dimIdx-1)}dimIdx++;return getIdx(foundIdx,dimIdx)};let found=getIdx();if(cardinal){if(coordinate[coordinate.length-1]===0){let lastnonzero=0;let idx=0;while(idx!==coordinate.length-1){if(coordinate[idx]!==0)lastnonzero=idx;idx++}return vb[found-lastnonzero+cardinal]}return vb[found-dims.length+cardinal]}else{if(coordinate[coordinate.length-1]===0){let lastnonzero=0;let idx=0;while(idx!==coordinate.length-1){if(coordinate[idx]!==0)lastnonzero=idx;idx++}return vb.slice(found-lastnonzero,found+1)}return vb.slice(found-dims.length,found+1)}}static forBufferedMat(vb=new Array(100).fill(1),dims=[10,10],asIndex=(v,i,x2,y)=>{return v+x2+y}){let coordinate=[];let idx=0;let recurseFor=(depth=0,nextDepth=depth+1)=>{let result=new Array(vb.length);for(let di=0;di<dims[depth];di++){coordinate[depth]=di;if(dims[nextDepth])recurseFor(nextDepth);else{result[idx]=asIndex(vb[idx],idx,...coordinate);idx++}}return result};let recurseForArrFuncs=(depth,nextDepth=depth+1)=>{let result=new Array(vb.length);for(let di=0;di<dims[depth];di++){coordinate[depth]=di;if(dims[nextDepth])recurseFor(nextDepth);else{for(let dj=0;dj<dims.length;dj++){result[idx]=asIndex[dj](vb[idx],idx,...coordinate);idx++}}}return result};if(typeof asIndex==="function"){return recurseFor()}else if(Array.isArray(asIndex)){return recurseForArrFuncs()}}static mapBufferedMat(buffer=new Array(100).fill(1),dimensions=[10,10],asIndex=(v,idx,i,j)=>{console.log(`value:${v}, idx:${idx}, x:${i},y:${j}`);return v+i+j}){let coordinate=new Array(dimensions.length).fill(0);const iterateCoordinate=(coord,idx=0)=>{if(coord[idx]>=dimensions[idx]){coord[idx]=0;idx++;if(idx===dimensions.length)return;iterateCoordinate(coord,idx)}else coord[idx]++};let result=new Array(buffer.length);let i=0;if(typeof asIndex==="function"){while(i<buffer.length){result[i]=asIndex(buffer[i],i,...coordinate);i+=dimensions.length;iterateCoordinate(coordinate)}}else if(Array.isArray(asIndex)){while(i<buffer.length){asIndex.forEach(func=>{result[i]=func(buffer[i],i,...coordinate);i++;iterateCoordinate(coordinate)})}}return result}static combinations(choices=["a","b","c"],vecsize=3){var result=[];if(vecsize<=0){result.push([])}else{_Math2.combinations(choices,vecsize-1).forEach(function(previousComb){choices.forEach(function(element){result.push([element].concat(previousComb))})})}return result}static generateCoordinateSpace(upperBounds=[10,10,10],lowerBounds=[-10,-10,-10],steps=[1,1,1],mutater=void 0){for(let i=0;i<upperBounds.length;i++){if(lowerBounds[i]>upperBounds[i]){let temp=upperBounds[i];upperBounds[i]=lowerBounds[i];lowerBounds[i]=temp}}let result=[];let copy=[...upperBounds];let lastindex=copy.length-1;result.push([...copy]);while(copy[0]>=lowerBounds[0]){let checkNextIndex=decrIdx2=>{if(copy[decrIdx2]<=lowerBounds[decrIdx2]){if(decrIdx2===0)return;copy[decrIdx2]=upperBounds[decrIdx2];decrIdx2--;if(decrIdx2<0)return;if(typeof steps[decrIdx2]=="function")copy[decrIdx2]-=steps[decrIdx2](copy[decrIdx2]);else copy[decrIdx2]-=steps[decrIdx2];checkNextIndex(decrIdx2)}};let decrIdx=lastindex;if(typeof steps[decrIdx]=="function")copy[decrIdx]-=steps[decrIdx](copy[decrIdx]);else copy[decrIdx]-=steps[decrIdx];result.push([...copy]);checkNextIndex(decrIdx);if(mutater)result[result.length-1]=mutater(result[result.length-1])}return result}static calcVectorField(coordinates=[[0,0],[0,1],[1,0],[1,1]],formula=(x2,y)=>{return[x2*10,y*10]}){return coordinates.map(vec=>formula(...vec))}static transpose(mat){return mat[0].map((_,colIndex)=>mat.map(row=>row[colIndex]))}static matmul(a,b){var aNumRows=a.length,aNumCols=a[0].length,bNumRows=b.length,bNumCols=b[0].length,m=new Array(aNumRows);for(var r=0;r<aNumRows;++r){m[r]=new Array(bNumCols);for(var c=0;c<bNumCols;++c){m[r][c]=0;for(var i=0;i<aNumCols;++i){m[r][c]+=a[r][i]*b[i][c]}}}return m}static matscale(mat,scalar){let m=[];for(var i=0;i<mat.length;i++){m[i]=[];for(let j=0;j<mat[0].length;j++){m[i][j]=mat[i][j]*scalar}}return m}static matadd(a,b){let m=[];for(let i=0;i<a.length;i++){m[i]=[];for(var j=0;j<a[0].length;j++){m[i][j]=a[i][j]+b[i][j]}}return m}static matsub(a,b){let m=[];for(let i=0;i<a.length;i++){m[i]=[];for(var j=0;j<a[0].length;j++){m[i][j]=a[i][j]-b[i][j]}}return m}static histogram(arr=[],binSize=1,nBins=void 0){let copy=[...arr];copy.sort(function(a,b){return a-b});let binStart=Math.min(...copy);if(typeof nBins==="number"){let binEnd=Math.max(...copy);binSize=Math.abs((binEnd-binStart)/(nBins-1))}let j=binStart;let binx=[];let biny=[];for(let i=0;i<copy.length;i++){let binidx=binSize*j;if(copy[i]>binStart+binidx){j++;binidx+=binSize;let binmin=binStart+binidx;let binmid=binmin+binidx*.5;binx.push(binmid);biny.push(0)}biny[biny.length-1]++}return[binx,biny]}static normalDistribution(samples=[],normalize=true,cutoff=1e-4){let m=this.mean(samples);let vari=this.variance(samples);let nSamples=samples.length;let probabilities=[];let denom=1/(this.TWO_PI*vari);let _variance=1/vari;let sum=0;for(let i=0;i<nSamples;i++){let px=Math.exp(-.5*Math.pow((samples[i]-m)*_variance,2))*denom;if(px<cutoff)px=0;probabilities.push(px);sum+=px}if(normalize){let _sum=1/sum;probabilities=probabilities.map(x2=>x2*_sum)}return probabilities}static expectedValue(samples=[],probabilities=this.normalDistribution(samples)){return samples.reduce((sum,item,idx)=>sum+item*probabilities[idx])}static originMoment(samples=[],probabilities=this.normalDistribution(samples),order=1){return samples.reduce((sum,item,idx)=>sum+Math.pow(item,order)*probabilities[idx])}static centralMoment(samples=[],probabilities=this.normalDistribution(samples),order=1){let m=this.mean(samples);return samples.reduce((sum,item,idx)=>sum+Math.pow(item-m,order)*probabilities[idx]/samples.length)}static linearDiscriminantAnalysis(samples=[],classifier=[]){let mean=this.mean(samples);let meank=this.mean(classifier);let covariance=this.cov1d(samples,classifier);let probs=this.normalDistribution(samples);let dk=[];for(let i=0;i<samples.length;i++){dk.push(x[i]*covariance*meank-.5*mean*covariance*meank+Math.log10(probs[i]))}return dk}static conv1D(arr=[],kern=[1/3,1/3,1/3],pad=Math.floor(kern.length*.5)){let result=[];let _n=1/kern.length;if(pad>0){let pads=new Array(pad).fill(0);arr=[...pads,...arr,...pads]}let start=Math.floor(kern.length*.5);let end=arr.length-kern.length+start;for(let i=start;i<end;i++){let acc=0;for(let j=0;j<kern.length;j++){acc+=arr[i-start]*kern[j]}result.push(acc*_n)}return result}static conv2D(mat=[[],[],[]],kern=[[],[],[]],pad=0){let result=new Array(mat.length-Math.ceil(kern.length*.5)).fill([]);let mat_t;let kern_t=_Math2.transpose(kern_t);if(pad>0){let pads=new Array(pad).fill(0);mat_t=_Math2.transpose(mat);for(let i2=0;i2<mat_t.length;i2++){mat_t[i2]=[...pads,...mat_t[i2],...pads]}mat=_Math2.transpose(mat_t);for(let j=0;j<mat.length;j++){mat[j]=[...pads,...mat[j],...pads]}}let startr=Math.floor(kern[0].length*.5);let startl=Math.floor(kern_t[0].length*.5);let endr=mat[0].length-kern[0].length+startr;let endl=mat_t[0].length-kern_t[0].length+startl;let _n=1/(kern[0].length*kern_t[0].length);let iters=endr*endl;let i=startr;let x2;let y=startl;while(i<iters){let acc=0;x2=i%mat[0].length;if(x2===0){y++}for(let j=0;j<kern[0].length;j++){for(let k=0;k<kern_t[0].length;j++){acc+=mat[y-startl+k][x2-startr+j]*kern[k][j]}result[y].push(acc*_n)}i++}return result}static cov2d(mat){var mattransposed=this.transpose(mat);var matproducts=[];var rowmeans=[];var colmeans=[];mat.forEach((row,idx)=>{rowmeans.push(this.mean(row))});mattransposed.forEach((col,idx)=>{colmeans.push(this.mean(col))});mat.forEach((row,idx)=>{matproducts.push([]);for(var col=0;col<row.length;col++){matproducts[idx].push((mat[idx][col]-rowmeans[idx])*(mat[idx][col]-colmeans[col])/(row.length-1))}});var matproductstransposed=this.transpose(matproducts);var aNumRows=matproducts.length,aNumCols=matproducts[0].length,bNumRows=matproductstransposed.length,bNumCols=matproductstransposed[0].length,m=new Array(aNumRows);for(var r=0;r<aNumRows;++r){m[r]=new Array(bNumCols);for(var c=0;c<bNumCols;++c){m[r][c]=0;for(var i=0;i<aNumCols;++i){m[r][c]+=matproducts[r][i]*matproductstransposed[i][c]/(mat[0].length-1)}}}return m}static cov1d(arr1=[],arr2=[]){return this.cov2d([arr1,arr2])}static cov3d(x2=[],y=[],z=[]){return[[this.cov1d(x2,x2),this.cov1d(x2,y),this.cov1d(x2,z)],[this.cov1d(y,x2),this.cov1d(y,y),this.cov1d(y,z)],[this.cov1d(z,x2),this.cov1d(z,y),this.cov1d(z,z)]]}static covNd(dimensionalData=[]){let covariance=[];dimensionalData.forEach((arr,i)=>{covariance.push([]);dimensionalData.forEach((arr2,j)=>{covariance[i].push(this.cov1d(arr,arr2))})})}static eigens2x2(mat=[[1,2],[3,4]]){let det=mat[0][0]*mat[1][1]-mat[0][1]*mat[1][0];let mean=(mat[0][0]+mat[1][1])*.5;let sqrt=Math.sqrt(mean*mean-det);let eig1=mean+sqrt;let eig2=mean-sqrt;return[eig1,eig2]}static eigenvectors2x2(mat=[[1,2],[3,4]],eigens=[1,2]){let v1=[-mat[0][1],mat[0][0]-eigens[0]];if(v1[0]===0&&v1[1]===0){v1[0]=mat[1][1]-eigens[0];v1[1]=-mat[1][0]}let v2=[-mat[0][1],mat[0][0]-eigens[1]];if(v2[0]===0&&v2[1]===0){v2[0]=mat[1][1]-eigens[1];v2[1]=-mat[1][0]}return[v1,v2]}static fastpca2d(xarr,yarr){let cov1d=this.cov1d(xarr,yarr);let eigs=this.eigens2x2(cov1d);if(eigs[1]>eigs[0])eigs.reverse();let evs=this.eigenvectors2x2(cov1d,eigs);console.log(eigs,evs);return[eigs,evs]}static crosscorrelation(arr1,arr2){var arr2buf=[...arr2,...Array(arr2.length).fill(0)];var mean1=this.mean(arr1);var mean2=this.mean(arr2);var arr1Est=arr1.reduce((sum,item)=>sum+=Math.pow(item-mean1,2));arr1Est=Math.sqrt(Math.abs(arr1Est));var arr2Est2=arr2.reduce((sum,item)=>sum+=Math.pow(item-mean1,2));arr2Est2=Math.sqrt(Math.abs(arr2Est2));let denom=arr1Est*arr2Est2;if(denom===0)denom=1e-26;var _arrEstsMul=1/denom;var correlations=new Array(arr1.length).fill(0);for(var delay=0;delay<arr1.length;delay++){var r=arr1.reduce((sum,item,i)=>sum+=(item-mean1)*(arr2buf[delay+i]-mean2));correlations[delay]=r*_arrEstsMul}return correlations}static autocorrelation(arr1){var delaybuf=[...arr1,...Array(arr1.length).fill(0)];var mean1=this.mean(arr1);var arr1Est=arr1.reduce((sum,item)=>sum+=Math.pow(item-mean1,2));arr1Est=Math.sqrt(Math.abs(arr1Est));let denom=arr1Est*arr2Est;if(denom===0)denom=1e-26;var _arr1estsqrd=1/denom;var correlations=new Array(arr1.length).fill(0);for(var delay=0;delay<arr1.length;delay++){var r=arr1.reduce((sum,item,i)=>sum+=(item-mean1)*(delaybuf[delay+i]-mean1));correlations[delay]=r*_arr1estsqrd}return correlations}static autocorrelation2dNormalized(mat2d2){let result=[];for(let y=0;y<mat2d2.length;y++){result.push([]);for(let x2=0;x2<mat2d2[y].length;x2++){let G=0;let _G=0;for(let b=0;b<mat2d2.length;b++){for(let a=0;a<mat2d2[b].length;a++){G+=mat2d2[y][x2]*mat2d2[mat2d2.length-1-b][mat2d2[y].length-1-a];_G+=mat2d2[y][x2]*mat2d2[mat2d2.length-1][mat2d2[y].length-1]}}result[y][x2]=G/_G-1}}return result}static crosscorrelation2d(mat2d1,mat2d2){let result=[];for(let y=0;y<mat2d1.length;y++){result.push([]);for(let x2=0;x2<mat2d1[y].length;x2++){let G=0;for(let b=0;b<mat2d2.length;b++){for(let a=0;a<mat2d2[b].length;a++){G+=mat2d1[y][x2]*mat2d2[mat2d2.length-1-b][mat2d2[y].length-1-a]}}result[y][x2]=G}}return result}static crosscorrelation2dNormalized(mat2d1,mat2d2){let result=[];for(let y=0;y<mat2d1.length;y++){result.push([]);for(let x2=0;x2<mat2d1[y].length;x2++){let G=0;let _G=0;for(let b=0;b<mat2d2.length;b++){for(let a=0;a<mat2d2[b].length;a++){G+=mat2d1[y][x2]*mat2d2[mat2d.length-1-b][mat2d2[y].length-1-a];_G+=mat2d1[y][x2]*mat2d2[mat2d2.length-1][mat2d2[y].length-1]}}result[y][x2]=G/_G-1}}return result}static correlograms(dat=[[],[]]){var correlograms=[];dat.forEach((row1,i)=>{dat.forEach((row2,j)=>{if(j>=i){correlograms.push(_Math2.crosscorrelation(row1,row2))}})});return correlograms}static dft(sineWave=[]){var TWOPI=2*3.141592653589793;var real=[];var imag=[];var mags=[];for(var k=0;k<sineWave.length;k++){real.push(0);imag.push(0);for(var j=0;j<sineWave.length;j++){var shared=TWOPI*k*j/sineWave.length;real[k]=real[k]+sineWave[j]*Math.cos(shared);imag[k]=imag[k]-sineWave[j]*Math.sin(shared)}mags.push(Math.sqrt(real[k]*real[k]+imag[k]*imag[k]))}function orderMagnitudes(unorderedMags){return[...unorderedMags.slice(Math.ceil(unorderedMags.length*.5),unorderedMags.length),...unorderedMags.slice(0,Math.ceil(unorderedMags.length*.5))]}mags=orderMagnitudes(mags);let halflen=mags.length*.5;let freqs=mags.map((m,i)=>{return i-halflen});return{real,imag,freqs,mags}}static sma(arr=[],window){var smaArr=[];for(var i=0;i<arr.length;i++){if(i==0){smaArr.push(arr[0])}else if(i<window){var arrslice=arr.slice(0,i+1);smaArr.push(arrslice.reduce((previous,current)=>current+=previous)/(i+1))}else{var arrslice=arr.slice(i-window,i);smaArr.push(arrslice.reduce((previous,current)=>current+=previous)/window)}}return smaArr}static sum(arr=[]){if(arr.length>0){var sum=arr.reduce((prev,curr)=>curr+=prev);return sum}else{return 0}}static reduceArrByFactor(arr,factor=2){let x2=arr.filter((element,index)=>{return index%factor===0});return x2}static makeArr(startValue,stopValue,nSteps){var arr=[];var step=(stopValue-startValue)/(nSteps-1);for(var i=0;i<nSteps;i++){arr.push(startValue+step*i)}return arr}static autoscale(array,stackedLines=1,stackPosition=0,centerZero=false){if(array?.length===0)return array;let max=Math.max(...array);let min=Math.min(...array);let _lines=1/stackedLines;let scalar;if(centerZero){let absmax=Math.max(Math.abs(min),Math.abs(max));scalar=_lines/absmax;return array.map(y=>y*scalar+(_lines*(stackPosition+1)*2-1-_lines))}else{scalar=_lines/(max-min);return array.map(y=>2*((y-min)*scalar-1/(2*stackedLines))+(_lines*(stackPosition+1)*2-1-_lines))}}static absmax(array){return Math.max(Math.abs(Math.min(...array)),Math.max(...array))}static downsample(array,fitCount,scalar=1){if(array.length>fitCount){let output=new Array(fitCount);let incr=array.length/fitCount;let lastIdx=array.length-1;let last=0;let counter=0;for(let i=incr;i<array.length;i+=incr){let rounded=Math.round(i);if(rounded>lastIdx)rounded=lastIdx;for(let j=last;j<rounded;j++){output[counter]+=array[j]}output[counter]/=(rounded-last)*scalar;counter++;last=rounded}return output}else return array}static interpolateArray(data,fitCount,scalar=1){var linearInterpolate=function(before2,after2,atPoint2){return(before2+(after2-before2)*atPoint2)*scalar};var newData=new Array;var springFactor=(data.length-1)/(fitCount-1);newData[0]=data[0];for(var i=1;i<fitCount-1;i++){var tmp=i*springFactor;var before=Math.floor(tmp);var after=Math.ceil(tmp);var atPoint=tmp-before;newData[i]=linearInterpolate(data[before],data[after],atPoint)}newData[fitCount-1]=data[data.length-1];return newData}static isExtrema(arr,critical="peak"){let ref=[...arr];if(ref.length%2===0)ref.pop();if(arr.length>1){let pass=true;for(let i=0;i<ref.length;i++){let val=ref[i];if(critical==="peak"){if(i<Math.floor(ref.length*.5)&&val>=ref[Math.floor(ref.length*.5)]){pass=false;break}else if(i>Math.floor(ref.length*.5)&&val>=ref[Math.floor(ref.length*.5)]){pass=false;break}}else if(critical==="valley"){if(i<Math.floor(ref.length*.5)&&val<=ref[Math.floor(ref.length*.5)]){pass=false;break}else if(i>Math.floor(ref.length*.5)&&val<=ref[Math.floor(ref.length*.5)]){pass=false;break}}else{if(i<Math.floor(ref.length*.5)&&val<=ref[Math.floor(ref.length*.5)]){pass=false;break}else if(i>Math.floor(ref.length*.5)&&val<=ref[Math.floor(ref.length*.5)]){pass=false;break}}}if(critical!=="peak"&&critical!=="valley"&&pass===false){pass=true;for(let i=0;i<ref.length;i++){let val=ref[i];if(i<Math.floor(ref.length*.5)&&val>=ref[Math.floor(ref.length*.5)]){pass=false;break}else if(i>Math.floor(ref.length*.5)&&val>=ref[Math.floor(ref.length*.5)]){pass=false;break}}}return pass}else return void 0}static isCriticalPoint(arr,critical="peak"){let ref=[...arr];if(ref.length%2===0)ref.pop();if(arr.length>1){let pass=true;for(let i=0;i<ref.length;i++){let val=ref[i];if(critical==="peak"){if(i<ref.length*.5&&val<=0){pass=false;break}else if(i>ref.length*.5&&val>0){pass=false;break}}else if(critical==="valley"){if(i<ref.length*.5&&val>=0){pass=false;break}else if(i>ref.length*.5&&val<0){pass=false;break}}else{if(i<ref.length*.5&&val>=0){pass=false;break}else if(i>ref.length*.5&&val<0){pass=false;break}}}if(critical!=="peak"&&critical!=="valley"&&pass===false){pass=true;for(let i=0;i<ref.length;i++){let val=ref[i];if(i<ref.length*.5&&val<=0){pass=false;break}else if(i>ref.length*.5&&val>0){pass=false;break}}}return pass}else return void 0}static getPeakThreshold(arr,peakIndices,thresholdVar){let threshold;let filtered=arr.filter((o,i)=>{if(peakIndices.indexOf(i)>-1)return true});if(thresholdVar===0){threshold=this.mean(filtered)}else threshold=(thresholdVar+this.mean(filtered))*.5;return threshold}static column(mat,x2){let col=new Array(mat.length).fill(0).map(()=>new Array(1).fill(0));for(let i=0;i<mat.length;i++){col[i][0]=mat[i][x2]}return col}static flatten_vector(v){let v_new=[];for(let i=0;i<v.length;i++){v_new[i]=v[i][0]}return v_new}static squared_difference(v1,v2){let sum=0;for(let i=0;i<v1.length;i++){sum=sum+Math.pow(v1[i]-v2[i],2)}return sum}static shift_deflate(mat,eigenvalue,eigenvector){let len=Math.sqrt(this.matmul(this.transpose(eigenvector),eigenvector));let U=this.matscale(eigenvector,1/len);let delta=this.matscale(this.matmul(U,this.transpose(U)),eigenvalue);let M_new=this.matsub(mat,delta);return M_new}static eigenvalue_of_vector(mat,eigenvector){ev=this.matmul(this.matmul(this.transpose(eigenvector),mat),eigenvector);return ev}static power_iteration(mat,tolerance=1e-5,max_iterations=1e3){let rank=mat.length;let eigenvector=new Array(rank).fill(0).map(()=>new Array(1).fill(Math.sqrt(rank)));let eigenvalue=this.eigenvalue_of_vector(mat,eigenvector);let epsilon=1;let iter=0;while(epsilon>tolerance&&iter<max_iterations){let old_eigenvalue=JSON.parse(JSON.stringify(eigenvalue));let Mv=this.matmul(mat,eigenvector);eigenvector=this.normalize(Mv);eigenvalue=this.eigenvalue_of_vector(mat,eigenvector);epsilon=Math.abs(eigenvalue-old_eigenvalue);iter++};return[eigenvalue,eigenvector]}static eigens(mat,tolerance=1e-4,max_iterations=1e3){let eigenvalues=[];let eigenvectors=[];for(let i=0;i<mat.length;i++){let result=this.power_iteration(mat,tolerance,max_iterations);let eigenvalue=result[0];let eigenvector=result[1];eigenvalues[i]=eigenvalue;eigenvectors[i]=this.flatten_vector(eigenvector);mat=this.shift_deflate(mat,eigenvalue,eigenvector)}return[eigenvalues,eigenvectors]}static pca(mat,tolerance=1e-5){let dims=mat.length;let t=new Array(dims);let p=new Array(dims);let mat_t=this.transpose(mat);t[0]=this.column(mat,0);let epsilon=1;let iter=0;while(espilon>tolerance){iter++;p[0]=this.matmul(mat_t,t[0]);let tp=this.matmul(this.transpose(t[0]),t[0]);p[0]=this.matscale(p[0],1/tp);let p_length=Math.sqrt(this.matmul(this.transpose(p[0]),p[0]));p[0]=this.matscale(p[0],1/p_length);let t_new=this.matmul(mat,p[0]);let pp=this.matmul(this.transpose(p[0]),p[0]);t_new=this.matscale(t_new,1/pp);epsilon=this.squared_difference(t[0],t_new);t[0]=JSON.parse(JSON.stringify(t_new))}let components=this.matmul(this.transpose(t[0]),t[0]);return components}static circularBuffer(arr,newEntries){if(Array.isArray(newEntries)){if(newEntries.length<arr.length){let slice=arr.slice(newEntries.length);let len=arr.length;arr.splice(0,len,...slice,...newEntries)}else if(newEntries.length>arr.length){let len=arr.length;arr.splice(0,len,newEntries.slice(len-newEntries.length))}else{arr.splice(0,arr.length,...newEntries)}}else{arr.push(newEntries);arr.shift()}return arr}static HSLToRGB(h,s,l,scalar=255){s/=100;l/=100;let c=(1-Math.abs(2*l-1))*s,x2=c*(1-Math.abs(h/60%2-1)),m=l-c/2,r=0,g=0,b=0;if(0<=h&&h<60){r=c;g=x2;b=0}else if(60<=h&&h<120){r=x2;g=c;b=0}else if(120<=h&&h<180){r=0;g=c;b=x2}else if(180<=h&&h<240){r=0;g=x2;b=c}else if(240<=h&&h<300){r=x2;g=0;b=c}else if(300<=h&&h<360){r=c;g=0;b=x2}r=(r+m)*scalar;g=(g+m)*scalar;b=(b+m)*scalar;return[r,g,b]}static p300(event_timestamps=[],raw_signal=[],signal_timestamps=[],sps=256){let smoothingstep=Math.floor(sps/10);let smoothed=this.sma(raw_signal,smoothingstep);let peaks=this.peakDetect(smoothed,"peak",smoothingstep);let mean=this.mean(smoothed);let std=this.std(smoothed,mean);let p_idx=0;let candidates=[];if(peaks.length>0){event_timestamps.forEach((t,j)=>{while(signal_timestamps[peaks[p_idx]]<t+200){p_idx++;if(!peaks[p_idx])break}let tempi=0;let tempcandidates=[];while(signal_timestamps[peaks[p_idx+tempi]]<t+600){tempcandidates.push(p_idx+tempi);tempi++;if(!peaks[p_idx+tempi])break}if(tempcandidates.length>1){let peakvals=[];tempcandidates.forEach(tc=>{peakvals.push(smoothed[peaks[tc]])});let max=Math.max(...peakvals);let maxi=tempcandidates[peakvals.indexOf(max)];candidates.push({event_timestamp:t,event_index:j,peak_timestamp:signal_timestamps[[peaks[maxi]]],signal_index:[peaks[maxi]],signal_amplitude:raw_signal[[peaks[maxi]]],zscore:(smoothed[peaks[maxi]]-mean)/std})}else if(tempcandidates.length===1)candidates.push({event_timestamp:t,event_index:j,peak_timestamp:signal_timestamps[peaks[tempcandidates[0]]],signal_index:peaks[tempcandidates[0]],signal_amplitude:raw_signal[[peaks[tempcandidates[0]]]],zscore:(smoothed[peaks[tempcandidates[0]]]-mean)/std})})}return candidates}};var Math2=_Math2;__publicField(Math2,"TWO_PI",Math.PI*2);__publicField(Math2,"C",299792458);__publicField(Math2,"G",66743e-15);__publicField(Math2,"h",662607015e-42);__publicField(Math2,"R",8314.32);__publicField(Math2,"Ra",287);__publicField(Math2,"H",69.3);__publicField(Math2,"kbar",1054571817e-43);__publicField(Math2,"kB",1380649e-29);__publicField(Math2,"ke",89875517923e-1);__publicField(Math2,"me",91093837015e-41);__publicField(Math2,"mp",167262192369e-38);__publicField(Math2,"mn",167492749804e-38);__publicField(Math2,"P0",101325);__publicField(Math2,"T0",288.15);__publicField(Math2,"p0",1.225);__publicField(Math2,"Na",60220978e16);__publicField(Math2,"y",1.405);__publicField(Math2,"M0",28.96643);__publicField(Math2,"g0",9.80665);__publicField(Math2,"Re",6378100);__publicField(Math2,"B",1458e-9);__publicField(Math2,"S",110.4);__publicField(Math2,"Sigma",365e-12);__publicField(Math2,"imgkernels",{edgeDetection:[[-1,-1,-1],[-1,8,-1],[-1,-1,-1]],boxBlur:[[1/9,1/9,1/9],[1/9,1/9,1/9],[1/9,1/9,1/9]],sobelLeft:[[1,0,-1],[2,0,-2],[1,0,-1]],sobelRight:[[-1,0,1],[-2,0,2],[-1,0,1]],sobelTop:[[1,2,1],[0,0,0],[-1,-2,-1]],sobelBottom:[[-1,2,1],[0,0,0],[1,2,1]],identity:[[0,0,0],[0,1,0],[0,0,0]],gaussian3x3:[[1,2,1],[2,4,2],[1,2,1]],guassian7x7:[[0,0,0,5,0,0,0],[0,5,18,32,18,5,0],[0,18,64,100,64,18,0],[5,32,100,100,100,32,5],[0,18,64,100,64,18,0],[0,5,18,32,18,5,0],[0,0,0,5,0,0,0]],emboss:[[-2,-1,0],[-1,1,1],[0,1,2]],sharpen:[[0,-1,0],[-1,5,-1],[0,-1,0]]});__publicField(Math2,"integral",(func=x2=>{let y=x2;return y},range=[],stepx=.01)=>{let area=0;for(let i=range[0];i<range[1];i+=stepx){let y=func(i);area+=y*stepx}return area});__publicField(Math2,"dintegral",(func=(x2,y)=>{let z=x2+y;return z},range=[[],[]],stepx=.01,stepy=stepx)=>{let volume=0;for(let i=range[0][0]+stepx;i<range[0][1];i+=stepx){for(let j=range[1][0]+stepy;j<range[1][1];j+=stepy){let z=func(i,j);volume+=z*stepx*stepy}}return volume});__publicField(Math2,"tintegral",(func=(x2,y,z)=>{let w=x2+y+z;return w},range=[[],[],[]],stepx=.01,stepy=stepx,stepz=stepx)=>{let volume=0;for(let i=range[0][0]+stepx;i<range[0][1];i+=stepx){for(let j=range[1][0]+stepy;j<range[1][1];j+=stepy){for(let k=range[2][0]+stepz;k<range[2][1];k+=stepz){let w=func(i,j,k);volume+=w*stepx*stepy*stepz}}}return volume});__publicField(Math2,"pintegral",(func=x2=>{let y=x2;return y},range=[],stepx=.01)=>{let length=0;let y0=void 0;let yi=void 0;for(let i=range[0];i<range[1];i+=stepx){y0=yi;yi=func(i);if(y0)length+=_Math2.distance([0,y0],[stepx,yi])}return length});__publicField(Math2,"meshgrid",_Math2.generateCoordinateSpace);__publicField(Math2,"autocorrelation2d",mat2d2=>{let result=[];for(let y=0;y<mat2d2.length;y++){result.push([]);for(let x2=0;x2<mat2d2[y].length;x2++){let G=0;for(let b=0;b<mat2d2.length;b++){for(let a=0;a<mat2d2[b].length;a++){G+=mat2d2[y][x2]*mat2d2[mat2d2.length-1-b][mat2d2[y].length-1-a]}}result[y][x2]=G}}return result});__publicField(Math2,"lerp",_Math2.makeArr);__publicField(Math2,"upsample",_Math2.interpolateArray);__publicField(Math2,"lerp",(v0,v1,fit,floor=true)=>{function lerp(v02,v12,t){return(1-t)*v02+t*v12}function interpolerp(v02,v12,fit2,floor2=true){if(fit2<=2)return[v02,v12];let a=1/fit2;let result=new Array(fit2);result[0]=v02;for(let i=1;i<=fit2;i++){result[i]=lerp(v02,v12,a*i);if(floor2)result[i]=Math.floor(result[i])}return result}});__publicField(Math2,"peakDetect",(smoothedArray,type="peak",window=49)=>{let mid=Math.floor(window*.5);let peaks=[];for(let i=0;i<smoothedArray.length-window;i++){let isPeak=_Math2.isExtrema(smoothedArray.slice(i,i+window),type);if(isPeak){peaks.push(i+mid-1)}}return peaks});Object.assign(Math,Math2);if(typeof WorkerGlobalScope!=="undefined"&&self instanceof WorkerGlobalScope){self.SERVICE=new WorkerService({services:{workerCanvasRoutes,unsafeRoutes,Math,Math2}})}var Worker_default=self;})();\n')],{type:"text/javascript"}));var Worker_default=url;function parseFunctionFromText(method=""){let getFunctionBody=methodString=>{return methodString.replace(/^\W*(function[^{]+\{([\s\S]*)\}|[^=]+=>[^{]*\{([\s\S]*)\}|[^=]+=>(.+))/i,"$2$3$4")};let getFunctionHead=methodString=>{let startindex=methodString.indexOf("=>")+1;if(startindex<=0){startindex=methodString.indexOf("){")}if(startindex<=0){startindex=methodString.indexOf(") {")}return methodString.slice(0,methodString.indexOf("{",startindex)+1)};let newFuncHead=getFunctionHead(method);let newFuncBody=getFunctionBody(method);let newFunc;if(newFuncHead.includes("function")){let varName=newFuncHead.split("(")[1].split(")")[0];newFunc=new Function(varName,newFuncBody)}else{if(newFuncHead.substring(0,6)===newFuncBody.substring(0,6)){let varName=newFuncHead.split("(")[1].split(")")[0];newFunc=new Function(varName,newFuncBody.substring(newFuncBody.indexOf("{")+1,newFuncBody.length-1))}else{try{newFunc=(0,eval)(newFuncHead+newFuncBody+"}")}catch{}}}return newFunc}var stringifyWithCircularRefs=function(){const refs=new Map;const parents=[];const path=["this"];function clear(){refs.clear();parents.length=0;path.length=1}function updateParents(key,value){var idx=parents.length-1;var prev=parents[idx];if(typeof prev==="object"){if(prev[key]===value||idx===0){path.push(key);parents.push(value.pushed)}else{while(idx-->=0){prev=parents[idx];if(typeof prev==="object"){if(prev[key]===value){idx+=2;parents.length=idx;path.length=idx;--idx;parents[idx]=value;path[idx]=key;break}}idx--}}}}function checkCircular(key,value){if(value!=null){if(typeof value==="object"){if(key){updateParents(key,value)}let other=refs.get(value);if(other){return"[Circular Reference]"+other}else{refs.set(value,path.join("."))}}}return value}return function stringifyWithCircularRefs2(obj,space){try{parents.push(obj);return JSON.stringify(obj,checkCircular,space)}finally{clear()}}}();if(JSON.stringifyWithCircularRefs===void 0){JSON.stringifyWithCircularRefs=stringifyWithCircularRefs}var stringifyFast=function(){const refs=new Map;const parents=[];const path=["this"];function clear(){refs.clear();parents.length=0;path.length=1}function updateParents(key,value){var idx=parents.length-1;if(parents[idx]){var prev=parents[idx];if(typeof prev==="object"){if(prev[key]===value||idx===0){path.push(key);parents.push(value.pushed)}else{while(idx-->=0){prev=parents[idx];if(typeof prev==="object"){if(prev[key]===value){idx+=2;parents.length=idx;path.length=idx;--idx;parents[idx]=value;path[idx]=key;break}}idx++}}}}}function checkValues(key,value){let val;if(value!=null){if(typeof value==="object"){let c=value.constructor.name;if(key&&c==="Object"){updateParents(key,value)}let other=refs.get(value);if(other){return"[Circular Reference]"+other}else{refs.set(value,path.join("."))}if(c==="Array"){if(value.length>20){val=value.slice(value.length-20)}else val=value}else if(c.includes("Set")){val=Array.from(value)}else if(c!=="Object"&&c!=="Number"&&c!=="String"&&c!=="Boolean"){val="instanceof_"+c}else if(c==="Object"){let obj={};for(const prop in value){if(value[prop]==null){obj[prop]=value[prop]}else if(Array.isArray(value[prop])){if(value[prop].length>20)obj[prop]=value[prop].slice(value[prop].length-20);else obj[prop]=value[prop]}else if(value[prop].constructor.name==="Object"){obj[prop]={};for(const p in value[prop]){if(Array.isArray(value[prop][p])){if(value[prop][p].length>20)obj[prop][p]=value[prop][p].slice(value[prop][p].length-20);else obj[prop][p]=value[prop][p]}else{if(value[prop][p]!=null){let con=value[prop][p].constructor.name;if(con.includes("Set")){obj[prop][p]=Array.from(value[prop][p])}else if(con!=="Number"&&con!=="String"&&con!=="Boolean"){obj[prop][p]="instanceof_"+con}else{obj[prop][p]=value[prop][p]}}else{obj[prop][p]=value[prop][p]}}}}else{let con=value[prop].constructor.name;if(con.includes("Set")){obj[prop]=Array.from(value[prop])}else if(con!=="Number"&&con!=="String"&&con!=="Boolean"){obj[prop]="instanceof_"+con}else{obj[prop]=value[prop]}}}val=obj}else{val=value}}else{val=value}}return val}return function stringifyFast2(obj,space){parents.push(obj);let res=JSON.stringify(obj,checkValues,space);clear();return res}}();if(JSON.stringifyFast===void 0){JSON.stringifyFast=stringifyFast}var unsafeRoutes={setRoute:function(fn,fnName){if(typeof fn==="string")fn=parseFunctionFromText(fn);if(typeof fn==="function"){if(!fnName)fnName=fn.name;if(this.__node.graph.get(fnName)){this.__node.graph.get(fnName).__setOperator(fn)}else{let node=this.__node.graph.add({__node:{tag:fnName},__operator:fn})}return true}return false},setNode:function(fn,fnName){if(typeof fn==="string")fn=parseFunctionFromText(fn);if(typeof fn==="function"){if(!fnName)fnName=fn.name;if(this.__node.graph.get(fnName)){this.__node.graph.get(fnName).__setOperator(fn)}else this.__node.graph.add({__node:{tag:fnName},__operator:fn});return true}return false},setMethod:function(route,fn,fnName){if(typeof fn==="string")fn=parseFunctionFromText(fn);if(typeof fn==="function"){if(!fnName)fnName=fn.name;if(this.__node.graph.get(route)){this.__node.graph.get(route)[fnName]=fn}else this.__node.graph.add({__node:{tag:fnName,[fnName]:fn}});return true}return false},assignRoute:function(route,source){if(this.__node.graph.get(route)&&typeof source==="object"){Object.assign(this.__node.graph.get(route),source)}},transferClass:(classObj,className)=>{if(typeof classObj==="object"){let str2=classObj.toString();let message={route:"receiveClass",args:[str2,className]};return message}return false},receiveClass:function(stringified,className){if(typeof stringified==="string"){if(stringified.indexOf("class")===0){let cls=(0,eval)("("+stringified+")");let name=className;if(!name)name=cls.name;this.__node.graph[name]=cls;return true}}return false},setGlobal:(key,value)=>{globalThis[key]=value;return true},assignGlobalObject:(target,source)=>{if(!globalThis[target])return false;if(typeof source==="object")Object.assign(globalThis[target],source);return true},setValue:function(key,value){this.__node.graph[key]=value;return true},assignObject:function(target,source){if(!this.__node.graph[target])return false;if(typeof source==="object")Object.assign(this.__node.graph[target],source);return true},setGlobalFunction:(fn,fnName)=>{if(typeof fn==="string")fn=parseFunctionFromText(fn);if(typeof fn==="function"){if(!fnName)fnName=fn.name;globalThis[fnName]=fn;return true}return false},assignFunctionToGlobalObject:function(globalObjectName,fn,fnName){if(!globalThis[globalObjectName])return false;if(typeof fn==="string")fn=parseFunctionFromText(fn);if(typeof fn==="function"){if(!fnName)fnName=fn.name;this.__node.graph[globalObjectName][fnName]=fn;return true}return false},setFunction:function(fn,fnName){if(typeof fn==="string")fn=parseFunctionFromText(fn);if(typeof fn==="function"){if(!fnName)fnName=fn.name;this.__node.graph[fnName]=fn;return true}return false},assignFunctionToObject:function(objectName,fn,fnName){if(!this.__node.graph[objectName])return false;if(typeof fn==="string")fn=parseFunctionFromText(fn);if(typeof fn==="function"){if(!fnName)fnName=fn.name;this.__node.graph[objectName][fnName]=fn;return true}return false}};var algorithms={};var loadAlgorithms=settings=>{return Object.assign(algorithms,settings)};function createSubprocess(options,inputs){let ctx={_id:options._id?options._id:`algorithm${Math.floor(Math.random()*1e15)}`,ondata:options.ondata,run:data=>{return ctx.ondata(ctx,data)}};if(options.structs)recursivelyAssign3(ctx,JSON.parse(JSON.stringify(options.structs)));if(inputs)recursivelyAssign3(ctx,JSON.parse(JSON.stringify(inputs)));if(options.oncreate){ctx.oncreate=options.oncreate}if(ctx.oncreate){ctx.oncreate(ctx)}return ctx}var recursivelyAssign3=(target,obj)=>{for(const key in obj){if(typeof obj[key]==="object"&&!Array.isArray(obj[key])){if(typeof target[key]==="object"&&!Array.isArray(target[key]))recursivelyAssign3(target[key],obj[key]);else target[key]=recursivelyAssign3({},obj[key])}else target[key]=obj[key]}return target};var subprocessRoutes={...unsafeRoutes,loadAlgorithms,"initSubprocesses":async function initSubprocesses(subprocesses,service){if(!service)service=this.__node.graph;if(!service)return void 0;for(const p in subprocesses){let s=subprocesses[p];if(!s.worker&&s.url)s.worker=service.addWorker({url:s.url});if(!s.worker)continue;let w2=s.worker;let wpId;wpId=service.establishMessageChannel(w2.worker,s.source?.worker);if(!s.source)s.source=service;if(typeof s.subprocess==="object"){const p2=s.subprocess;if(!p2.name)continue;if(typeof p2.oncreate==="function"){p2.oncreate=p2.oncreate.toString()}if(typeof p2.ondata==="function"){p2.ondata=p2.ondata.toString()}s.worker.post("addSubprocessTemplate",[p2.name,p2.structs,p2.oncreate,p2.ondata,p2.props]);s.subprocess=p2.name}if(s.init){let r=await w2.run(s.init,s.initArgs);s.otherArgs=r}if(s.otherArgs){w2.run("setValue",["otherArgsProxy",Array.isArray(s.otherArgs)?s.otherArgs:[s.otherArgs]])}if(s.pipeTo){w2.run("setValue",["routeProxy",s.route]);w2.run("setValue",["pipeRoute",s.pipeTo.route]);if(s.url&&!s.pipeTo.worker){let w22=service.addWorker({url:s.url});s.pipeTo.portId=service.establishMessageChannel(w2.worker,w22.worker);s.pipeTo.worker=w22}if(s.pipeTo.init){s.pipeTo.otherArgs=await s.pipeTo.worker.run(s.pipeTo.init,s.pipeTo.initArgs)}w2.run("setValue",["pipePort",s.pipeTo.portId]);if(s.pipeTo.otherArgs)w2.run("setValue",["otherPipeArgs",s.pipeTo.otherArgs]);service.transferFunction(w2,function pipeResults(data){let inp=data;if(this.__node.graph.otherArgsProxy)inp=[data,...this.__node.graph.otherArgsProxy];let r=this.__node.graph.run(this.__node.graph.routeProxy,inp);if(!s.blocking)return new Promise(res=>{if(r instanceof Promise){r.then(rr=>{if(rr!==void 0){let args=rr;if(this.__node.graph.otherPipeArgs)args=[rr,...this.__node.graph.otherPipeArgs];if(this.workers[this.__node.graph.pipePort]){s.blocking=true;this.workers[this.__node.graph.pipePort].run(this.__node.graph.pipeRoute,args).then(result=>{s.blocking=false;res(result)})}}})}else if(r!==void 0){let args=r;if(this.__node.graph.otherPipeArgs)args=[r,...this.__node.graph.otherPipeArgs];if(this.workers[this.__node.graph.pipePort]){s.blocking=true;this.workers[this.__node.graph.pipePort].run(this.__node.graph.pipeRoute,args).then(result=>{s.blocking=false;res(result)})}}});return void 0},s.route+"_pipeResults");s.route=s.route+"_pipeResults"}else{w2.run("setValue",["routeProxy",s.route]);service.transferFunction(w2,function routeProxy(data){let r;if(this.__node.graph.otherArgsProxy)r=this.__node.graph.nodes.get(this.__node.graph.routeProxy).__operator(data,...this.__node.graph.otherArgsProxy);else r=this.__node.graph.nodes.get(this.__node.graph.routeProxy).__operator(data);if(this.__node.graph.state.triggers[this.__node.graph.routeProxy]){if(r instanceof Promise){r.then(rr=>{this.setState({[this.__node.graph.routeProxy]:rr})})}else this.setState({[this.__node.graph.routeProxy]:r})}return r},s.route+"_routeProxy");s.route=s.route+"_routeProxy";if(!s.stopped)w2.run("subscribeToWorker",[s.subscribeRoute,wpId,s.route]).then(sub=>{s.sub=sub})}s.stop=async()=>{if(s.source&&typeof s.sub==="number"){s.source.unsubscribe(s.subscribeRoute,s.sub);return true}return void 0};s.start=async()=>{if(typeof s.sub!=="number")return w2.run("subscribeToWorker",[s.subscribeRoute,wpId,s.route,s.blocking]).then(sub=>{s.sub=sub})};s.setArgs=async args=>{if(Array.isArray(args))await w2.run("setValue",["otherArgsProxy",args]);else if(typeof args==="object"){for(const key in args){await w2.run("setValue",[key,args[key]])}}return true};s.terminate=()=>{w2.terminate();if(s.source?.worker&&typeof s.sub==="number"){s.source.post("unsubscribe",s.sub)}if(s.pipeTo?.worker){s.pipeTo.worker.terminate()}};if(s.callback)w2.subscribe(s.route,res=>{if(typeof s.callback==="string")this.__node.graph.run(s.callback,res);else s.callback(res)})}return subprocesses},"addSubprocessTemplate":function subprocesstempalte(name,structs,oncreate,ondata,props){if(typeof oncreate==="string")oncreate=parseFunctionFromText(oncreate);if(typeof ondata==="string")ondata=parseFunctionFromText(ondata);if(typeof ondata==="function"){algorithms[name]={ondata,oncreate:typeof oncreate==="function"?oncreate:null,structs};if(typeof props==="object")Object.assign(algorithms[name],props);return true}},"updateSubprocess":function updatesubprocess(structs,_id){if(!this.__node.graph.ALGORITHMS)this.__node.graph.ALGORITHMS={};if(!_id)_id=Object.keys(this.__node.graph.ALGORITHMS)[0];if(!_id)return;Object.assign(this.__node.graph.ALGORITHMS[_id],structs)},"createSubprocess":function creatsubprocess(options,inputs){if(!this.__node.graph.ALGORITHMS)this.__node.graph.ALGORITHMS={};if(typeof options==="string"){options=algorithms[options]}if(typeof options==="object"){if(typeof options.ondata==="string")options.ondata=parseFunctionFromText(options.ondata);let ctx;if(typeof options?.ondata==="function")ctx=createSubprocess(options,inputs);if(ctx)this.__node.graph.ALGORITHMS[ctx._id]=ctx;console.log(ctx,options);if(ctx)return ctx._id}return false},"runSubprocess":function runsubprocess(data,_id){if(!this.__node.graph.ALGORITHMS)this.__node.graph.ALGORITHMS={};if(!_id)_id=Object.keys(this.__node.graph.ALGORITHMS)[0];if(!_id)return;let res=this.__node.graph.ALGORITHMS[_id].run(data);if(res!==void 0){if(Array.isArray(res)){let pass=[];res.forEach(r=>{if(r!==void 0){pass.push(r);this.__node.graph.setState({[_id]:r})}});if(pass.length>0){return pass}}else{this.__node.graph.setState({[_id]:res});return res}}}};var __defProp2=Object.defineProperty;var __defNormalProp=(obj,key,value)=>key in obj?__defProp2(obj,key,{enumerable:true,configurable:true,writable:true,value}):obj[key]=value;var __publicField=(obj,key,value)=>{__defNormalProp(obj,typeof key!=="symbol"?key+"":key,value);return value};var _Math2=class{constructor(){}static genSineWave(freq=20,peakAmp=1,nSec=1,fs=512,freq2=0,peakAmp2=1){var sineWave=[];var t=[];var increment=1/fs;for(var ti=0;ti<nSec;ti+=increment){var amplitude=Math.sin(2*Math.PI*freq*ti)*peakAmp;amplitude+=Math.sin(2*Math.PI*freq2*ti)*peakAmp2;sineWave.push(amplitude);t.push(ti)}return[t,sineWave]}static getSineAmplitude(frequency=20,peakAmplitude=1,ti=0,tOffset=0){return Math.sin(this.TWO_PI*frequency*ti+tOffset)*peakAmplitude}static mean(arr){var sum=arr.reduce((prev,curr)=>curr+=prev);return sum/arr.length}static mode(arr){return arr.sort((a,b2)=>arr.filter(v2=>v2===a).length-arr.filter(v2=>v2===b2).length).pop()}static std(arr,mean=void 0){let avg=mean;if(!mean)avg=this.mean(arr);let summed=0;for(let i=0;i<arr.length;i++){let subbed=arr[i]-avg;summed+=subbed*subbed}return Math.sqrt(summed/arr.length)}static relError(actual=[],forecast=[],abs=true){if(actual.length!==forecast.length)throw new Error("Input arrays of same length!");let i=actual.length;let d2=new Array(actual.length);for(let j=0;j<i;j++){let dd=(actual[j]-forecast[j])/actual[j];if(abs)dd=Math.abs(dd);d2[j]=dd}return d2}static informationEntropy(probabilities=[]){let len=probabilities.length;let entropy=new Array(len);for(let i=0;i<len;i++){let ent=probabilities[i]*Math.log(probabilities[i]);if(isNaN(ent))ent=0;entropy[i]=ent}return entropy}static zscore(arr){let mean=this.mean(arr);let std=this.std(arr,mean);let z=new Array().length(arr.length);for(let i=0;i<arr.length;i++){z[i]=(arr[i]-mean)/std}return z}static variance(arr){var mean=this.mean(arr);return arr.reduce((a,b2)=>a+(b2-mean)**2,0)/arr.length}static dot(vec1,vec2){var dot=0;for(var i=0;i<vec1.length;i++){dot+=vec1[i]*vec2[i]}return dot}static cross3D(vec1,vec2){return[vec1[1]*vec2[2]-vec1[2]*vec2[1],vec1[2]*vec2[0]-vec1[0]*vec2[2],vec1[0]*vec2[1]-vec1[1]*vec2[0]]}static magnitude(vec){var sqrd=0;vec.forEach(c=>{sqrd+=c*c});return Math.sqrt(sqrd)}static distance(point1,point2){var dsqrd=0;point1.forEach((c,i)=>{dsqrd+=(point2[i]-c)*(point2[i]-c)});return Math.sqrt(dsqrd)}static midpoint(point1=[1,2,3],point2=[3,4,5]){return point1.map((c,i)=>{return(c+point2[i])*.5})}static normalize(vec){var norm=0;norm=this.magnitude(vec);var vecn=new Array(vec.length);vec.forEach((c,i)=>{vecn[i]=c*norm});return vecn}static normalizeSeries(arr=[],fromZero=true){let max=Math.max(...arr);let min=Math.min(...arr);if(fromZero==false){max=Math.max(max,Math.abs(min));min=0}if(max-min===0){min=0;if(max===0)max=1e-13}return arr.map(v2=>(v2-min)/(max-min))}static quadraticFormula(a,b2,c){let bbmac4=Math.sqrt(b2*b2-4*a*c);if(!isNaN(bbmac4))return["complex","complex"];let _a2=1/(2*a);if(bbmac4===0)return[b2*_a2];let nb=-b2;return[(nb+bbmac4)*_a2,(nb-bbmac4)*_a2]}static newtonsMethod(foo=x22=>{return Math.pow(x22,5)+x22*x22-x22-.2},start=0,end=1,precision=.01,attempts=10){let roots=[];for(let i=0;i<attempts;i++){let seedx=Math.random()*(end-start);let guess=foo(seedx);let guess2=foo(seedx+precision);let slope=(guess2-guess)/precision;let xn=seedx+precision;while(Math.abs(slope)>precision){let step=-guess/slope2;let xn12=xn+step;guess=guess2;guess2=foo(xn12);let slope2=(guess2-guess)/(xn12-xn)}let idx;let f=roots.find((root,i2)=>{if(Math.abs(xn1-root)<precision){idx=i2;return true}});if(f)roots[idx]=(xn1+f)*.5;else roots.push(xn1)}return roots}static makeVec(point1,point2){var vec=[];point1.forEach((c,i)=>{vec.push(point2[i]-c)});return vec}static getBufferedValueByCoordinates(vb=new Array(300).fill(1),dims=[10,10,2],coordinate=[1,2,1],cardinal=void 0){let getIdx=(foundIdx=0,dimIdx=0)=>{if(dimIdx===dims.length)return foundIdx;if(dimIdx==0)foundIdx+=coordinate[dimIdx];else if(dims[dimIdx]==0)dimsAt0++;else{let reMul=(val=coordinate[dimIdx],di=dimIdx-1)=>{val*=dims[di];di--;if(di==0)return val;else return reMul(val,di)};foundIdx+=reMul(coordinate[dimIdx]+1,dimIdx-1)}dimIdx++;return getIdx(foundIdx,dimIdx)};let found=getIdx();if(cardinal){if(coordinate[coordinate.length-1]===0){let lastnonzero=0;let idx=0;while(idx!==coordinate.length-1){if(coordinate[idx]!==0)lastnonzero=idx;idx++}return vb[found-lastnonzero+cardinal]}return vb[found-dims.length+cardinal]}else{if(coordinate[coordinate.length-1]===0){let lastnonzero=0;let idx=0;while(idx!==coordinate.length-1){if(coordinate[idx]!==0)lastnonzero=idx;idx++}return vb.slice(found-lastnonzero,found+1)}return vb.slice(found-dims.length,found+1)}}static forBufferedMat(vb=new Array(100).fill(1),dims=[10,10],asIndex=(v2,i,x22,y2)=>{return v2+x22+y2}){let coordinate=[];let idx=0;let recurseFor=(depth=0,nextDepth=depth+1)=>{let result=new Array(vb.length);for(let di=0;di<dims[depth];di++){coordinate[depth]=di;if(dims[nextDepth])recurseFor(nextDepth);else{result[idx]=asIndex(vb[idx],idx,...coordinate);idx++}}return result};let recurseForArrFuncs=(depth,nextDepth=depth+1)=>{let result=new Array(vb.length);for(let di=0;di<dims[depth];di++){coordinate[depth]=di;if(dims[nextDepth])recurseFor(nextDepth);else{for(let dj=0;dj<dims.length;dj++){result[idx]=asIndex[dj](vb[idx],idx,...coordinate);idx++}}}return result};if(typeof asIndex==="function"){return recurseFor()}else if(Array.isArray(asIndex)){return recurseForArrFuncs()}}static mapBufferedMat(buffer=new Array(100).fill(1),dimensions=[10,10],asIndex=(v2,idx,i,j)=>{console.log(`value:${v2}, idx:${idx}, x:${i},y:${j}`);return v2+i+j}){let coordinate=new Array(dimensions.length).fill(0);const iterateCoordinate=(coord,idx=0)=>{if(coord[idx]>=dimensions[idx]){coord[idx]=0;idx++;if(idx===dimensions.length)return;iterateCoordinate(coord,idx)}else coord[idx]++};let result=new Array(buffer.length);let i=0;if(typeof asIndex==="function"){while(i<buffer.length){result[i]=asIndex(buffer[i],i,...coordinate);i+=dimensions.length;iterateCoordinate(coordinate)}}else if(Array.isArray(asIndex)){while(i<buffer.length){asIndex.forEach(func=>{result[i]=func(buffer[i],i,...coordinate);i++;iterateCoordinate(coordinate)})}}return result}static combinations(choices=["a","b","c"],vecsize=3){var result=[];if(vecsize<=0){result.push([])}else{_Math2.combinations(choices,vecsize-1).forEach(function(previousComb){choices.forEach(function(element){result.push([element].concat(previousComb))})})}return result}static generateCoordinateSpace(upperBounds=[10,10,10],lowerBounds=[-10,-10,-10],steps=[1,1,1],mutater=void 0){for(let i=0;i<upperBounds.length;i++){if(lowerBounds[i]>upperBounds[i]){let temp=upperBounds[i];upperBounds[i]=lowerBounds[i];lowerBounds[i]=temp}}let result=[];let copy=[...upperBounds];let lastindex=copy.length-1;result.push([...copy]);while(copy[0]>=lowerBounds[0]){let checkNextIndex=decrIdx2=>{if(copy[decrIdx2]<=lowerBounds[decrIdx2]){if(decrIdx2===0)return;copy[decrIdx2]=upperBounds[decrIdx2];decrIdx2--;if(decrIdx2<0)return;if(typeof steps[decrIdx2]=="function")copy[decrIdx2]-=steps[decrIdx2](copy[decrIdx2]);else copy[decrIdx2]-=steps[decrIdx2];checkNextIndex(decrIdx2)}};let decrIdx=lastindex;if(typeof steps[decrIdx]=="function")copy[decrIdx]-=steps[decrIdx](copy[decrIdx]);else copy[decrIdx]-=steps[decrIdx];result.push([...copy]);checkNextIndex(decrIdx);if(mutater)result[result.length-1]=mutater(result[result.length-1])}return result}static calcVectorField(coordinates=[[0,0],[0,1],[1,0],[1,1]],formula=(x22,y2)=>{return[x22*10,y2*10]}){return coordinates.map(vec=>formula(...vec))}static transpose(mat){return mat[0].map((_2,colIndex)=>mat.map(row=>row[colIndex]))}static matmul(a,b2){var aNumRows=a.length,aNumCols=a[0].length,bNumRows=b2.length,bNumCols=b2[0].length,m=new Array(aNumRows);for(var r=0;r<aNumRows;++r){m[r]=new Array(bNumCols);for(var c=0;c<bNumCols;++c){m[r][c]=0;for(var i=0;i<aNumCols;++i){m[r][c]+=a[r][i]*b2[i][c]}}}return m}static matscale(mat,scalar){let m=[];for(var i=0;i<mat.length;i++){m[i]=[];for(let j=0;j<mat[0].length;j++){m[i][j]=mat[i][j]*scalar}}return m}static matadd(a,b2){let m=[];for(let i=0;i<a.length;i++){m[i]=[];for(var j=0;j<a[0].length;j++){m[i][j]=a[i][j]+b2[i][j]}}return m}static matsub(a,b2){let m=[];for(let i=0;i<a.length;i++){m[i]=[];for(var j=0;j<a[0].length;j++){m[i][j]=a[i][j]-b2[i][j]}}return m}static histogram(arr=[],binSize=1,nBins=void 0){let copy=[...arr];copy.sort(function(a,b2){return a-b2});let binStart=Math.min(...copy);if(typeof nBins==="number"){let binEnd=Math.max(...copy);binSize=Math.abs((binEnd-binStart)/(nBins-1))}let j=binStart;let binx=[];let biny=[];for(let i=0;i<copy.length;i++){let binidx=binSize*j;if(copy[i]>binStart+binidx){j++;binidx+=binSize;let binmin=binStart+binidx;let binmid=binmin+binidx*.5;binx.push(binmid);biny.push(0)}biny[biny.length-1]++}return[binx,biny]}static normalDistribution(samples=[],normalize=true,cutoff=1e-4){let m=this.mean(samples);let vari=this.variance(samples);let nSamples=samples.length;let probabilities=[];let denom=1/(this.TWO_PI*vari);let _variance=1/vari;let sum=0;for(let i=0;i<nSamples;i++){let px=Math.exp(-.5*Math.pow((samples[i]-m)*_variance,2))*denom;if(px<cutoff)px=0;probabilities.push(px);sum+=px}if(normalize){let _sum=1/sum;probabilities=probabilities.map(x22=>x22*_sum)}return probabilities}static expectedValue(samples=[],probabilities=this.normalDistribution(samples)){return samples.reduce((sum,item,idx)=>sum+item*probabilities[idx])}static originMoment(samples=[],probabilities=this.normalDistribution(samples),order=1){return samples.reduce((sum,item,idx)=>sum+Math.pow(item,order)*probabilities[idx])}static centralMoment(samples=[],probabilities=this.normalDistribution(samples),order=1){let m=this.mean(samples);return samples.reduce((sum,item,idx)=>sum+Math.pow(item-m,order)*probabilities[idx]/samples.length)}static linearDiscriminantAnalysis(samples=[],classifier=[]){let mean=this.mean(samples);let meank=this.mean(classifier);let covariance=this.cov1d(samples,classifier);let probs=this.normalDistribution(samples);let dk=[];for(let i=0;i<samples.length;i++){dk.push(x[i]*covariance*meank-.5*mean*covariance*meank+Math.log10(probs[i]))}return dk}static conv1D(arr=[],kern=[1/3,1/3,1/3],pad=Math.floor(kern.length*.5)){let result=[];let _n=1/kern.length;if(pad>0){let pads=new Array(pad).fill(0);arr=[...pads,...arr,...pads]}let start=Math.floor(kern.length*.5);let end=arr.length-kern.length+start;for(let i=start;i<end;i++){let acc=0;for(let j=0;j<kern.length;j++){acc+=arr[i-start]*kern[j]}result.push(acc*_n)}return result}static conv2D(mat=[[],[],[]],kern=[[],[],[]],pad=0){let result=new Array(mat.length-Math.ceil(kern.length*.5)).fill([]);let mat_t;let kern_t=_Math2.transpose(kern_t);if(pad>0){let pads=new Array(pad).fill(0);mat_t=_Math2.transpose(mat);for(let i2=0;i2<mat_t.length;i2++){mat_t[i2]=[...pads,...mat_t[i2],...pads]}mat=_Math2.transpose(mat_t);for(let j=0;j<mat.length;j++){mat[j]=[...pads,...mat[j],...pads]}}let startr=Math.floor(kern[0].length*.5);let startl=Math.floor(kern_t[0].length*.5);let endr=mat[0].length-kern[0].length+startr;let endl=mat_t[0].length-kern_t[0].length+startl;let _n=1/(kern[0].length*kern_t[0].length);let iters=endr*endl;let i=startr;let x22;let y2=startl;while(i<iters){let acc=0;x22=i%mat[0].length;if(x22===0){y2++}for(let j=0;j<kern[0].length;j++){for(let k=0;k<kern_t[0].length;j++){acc+=mat[y2-startl+k][x22-startr+j]*kern[k][j]}result[y2].push(acc*_n)}i++}return result}static cov2d(mat){var mattransposed=this.transpose(mat);var matproducts=[];var rowmeans=[];var colmeans=[];mat.forEach((row,idx)=>{rowmeans.push(this.mean(row))});mattransposed.forEach((col,idx)=>{colmeans.push(this.mean(col))});mat.forEach((row,idx)=>{matproducts.push([]);for(var col=0;col<row.length;col++){matproducts[idx].push((mat[idx][col]-rowmeans[idx])*(mat[idx][col]-colmeans[col])/(row.length-1))}});var matproductstransposed=this.transpose(matproducts);var aNumRows=matproducts.length,aNumCols=matproducts[0].length,bNumRows=matproductstransposed.length,bNumCols=matproductstransposed[0].length,m=new Array(aNumRows);for(var r=0;r<aNumRows;++r){m[r]=new Array(bNumCols);for(var c=0;c<bNumCols;++c){m[r][c]=0;for(var i=0;i<aNumCols;++i){m[r][c]+=matproducts[r][i]*matproductstransposed[i][c]/(mat[0].length-1)}}}return m}static cov1d(arr1=[],arr2=[]){return this.cov2d([arr1,arr2])}static cov3d(x22=[],y2=[],z=[]){return[[this.cov1d(x22,x22),this.cov1d(x22,y2),this.cov1d(x22,z)],[this.cov1d(y2,x22),this.cov1d(y2,y2),this.cov1d(y2,z)],[this.cov1d(z,x22),this.cov1d(z,y2),this.cov1d(z,z)]]}static covNd(dimensionalData=[]){let covariance=[];dimensionalData.forEach((arr,i)=>{covariance.push([]);dimensionalData.forEach((arr2,j)=>{covariance[i].push(this.cov1d(arr,arr2))})})}static eigens2x2(mat=[[1,2],[3,4]]){let det=mat[0][0]*mat[1][1]-mat[0][1]*mat[1][0];let mean=(mat[0][0]+mat[1][1])*.5;let sqrt=Math.sqrt(mean*mean-det);let eig1=mean+sqrt;let eig2=mean-sqrt;return[eig1,eig2]}static eigenvectors2x2(mat=[[1,2],[3,4]],eigens=[1,2]){let v1=[-mat[0][1],mat[0][0]-eigens[0]];if(v1[0]===0&&v1[1]===0){v1[0]=mat[1][1]-eigens[0];v1[1]=-mat[1][0]}let v2=[-mat[0][1],mat[0][0]-eigens[1]];if(v2[0]===0&&v2[1]===0){v2[0]=mat[1][1]-eigens[1];v2[1]=-mat[1][0]}return[v1,v2]}static fastpca2d(xarr,yarr){let cov1d=this.cov1d(xarr,yarr);let eigs=this.eigens2x2(cov1d);if(eigs[1]>eigs[0])eigs.reverse();let evs=this.eigenvectors2x2(cov1d,eigs);console.log(eigs,evs);return[eigs,evs]}static crosscorrelation(arr1,arr2){var arr2buf=[...arr2,...Array(arr2.length).fill(0)];var mean1=this.mean(arr1);var mean2=this.mean(arr2);var arr1Est=arr1.reduce((sum,item)=>sum+=Math.pow(item-mean1,2));arr1Est=Math.sqrt(Math.abs(arr1Est));var arr2Est2=arr2.reduce((sum,item)=>sum+=Math.pow(item-mean1,2));arr2Est2=Math.sqrt(Math.abs(arr2Est2));let denom=arr1Est*arr2Est2;if(denom===0)denom=1e-26;var _arrEstsMul=1/denom;var correlations=new Array(arr1.length).fill(0);for(var delay=0;delay<arr1.length;delay++){var r=arr1.reduce((sum,item,i)=>sum+=(item-mean1)*(arr2buf[delay+i]-mean2));correlations[delay]=r*_arrEstsMul}return correlations}static autocorrelation(arr1){var delaybuf=[...arr1,...Array(arr1.length).fill(0)];var mean1=this.mean(arr1);var arr1Est=arr1.reduce((sum,item)=>sum+=Math.pow(item-mean1,2));arr1Est=Math.sqrt(Math.abs(arr1Est));let denom=arr1Est*arr2Est;if(denom===0)denom=1e-26;var _arr1estsqrd=1/denom;var correlations=new Array(arr1.length).fill(0);for(var delay=0;delay<arr1.length;delay++){var r=arr1.reduce((sum,item,i)=>sum+=(item-mean1)*(delaybuf[delay+i]-mean1));correlations[delay]=r*_arr1estsqrd}return correlations}static autocorrelation2dNormalized(mat2d2){let result=[];for(let y2=0;y2<mat2d2.length;y2++){result.push([]);for(let x22=0;x22<mat2d2[y2].length;x22++){let G=0;let _G=0;for(let b2=0;b2<mat2d2.length;b2++){for(let a=0;a<mat2d2[b2].length;a++){G+=mat2d2[y2][x22]*mat2d2[mat2d2.length-1-b2][mat2d2[y2].length-1-a];_G+=mat2d2[y2][x22]*mat2d2[mat2d2.length-1][mat2d2[y2].length-1]}}result[y2][x22]=G/_G-1}}return result}static crosscorrelation2d(mat2d1,mat2d2){let result=[];for(let y2=0;y2<mat2d1.length;y2++){result.push([]);for(let x22=0;x22<mat2d1[y2].length;x22++){let G=0;for(let b2=0;b2<mat2d2.length;b2++){for(let a=0;a<mat2d2[b2].length;a++){G+=mat2d1[y2][x22]*mat2d2[mat2d2.length-1-b2][mat2d2[y2].length-1-a]}}result[y2][x22]=G}}return result}static crosscorrelation2dNormalized(mat2d1,mat2d2){let result=[];for(let y2=0;y2<mat2d1.length;y2++){result.push([]);for(let x22=0;x22<mat2d1[y2].length;x22++){let G=0;let _G=0;for(let b2=0;b2<mat2d2.length;b2++){for(let a=0;a<mat2d2[b2].length;a++){G+=mat2d1[y2][x22]*mat2d2[mat2d.length-1-b2][mat2d2[y2].length-1-a];_G+=mat2d1[y2][x22]*mat2d2[mat2d2.length-1][mat2d2[y2].length-1]}}result[y2][x22]=G/_G-1}}return result}static correlograms(dat=[[],[]]){var correlograms=[];dat.forEach((row1,i)=>{dat.forEach((row2,j)=>{if(j>=i){correlograms.push(_Math2.crosscorrelation(row1,row2))}})});return correlograms}static dft(sineWave=[]){var TWOPI=2*3.141592653589793;var real=[];var imag=[];var mags=[];for(var k=0;k<sineWave.length;k++){real.push(0);imag.push(0);for(var j=0;j<sineWave.length;j++){var shared=TWOPI*k*j/sineWave.length;real[k]=real[k]+sineWave[j]*Math.cos(shared);imag[k]=imag[k]-sineWave[j]*Math.sin(shared)}mags.push(Math.sqrt(real[k]*real[k]+imag[k]*imag[k]))}function orderMagnitudes(unorderedMags){return[...unorderedMags.slice(Math.ceil(unorderedMags.length*.5),unorderedMags.length),...unorderedMags.slice(0,Math.ceil(unorderedMags.length*.5))]}mags=orderMagnitudes(mags);let halflen=mags.length*.5;let freqs=mags.map((m,i)=>{return i-halflen});return{real,imag,freqs,mags}}static sma(arr=[],window){var smaArr=[];for(var i=0;i<arr.length;i++){if(i==0){smaArr.push(arr[0])}else if(i<window){var arrslice=arr.slice(0,i+1);smaArr.push(arrslice.reduce((previous,current)=>current+=previous)/(i+1))}else{var arrslice=arr.slice(i-window,i);smaArr.push(arrslice.reduce((previous,current)=>current+=previous)/window)}}return smaArr}static sum(arr=[]){if(arr.length>0){var sum=arr.reduce((prev,curr)=>curr+=prev);return sum}else{return 0}}static reduceArrByFactor(arr,factor=2){let x22=arr.filter((element,index)=>{return index%factor===0});return x22}static makeArr(startValue,stopValue,nSteps){var arr=[];var step=(stopValue-startValue)/(nSteps-1);for(var i=0;i<nSteps;i++){arr.push(startValue+step*i)}return arr}static autoscale(array,stackedLines=1,stackPosition=0,centerZero=false){if(array?.length===0)return array;let max=Math.max(...array);let min=Math.min(...array);let _lines=1/stackedLines;let scalar;if(centerZero){let absmax=Math.max(Math.abs(min),Math.abs(max));scalar=_lines/absmax;return array.map(y2=>y2*scalar+(_lines*(stackPosition+1)*2-1-_lines))}else{scalar=_lines/(max-min);return array.map(y2=>2*((y2-min)*scalar-1/(2*stackedLines))+(_lines*(stackPosition+1)*2-1-_lines))}}static absmax(array){return Math.max(Math.abs(Math.min(...array)),Math.max(...array))}static downsample(array,fitCount,scalar=1){if(array.length>fitCount){let output=new Array(fitCount);let incr=array.length/fitCount;let lastIdx=array.length-1;let last=0;let counter=0;for(let i=incr;i<array.length;i+=incr){let rounded=Math.round(i);if(rounded>lastIdx)rounded=lastIdx;for(let j=last;j<rounded;j++){output[counter]+=array[j]}output[counter]/=(rounded-last)*scalar;counter++;last=rounded}return output}else return array}static interpolateArray(data,fitCount,scalar=1){var linearInterpolate=function(before2,after2,atPoint2){return(before2+(after2-before2)*atPoint2)*scalar};var newData=new Array;var springFactor=(data.length-1)/(fitCount-1);newData[0]=data[0];for(var i=1;i<fitCount-1;i++){var tmp=i*springFactor;var before=Math.floor(tmp);var after=Math.ceil(tmp);var atPoint=tmp-before;newData[i]=linearInterpolate(data[before],data[after],atPoint)}newData[fitCount-1]=data[data.length-1];return newData}static isExtrema(arr,critical="peak"){let ref=[...arr];if(ref.length%2===0)ref.pop();if(arr.length>1){let pass=true;for(let i=0;i<ref.length;i++){let val=ref[i];if(critical==="peak"){if(i<Math.floor(ref.length*.5)&&val>=ref[Math.floor(ref.length*.5)]){pass=false;break}else if(i>Math.floor(ref.length*.5)&&val>=ref[Math.floor(ref.length*.5)]){pass=false;break}}else if(critical==="valley"){if(i<Math.floor(ref.length*.5)&&val<=ref[Math.floor(ref.length*.5)]){pass=false;break}else if(i>Math.floor(ref.length*.5)&&val<=ref[Math.floor(ref.length*.5)]){pass=false;break}}else{if(i<Math.floor(ref.length*.5)&&val<=ref[Math.floor(ref.length*.5)]){pass=false;break}else if(i>Math.floor(ref.length*.5)&&val<=ref[Math.floor(ref.length*.5)]){pass=false;break}}}if(critical!=="peak"&&critical!=="valley"&&pass===false){pass=true;for(let i=0;i<ref.length;i++){let val=ref[i];if(i<Math.floor(ref.length*.5)&&val>=ref[Math.floor(ref.length*.5)]){pass=false;break}else if(i>Math.floor(ref.length*.5)&&val>=ref[Math.floor(ref.length*.5)]){pass=false;break}}}return pass}else return void 0}static isCriticalPoint(arr,critical="peak"){let ref=[...arr];if(ref.length%2===0)ref.pop();if(arr.length>1){let pass=true;for(let i=0;i<ref.length;i++){let val=ref[i];if(critical==="peak"){if(i<ref.length*.5&&val<=0){pass=false;break}else if(i>ref.length*.5&&val>0){pass=false;break}}else if(critical==="valley"){if(i<ref.length*.5&&val>=0){pass=false;break}else if(i>ref.length*.5&&val<0){pass=false;break}}else{if(i<ref.length*.5&&val>=0){pass=false;break}else if(i>ref.length*.5&&val<0){pass=false;break}}}if(critical!=="peak"&&critical!=="valley"&&pass===false){pass=true;for(let i=0;i<ref.length;i++){let val=ref[i];if(i<ref.length*.5&&val<=0){pass=false;break}else if(i>ref.length*.5&&val>0){pass=false;break}}}return pass}else return void 0}static getPeakThreshold(arr,peakIndices,thresholdVar){let threshold;let filtered=arr.filter((o,i)=>{if(peakIndices.indexOf(i)>-1)return true});if(thresholdVar===0){threshold=this.mean(filtered)}else threshold=(thresholdVar+this.mean(filtered))*.5;return threshold}static column(mat,x22){let col=new Array(mat.length).fill(0).map(()=>new Array(1).fill(0));for(let i=0;i<mat.length;i++){col[i][0]=mat[i][x22]}return col}static flatten_vector(v2){let v_new=[];for(let i=0;i<v2.length;i++){v_new[i]=v2[i][0]}return v_new}static squared_difference(v1,v2){let sum=0;for(let i=0;i<v1.length;i++){sum=sum+Math.pow(v1[i]-v2[i],2)}return sum}static shift_deflate(mat,eigenvalue,eigenvector){let len=Math.sqrt(this.matmul(this.transpose(eigenvector),eigenvector));let U=this.matscale(eigenvector,1/len);let delta=this.matscale(this.matmul(U,this.transpose(U)),eigenvalue);let M_new=this.matsub(mat,delta);return M_new}static eigenvalue_of_vector(mat,eigenvector){ev=this.matmul(this.matmul(this.transpose(eigenvector),mat),eigenvector);return ev}static power_iteration(mat,tolerance=1e-5,max_iterations=1e3){let rank=mat.length;let eigenvector=new Array(rank).fill(0).map(()=>new Array(1).fill(Math.sqrt(rank)));let eigenvalue=this.eigenvalue_of_vector(mat,eigenvector);let epsilon=1;let iter=0;while(epsilon>tolerance&&iter<max_iterations){let old_eigenvalue=JSON.parse(JSON.stringify(eigenvalue));let Mv=this.matmul(mat,eigenvector);eigenvector=this.normalize(Mv);eigenvalue=this.eigenvalue_of_vector(mat,eigenvector);epsilon=Math.abs(eigenvalue-old_eigenvalue);iter++};return[eigenvalue,eigenvector]}static eigens(mat,tolerance=1e-4,max_iterations=1e3){let eigenvalues=[];let eigenvectors=[];for(let i=0;i<mat.length;i++){let result=this.power_iteration(mat,tolerance,max_iterations);let eigenvalue=result[0];let eigenvector=result[1];eigenvalues[i]=eigenvalue;eigenvectors[i]=this.flatten_vector(eigenvector);mat=this.shift_deflate(mat,eigenvalue,eigenvector)}return[eigenvalues,eigenvectors]}static pca(mat,tolerance=1e-5){let dims=mat.length;let t=new Array(dims);let p=new Array(dims);let mat_t=this.transpose(mat);t[0]=this.column(mat,0);let epsilon=1;let iter=0;while(espilon>tolerance){iter++;p[0]=this.matmul(mat_t,t[0]);let tp=this.matmul(this.transpose(t[0]),t[0]);p[0]=this.matscale(p[0],1/tp);let p_length=Math.sqrt(this.matmul(this.transpose(p[0]),p[0]));p[0]=this.matscale(p[0],1/p_length);let t_new=this.matmul(mat,p[0]);let pp=this.matmul(this.transpose(p[0]),p[0]);t_new=this.matscale(t_new,1/pp);epsilon=this.squared_difference(t[0],t_new);t[0]=JSON.parse(JSON.stringify(t_new))}let components=this.matmul(this.transpose(t[0]),t[0]);return components}static circularBuffer(arr,newEntries){if(Array.isArray(newEntries)){if(newEntries.length<arr.length){let slice=arr.slice(newEntries.length);let len=arr.length;arr.splice(0,len,...slice,...newEntries)}else if(newEntries.length>arr.length){let len=arr.length;arr.splice(0,len,newEntries.slice(len-newEntries.length))}else{arr.splice(0,arr.length,...newEntries)}}else{arr.push(newEntries);arr.shift()}return arr}static HSLToRGB(h,s,l,scalar=255){s/=100;l/=100;let c=(1-Math.abs(2*l-1))*s,x22=c*(1-Math.abs(h/60%2-1)),m=l-c/2,r=0,g=0,b2=0;if(0<=h&&h<60){r=c;g=x22;b2=0}else if(60<=h&&h<120){r=x22;g=c;b2=0}else if(120<=h&&h<180){r=0;g=c;b2=x22}else if(180<=h&&h<240){r=0;g=x22;b2=c}else if(240<=h&&h<300){r=x22;g=0;b2=c}else if(300<=h&&h<360){r=c;g=0;b2=x22}r=(r+m)*scalar;g=(g+m)*scalar;b2=(b2+m)*scalar;return[r,g,b2]}static p300(event_timestamps=[],raw_signal=[],signal_timestamps=[],sps=256){let smoothingstep=Math.floor(sps/10);let smoothed=this.sma(raw_signal,smoothingstep);let peaks=this.peakDetect(smoothed,"peak",smoothingstep);let mean=this.mean(smoothed);let std=this.std(smoothed,mean);let p_idx=0;let candidates=[];if(peaks.length>0){event_timestamps.forEach((t,j)=>{while(signal_timestamps[peaks[p_idx]]<t+200){p_idx++;if(!peaks[p_idx])break}let tempi=0;let tempcandidates=[];while(signal_timestamps[peaks[p_idx+tempi]]<t+600){tempcandidates.push(p_idx+tempi);tempi++;if(!peaks[p_idx+tempi])break}if(tempcandidates.length>1){let peakvals=[];tempcandidates.forEach(tc=>{peakvals.push(smoothed[peaks[tc]])});let max=Math.max(...peakvals);let maxi=tempcandidates[peakvals.indexOf(max)];candidates.push({event_timestamp:t,event_index:j,peak_timestamp:signal_timestamps[[peaks[maxi]]],signal_index:[peaks[maxi]],signal_amplitude:raw_signal[[peaks[maxi]]],zscore:(smoothed[peaks[maxi]]-mean)/std})}else if(tempcandidates.length===1)candidates.push({event_timestamp:t,event_index:j,peak_timestamp:signal_timestamps[peaks[tempcandidates[0]]],signal_index:peaks[tempcandidates[0]],signal_amplitude:raw_signal[[peaks[tempcandidates[0]]]],zscore:(smoothed[peaks[tempcandidates[0]]]-mean)/std})})}return candidates}};var Math2=_Math2;__publicField(Math2,"TWO_PI",Math.PI*2);__publicField(Math2,"C",299792458);__publicField(Math2,"G",66743e-15);__publicField(Math2,"h",662607015e-42);__publicField(Math2,"R",8314.32);__publicField(Math2,"Ra",287);__publicField(Math2,"H",69.3);__publicField(Math2,"kbar",1054571817e-43);__publicField(Math2,"kB",1380649e-29);__publicField(Math2,"ke",89875517923e-1);__publicField(Math2,"me",91093837015e-41);__publicField(Math2,"mp",167262192369e-38);__publicField(Math2,"mn",167492749804e-38);__publicField(Math2,"P0",101325);__publicField(Math2,"T0",288.15);__publicField(Math2,"p0",1.225);__publicField(Math2,"Na",60220978e16);__publicField(Math2,"y",1.405);__publicField(Math2,"M0",28.96643);__publicField(Math2,"g0",9.80665);__publicField(Math2,"Re",6378100);__publicField(Math2,"B",1458e-9);__publicField(Math2,"S",110.4);__publicField(Math2,"Sigma",365e-12);__publicField(Math2,"imgkernels",{edgeDetection:[[-1,-1,-1],[-1,8,-1],[-1,-1,-1]],boxBlur:[[1/9,1/9,1/9],[1/9,1/9,1/9],[1/9,1/9,1/9]],sobelLeft:[[1,0,-1],[2,0,-2],[1,0,-1]],sobelRight:[[-1,0,1],[-2,0,2],[-1,0,1]],sobelTop:[[1,2,1],[0,0,0],[-1,-2,-1]],sobelBottom:[[-1,2,1],[0,0,0],[1,2,1]],identity:[[0,0,0],[0,1,0],[0,0,0]],gaussian3x3:[[1,2,1],[2,4,2],[1,2,1]],guassian7x7:[[0,0,0,5,0,0,0],[0,5,18,32,18,5,0],[0,18,64,100,64,18,0],[5,32,100,100,100,32,5],[0,18,64,100,64,18,0],[0,5,18,32,18,5,0],[0,0,0,5,0,0,0]],emboss:[[-2,-1,0],[-1,1,1],[0,1,2]],sharpen:[[0,-1,0],[-1,5,-1],[0,-1,0]]});__publicField(Math2,"integral",(func=x22=>{let y2=x22;return y2},range=[],stepx=.01)=>{let area=0;for(let i=range[0];i<range[1];i+=stepx){let y2=func(i);area+=y2*stepx}return area});__publicField(Math2,"dintegral",(func=(x22,y2)=>{let z=x22+y2;return z},range=[[],[]],stepx=.01,stepy=stepx)=>{let volume=0;for(let i=range[0][0]+stepx;i<range[0][1];i+=stepx){for(let j=range[1][0]+stepy;j<range[1][1];j+=stepy){let z=func(i,j);volume+=z*stepx*stepy}}return volume});__publicField(Math2,"tintegral",(func=(x22,y2,z)=>{let w2=x22+y2+z;return w2},range=[[],[],[]],stepx=.01,stepy=stepx,stepz=stepx)=>{let volume=0;for(let i=range[0][0]+stepx;i<range[0][1];i+=stepx){for(let j=range[1][0]+stepy;j<range[1][1];j+=stepy){for(let k=range[2][0]+stepz;k<range[2][1];k+=stepz){let w2=func(i,j,k);volume+=w2*stepx*stepy*stepz}}}return volume});__publicField(Math2,"pintegral",(func=x22=>{let y2=x22;return y2},range=[],stepx=.01)=>{let length=0;let y0=void 0;let yi=void 0;for(let i=range[0];i<range[1];i+=stepx){y0=yi;yi=func(i);if(y0)length+=_Math2.distance([0,y0],[stepx,yi])}return length});__publicField(Math2,"meshgrid",_Math2.generateCoordinateSpace);__publicField(Math2,"autocorrelation2d",mat2d2=>{let result=[];for(let y2=0;y2<mat2d2.length;y2++){result.push([]);for(let x22=0;x22<mat2d2[y2].length;x22++){let G=0;for(let b2=0;b2<mat2d2.length;b2++){for(let a=0;a<mat2d2[b2].length;a++){G+=mat2d2[y2][x22]*mat2d2[mat2d2.length-1-b2][mat2d2[y2].length-1-a]}}result[y2][x22]=G}}return result});__publicField(Math2,"lerp",_Math2.makeArr);__publicField(Math2,"upsample",_Math2.interpolateArray);__publicField(Math2,"lerp",(v0,v1,fit,floor=true)=>{function lerp(v02,v12,t){return(1-t)*v02+t*v12}function interpolerp(v02,v12,fit2,floor2=true){if(fit2<=2)return[v02,v12];let a=1/fit2;let result=new Array(fit2);result[0]=v02;for(let i=1;i<=fit2;i++){result[i]=lerp(v02,v12,a*i);if(floor2)result[i]=Math.floor(result[i])}return result}});__publicField(Math2,"peakDetect",(smoothedArray,type="peak",window=49)=>{let mid=Math.floor(window*.5);let peaks=[];for(let i=0;i<smoothedArray.length-window;i++){let isPeak=_Math2.isExtrema(smoothedArray.slice(i,i+window),type);if(isPeak){peaks.push(i+mid-1)}}return peaks});Object.assign(Math,Math2);var accel_gyro={structs:{accelConstant:1/8192,gyroConstant:1/65.5,gyroXAngle:0,gyroYAngle:0,gyroZAngle:0,px:0,py:0,pz:0,sps:100,lastAccelTime:Date.now(),lastGyroTime:Date.now()},ondata:(ctx,data)=>{if(!("ax"in data)&&!("gx"in data))return void 0;if(!data.timestamp){if(data.ax&&Array.isArray(data.ax)||data.gx&&Array.isArray(data.gx)){let len=data.ax?data.ax.length:data.gx.length;let now=Date.now();let toInterp=[now-len*ctx.sps*1e3,now];data.timestamp=Math2.upsample(toInterp,len)}else{data.timestamp=Date.now()}}let result;if(data.ax){let apass=(timestamp,ax,ay,az)=>{ax=ax*ctx.accelConstant;ay=ay*ctx.accelConstant;az=az*ctx.accelConstant;const accelXAngle=Math.atan(ay/Math.sqrt(ax*ax)+az*az*180/Math.PI)+ctx.accelXError;const accelYAngle=Math.atan(-ax/Math.sqrt(ay*ay)+az*az*180/Math.PI)+ctx.accelYError;return{ax,ay,az,roll:accelXAngle,pitch:accelYAngle}};if(Array.isArray(data.timestamp)){result=data.timestamp.map((v2,i)=>{return apass(v2,data.ax[i],data.ay[i],data.az[i])})}else result=apass(data.timestamp,data.ax,data.ay,data.az)}if(data.gx){let gpass=(timestamp,gx,gy,gz)=>{const elapsed=timestamp-ctx.lastGyroTime;ctx.lastGyroTime=timestamp;gx=gx*ctx.gyroConstant+ctx.gyroXError;gy=gy*ctx.gyroConstant+ctx.gyroYError;gz=gz*ctx.gyroConstant+ctx.gyroZError;ctx.gyroXAngle+=gx*elapsed;ctx.gyroYAngle+=gy*elapsed;ctx.gyroZAngle+=gz*elapsed;return{gx,gy,gz,roll:ctx.gyroXAngle,pitch:ctx.gyroYAngle,yaw:ctx.gyroZAngle}};let res;if(Array.isArray(data.timestamp)){res=data.timestamp.map((v2,i)=>{if(result){let r=gpass(v2,data.gx[i],data.gy[i],data.gz[i]);result.roll=result.roll*.04+r.roll*.96;result.pitch=result.pitch*.04+r.pitch*.96;result.yaw=res.yaw}else return gpass(v2,data.gx[i],data.gy[i],data.gz[i])});if(!result)result=res}else{res=gpass(data.timestamp,data.gx,data.gy,data.gz);if(result){result.roll=result.roll*.04+res.roll*.96;result.pitch=result.pitch*.04+res.pitch*.96;result.yaw=res.yaw}else result=res}}else if(ctx.gyroXAngle||ctx.gyroYAngle||ctx.gyroZAngle){result.roll=result.roll*.04+ctx.gyroXAngle*.96;result.pitch=result.pitch*.04+ctx.gyroYAngle*.96;result.yaw=ctx.gyroXAngle}if(result.ax){const setPositionOffset=(timestamp,result2)=>{const elapsed=timestamp-ctx.lastAccelTime;ctx.lastAccelTime=timestamp;ctx.px+=result2.ax*elapsed*elapsed*Math.cos(ctx.pitch*Math.PI*.005555555555);ctx.py+=result2.ay*elapsed*elapsed*Math.cos(ctx.roll*Math.PI*.005555555555);ctx.pz+=result2.az*elapsed*elapsed*Math.sin(ctx.pitch*Math.PI*.005555555555);result2.px=ctx.px;result2.py=ctx.py;result2.pz=ctx.pz;return result2};if(Array.isArray(data.timestamp)){data.timestamp.map((timestamp,i)=>{setPositionOffset(timestamp,result)})}else{setPositionOffset(data.timestamp,result)}}return result}};var Biquad=class{constructor(type,freq,sps,Q=1/Math.sqrt(2),dbGain=0){this.a0=0;this.a1=0;this.a2=0;this.b0=0;this.b1=0;this.b2=0;this.x1=0;this.x2=0;this.y1=0;this.y2=0;let types=["lowpass","highpass","bandpass","notch","peak","lowshelf","highshelf"];if(types.indexOf(type)<0){console.error("Valid types: 'lowpass','highpass','bandpass','notch','peak','lowshelf','highshelf'");return}this.type=type;this.freq=freq;this.sps=sps;this.Q=Q;this.dbGain=dbGain;let A2=Math.pow(10,dbGain/40);let omega=2*Math.PI*freq/sps;let sn=Math.sin(omega);let cs=Math.cos(omega);let alpha=sn/(2*Q);let beta=Math.sqrt(A2+A2);this[type](A2,sn,cs,alpha,beta);this.b0/=this.a0;this.b1/=this.a0;this.b2/=this.a0;this.a1/=this.a0;this.a2/=this.a0}lowpass(A2,sn,cs,alpha,beta){this.b0=(1-cs)*.5;this.b1=1-cs;this.b2=(1-cs)*.5;this.a0=1+alpha;this.a1=-2*cs;this.a2=1-alpha}highpass(A2,sn,cs,alpha,beta){this.b0=(1+cs)*.5;this.b1=-(1+cs);this.b2=(1+cs)*.5;this.a0=1+alpha;this.a1=-2*cs;this.a2=1-alpha}bandpass(A2,sn,cs,alpha,beta){this.b0=alpha;this.b1=0;this.b2=-alpha;this.a0=1+alpha;this.a1=-2*cs;this.a2=1-alpha}notch(A2,sn,cs,alpha,beta){this.b0=1;this.b1=-2*cs;this.b2=1;this.a0=1+alpha;this.a1=-2*cs;this.a2=1-alpha}peak(A2,sn,cs,alpha,beta){this.b0=1+alpha*A2;this.b1=-2*cs;this.b2=1-alpha*A2;this.a0=1+alpha/A2;this.a1=-2*cs;this.a2=1-alpha/A2}lowshelf(A2,sn,cs,alpha,beta){this.b0=A2*(A2+1-(A2-1)*cs+beta*sn);this.b1=2*A2*(A2-1-(A2+1)*cs);this.b2=A2*(A2+1-(A2-1)*cs-beta*sn);this.a0=A2+1+(A2+1)*cs+beta*sn;this.a1=2*(A2-1+(A2+1)*cs);this.a2=A2+1+(A2-1)*cs-beta*sn}highshelf(A2,sn,cs,alpha,beta){this.b0=A2*(A2+1+(A2-1)*cs+beta*sn);this.b1=2*A2*(A2-1+(A2+1)*cs);this.b2=A2*(A2+1-(A2-1)*cs-beta*sn);this.a0=A2+1-(A2+1)*cs-beta*sn;this.a1=2*(A2-1-(A2+1)*cs);this.a2=A2+1-(A2-1)*cs-beta*sn}applyFilter(signal_step){let y2=this.b0*signal_step+this.b1*this.x1+this.b2*this.x2-this.a1*this.y1-this.a2*this.y2;this.x2=this.x1;this.x1=signal_step;this.y2=this.y1;this.y1=y2;return y2}zResult(freq){try{let phi=Math.pow(Math.sin(Math.PI*freq*2/(2*this.sps)),2);let result=(Math.pow(this.b0+this.b1+this.b2,2)-4*(this.b0*this.b1+4*this.b0*this.b2+this.b1*this.b2)*phi+16*this.b0*this.b2*phi*phi)/(Math.pow(1+this.a1+this.a2,2)-4*(this.a1+4*this.a2+this.a1*this.a2)*phi+16*this.a2*phi*phi);return result}catch(err){return-200}}static calcCenterFrequency(freqStart,freqEnd){return(freqStart+freqEnd)/2}static calcBandwidth(freqStart,freqEnd){return freqEnd-this.calcCenterFrequency(freqStart,freqEnd)}static calcBandpassQ(frequency,bandwidth,resonance=Math.pow(10,Math.floor(Math.log10(frequency)))){let Q=resonance*Math.sqrt((frequency-bandwidth)*(frequency+bandwidth))/(2*bandwidth);return Q}static calcNotchQ(frequency,bandwidth,resonance=Math.pow(10,Math.floor(Math.log10(frequency)))){let Q=resonance*frequency*bandwidth/Math.sqrt((frequency-bandwidth)*(frequency+bandwidth));return Q}};var beat_detect={structs:{refdata:[],lowpass:void 0,smoothed:[],timestamp:[],peaks:[],valleys:[],peak_distances:[],valley_distances:[],beats:[],lastPeak:0,lastValley:0,sps:100,maxFreq:4,limit:10},oncreate:context=>{if(!context.lowpass){let freq=context.maxFreq;if(!freq)freq=1;if(freq>1)freq*=.5;context.lowpass=new Biquad("lowpass",context.maxFreq,context.sps);context.peakFinderWindow=Math.floor(context.sps/context.maxFreq);if(context.peakFinderWindow%2===0)context.peakFinderWindow+=1;if(context.peakFinderWindow<5)context.peakFinderWindow=5;context.midpoint=Math.round(context.peakFinderWindow*.5)}},ondata:(context,data)=>{if(!("red"in data)&&!("heg"in data)&&!("raw"in data))return void 0;let refdata=data.red?data.red:data.heg?data.heg:data.raw;if(!("timestamp"in data)){if(Array.isArray(refdata)){let now=Date.now();let len;if(refdata)len=refdata.length;let toInterp=[now-refdata.length*context.sps*1e3,now];data.timestamp=Math2.upsample(toInterp,refdata.length)}else{data.timestamp=Date.now()}}let pass=(amplitude,timestamp)=>{if(amplitude){context.refdata.push(amplitude)}context.timestamp.push(timestamp);let beat;if(context.refdata.length>context.peakFinderWindow){context.refdata.shift();context.timestamp.shift()}context.smoothed.push(context.lowpass.applyFilter(context.refdata[context.refdata.length-1]));if(context.smoothed.length>context.peakFinderWindow){context.smoothed.shift()}if(context.smoothed.length===context.peakFinderWindow){if(Math2.isExtrema(context.smoothed,"valley")){context.valleys.push({value:context.smoothed[context.smoothed.length-context.midpoint?context.midpoint:1],timestamp:context.timestamp[context.timestamp.length-context.midpoint?context.midpoint:1]})}else if(Math2.isExtrema(context.smoothed,"peak")){context.peaks.push({value:context.smoothed[context.smoothed.length-context.midpoint?context.midpoint:1],timestamp:context.timestamp[context.timestamp.length-context.midpoint?context.midpoint:1]})}if(context.valleys.length>2&&context.peaks.length>2){if(context.valleys[context.valleys.length-1].timestamp<context.peaks[context.peaks.length-2].timestamp)context.peaks.splice(context.peaks.length-1);if(context.peaks[context.peaks.length-1].timestamp<context.valleys[context.valleys.length-2].timestamp)context.valleys.splice(context.valleys.length-1);context.valley_distances.push({distance:context.valleys[context.valleys.length-1].timestamp-context.valleys[context.valleys.length-2].timestamp,timestamp:context.valleys[context.valleys.length-1].timestamp,peak0:context.valleys[context.valleys.length-1].value,peak1:context.valleys[context.valleys.length-2].value});context.peak_distances.push({distance:context.peaks[context.peaks.length-1].timestamp-context.peaks[context.peaks.length-2].timestamp,timestamp:context.peaks[context.peaks.length-1].timestamp,peak0:context.peaks[context.peaks.length-1].value,peak1:context.peaks[context.peaks.length-2].value});if(context.peak_distances.length>1&&context.valley_distances.length>1){if(context.lastPeak<context.peaks[context.peaks.length-1].timestamp&&context.lastValley<context.peaks[context.peaks.length-1].timestamp){if(context.valley_distances[context.valley_distances.length-1].timestamp>context.peak_distances[context.peak_distances.length-1].timestamp){let bpm,change=0;if(context.beats.length<1){bpm=60/(5e-4*(context.peak_distances[context.peak_distances.length-1].distance+context.valley_distances[context.valley_distances.length-1].distance))}else if(context.beats[context.beats.length-1].timestamp!==context.peak_distances[context.peak_distances.length-1].timestamp){bpm=60/(5e-4*(context.peak_distances[context.peak_distances.length-1].dt+context.valley_distances[context.valley_distances.length-1].dt));change=Math.abs(bpm-context.beats[context.beats.length-1].bpm)}beat={timestamp:context.peak_distances[context.peak_distances.length-1].timestamp,change,bpm,height0:context.peak_distances[context.peak_distances.length-1].peak0-context.valley_distances[context.valley_distances.length-1].peak0,height1:context.peak_distances[context.peak_distances.length-1].peak1-context.valley_distances[context.valley_distances.length-1].peak1};context.beats.push(beat);context.lastPeak=context.peaks[context.peaks.length-1].timestamp;context.lastValley=context.peaks[context.peaks.length-1].timestamp}else{let bpm,change=0;if(context.beats.length<2){bpm=60/(5e-4*(context.peak_distances[context.peak_distances.length-2].distance+context.valley_distances[context.valley_distances.length-2].distance))}else if(context.beats[context.beats.length-1].timestamp!==context.peak_distances[context.peak_distances.length-2].timestamp){bpm=60/(5e-4*(context.peak_distances[context.peak_distances.length-2].distance+context.valley_distances[context.valley_distances.length-2].distance));change=Math.abs(bpm-context.beats[context.beats.length-2].bpm)}beat={timestamp:context.peak_distances[context.peak_distances.length-2].timestamp,change,bpm,height0:context.peak_distances[context.peak_distances.length-2].peak0-context.valley_distances[context.valley_distances.length-2].peak0,height1:context.peak_distances[context.peak_distances.length-2].peak1-context.valley_distances[context.valley_distances.length-2].peak1};context.beats.push(beat);context.lastPeak=context.peaks[context.peaks.length-1].timestamp;context.lastValley=context.peaks[context.peaks.length-1].timestamp}}}if(context.peaks.length>context.limit){context.peaks.shift()}if(context.valleys.length>context.limit){context.valleys.shift()}if(context.peak_distances.length>context.limit){context.peak_distances.shift()}if(context.valley_distances.length>context.limit){context.valley_distances.shift()}if(context.beats.length>context.limit){context.beats.shift()}}}return beat};if(data.red){if("ir"in data&&!Array.isArray(data.red))return pass(data.red+data.ir,data.timestamp);let result;if(data.ir)data.red.map((v2,i)=>{return pass(v2+data.ir[i],data.timestamp[i])});else data.red.map((v2,i)=>{return pass(v2,data.timestamp[i])});return result}else if(data.raw){if(!Array.isArray(data.raw))return pass(data.raw,data.timestamp);let result=data.raw.map((v2,i)=>{return pass(v2,data.timestamp[i])});return result}else if(Array.isArray(data.heg)){if(!Array.isArray(data.heg))return pass(data.heg,data.timestamp);let result=data.heg.map((v2,i)=>{return pass(v2,data.timestamp[i])});return result}}};var blink_detect={structs:{sps:250,intervals:{},watch:["0"],tolerance:.2},oncreate:ctx=>{ctx.watch.forEach(ch=>ctx.intervals[ch]={lowpass:new Biquad("lowpass",20,ctx.sps),filtered:[],averaged:[]})},ondata:(ctx,data)=>{let checkCt=5;let averageCt=50;let found={};let passed=false;let pass=(key,n)=>{let next=ctx.intervals[key].lowpass.applyFilter(n);ctx.intervals[key].filtered.push(next);ctx.intervals[key].averaged.push(next);if(ctx.intervals[key].filtered.length>checkCt){if(ctx.intervals[key].averaged.length>averageCt){ctx.intervals[key].averaged.splice(0,checkCt);let mean=Math2.mean(ctx.intervals[key].averaged);if(Math.abs(Math.min(...ctx.intervals[key].filtered))>Math.abs(mean)+ctx.tolerance){ctx.intervals[key].filtered.length=0;passed=true;found[key]=true}}else ctx.intervals[key].filtered.shift()}};for(const key in ctx.intervals){if(data[key]){if(Array.isArray(data[key])){data[key].forEach(n=>{pass(key,n)})}else if(typeof data[key]==="number")pass(key,data[key])}}if(passed)return found}};var _ArrayManip=class{constructor(){this.recursivelyAssign=(target,obj)=>{for(const key in obj){if(typeof obj[key]==="object"){if(typeof target[key]==="object")this.recursivelyAssign(target[key],obj[key]);else target[key]=this.recursivelyAssign({},obj[key])}else target[key]=obj[key]}return target}}static autoscale(array,lineIdx=0,nLines=1,centerZero=false,ymin,ymax,clamp){if(array?.length===0)return array;let max=ymax?ymax:Math.max(...array);let min=ymin?ymin:Math.min(...array);let _lines=1/nLines;let scalar=1;if(centerZero){let absmax=Math.max(Math.abs(min),Math.abs(max));if(absmax!==0)scalar=_lines/absmax;return array.map(y2=>{if(clamp){if(y2<min)y2=min;if(y2>max)y2=max}return y2*scalar+(_lines*(lineIdx+1)*2-1-_lines)})}else{if(max===min){if(max!==0){scalar=_lines/max}else if(min!==0){scalar=_lines/Math.abs(min)}}else scalar=_lines/(max-min);return array.map(y2=>{if(clamp){if(y2<min)y2=min;if(y2>max)y2=max}return 2*((y2-min)*scalar-1/(2*nLines))+(_lines*(lineIdx+1)*2-1-_lines)})}}static genTimestamps(ct,sps){let now=Date.now();let toInterp=[now-ct*1e3/sps,now];return _ArrayManip.upsample(toInterp,ct)}static absmax(array){return Math.max(Math.abs(Math.min(...array)),Math.max(...array))}static downsample(array,fitCount,scalar=1){if(array.length>fitCount){let output=new Array(fitCount);let incr=array.length/fitCount;let lastIdx=array.length-1;let last=0;let counter=0;for(let i=incr;i<array.length;i+=incr){let rounded=Math.round(i);if(rounded>lastIdx)rounded=lastIdx;for(let j=last;j<rounded;j++){output[counter]+=array[j]}output[counter]/=(rounded-last)*scalar;counter++;last=rounded}return output}else return array}static upsample(array,fitCount,scalar=1){var linearInterpolate=function(before2,after2,atPoint2){return(before2+(after2-before2)*atPoint2)*scalar};var newData=new Array(fitCount);var springFactor=(array.length-1)/(fitCount-1);newData[0]=array[0];for(var i=1;i<fitCount-1;i++){var tmp=i*springFactor;var before=Math.floor(tmp);var after=Math.ceil(tmp);var atPoint=tmp-before;newData[i]=linearInterpolate(array[before],array[after],atPoint)}newData[fitCount-1]=array[array.length-1];return newData}static interpolate(array,fitCount,scalar=1){if(array.length>fitCount){return _ArrayManip.downsample(array,fitCount,scalar)}else if(array.length<fitCount){return _ArrayManip.upsample(array,fitCount,scalar)}return array}static HSLToRGB(h,s,l,scalar=255){s/=100;l/=100;let c=(1-Math.abs(2*l-1))*s,x3=c*(1-Math.abs(h/60%2-1)),m=l-c/2,r=0,g=0,b2=0;if(0<=h&&h<60){r=c;g=x3;b2=0}else if(60<=h&&h<120){r=x3;g=c;b2=0}else if(120<=h&&h<180){r=0;g=c;b2=x3}else if(180<=h&&h<240){r=0;g=x3;b2=c}else if(240<=h&&h<300){r=x3;g=0;b2=c}else if(300<=h&&h<360){r=c;g=0;b2=x3}r=(r+m)*scalar;g=(g+m)*scalar;b2=(b2+m)*scalar;return[r,g,b2]}static circularBuffer(arr,newEntries){if(newEntries.length<arr.length){let slice=arr.slice(newEntries.length);let len=arr.length;arr.splice(0,len,...slice,...newEntries)}else if(newEntries.length>arr.length){let len=arr.length;arr.splice(0,len,newEntries.slice(len-newEntries.length))}else{arr.splice(0,arr.length,...newEntries)}return arr}static reformatData(data,key){if(Array.isArray(data)){if(Array.isArray(data[0])){let d2={};data.forEach((arr,i)=>{d2[i]=arr});data=d2;if(isNaN(data[0][0]))return void 0}else if(key){data={[key]:data};if(isNaN(data[key][0]))return void 0}else{data={0:data};if(isNaN(data[0][0]))return void 0}}else if(typeof data==="object"){for(const key2 in data){if(typeof data[key2]==="number")data[key2]=[data[key2]];else if(data[key2]?.values){if(typeof data[key2].values==="number")data[key2].values=[data[key2].values]}if(isNaN(data[key2][0]))return void 0}}else if(typeof data==="string"){let split;if(data.includes("\r\n")){let lines=data.split("\r\n");data={};lines.forEach((l,j)=>{if(l.includes("	")){split=l.split("	")}else if(l.includes(",")){split=l.split(",")}else if(l.includes("|")){split=l.split("|")}if(Array.isArray(split)){split.forEach((val,i)=>{if(val.includes(":")){let[key2,v2]=val.split(":");let fl=parseFloat(v2);if(fl)data[key2]=[fl];else return void 0}else{let fl=parseFloat(val);if(fl)data[i]=[fl];else return void 0}})}})}else if(data.includes("	")){split=data.split("	")}else if(data.includes(",")){split=data.split(",")}else if(data.includes("|")){split=data.split("|")}data={};if(Array.isArray(split)){split.forEach((val,i)=>{if(val.includes(":")){let[key2,v2]=val.split(":");let fl=parseFloat(v2);if(fl)data[key2]=[fl];else return void 0}else{let fl=parseFloat(val);if(fl)data[i]=[fl];else return void 0}})}}else if(typeof data==="number"){if(key)data={[key]:[data]};else data={0:[data]}}return data}static padTime(data,lastValue,time,targetFit){let slopeIncr=(data[0]-lastValue)/time/targetFit;let padded=[...new Array(targetFit-data.length).map((_2,i)=>lastValue+slopeIncr*(i+1)),...data];return padded}static interpolateForTime(data,time,targetSPS){return _ArrayManip.interpolate(data,Math.ceil(targetSPS*time))}isTypedArray(x3){return ArrayBuffer.isView(x3)&&Object.prototype.toString.call(x3)!=="[object DataView]"}spliceTypedArray(arr,start,end){let s=arr.subarray(0,start);let e;if(end){e=arr.subarray(end+1)}let n;if(s.length>0||e?.length>0)n=new arr.constructor(s.length+e.length);if(s.length>0)n.set(s);if(e&&e.length>0)n.set(e,s.length);return n}};var ArrayManip=_ArrayManip;ArrayManip.bufferValues=(objects,property,keys,buffer)=>{if(!Array.isArray(keys)&&typeof keys==="object")keys=Object.keys(keys);if(!buffer){let object_keys=Object.keys(objects);if(keys)buffer=new Float32Array(object_keys.length*keys.length);else{if(typeof objects[object_keys[0]][property]==="object"){keys=Object.keys(objects[object_keys[0]][property]);buffer=new Float32Array(object_keys.length*keys.length)}else buffer=new Float32Array(object_keys.length)}}let i=0;for(const key in objects){if(objects[key][property]){if(keys){for(let j=0;j<keys.length;j++){buffer[i]=objects[key][property][keys[j]];i++}}else{buffer[i]=objects[key][property];i++}}}return buffer};var rechk=/^([<>])?(([1-9]\d*)?([xcbB?hHiIfdsp]))*$/;var refmt=/([1-9]\d*)?([xcbB?hHiIfdsp])/g;var str=(v2,o,c)=>String.fromCharCode(...new Uint8Array(v2.buffer,v2.byteOffset+o,c));var rts=(v2,o,c,s)=>new Uint8Array(v2.buffer,v2.byteOffset+o,c).set(s.split("").map(str2=>str2.charCodeAt(0)));var pst=(v2,o,c)=>str(v2,o+1,Math.min(v2.getUint8(o),c-1));var tsp=(v2,o,c,s)=>{v2.setUint8(o,s.length);rts(v2,o+1,c-1,s)};var lut=le=>({x:c=>[1,c,0],c:c=>[c,1,o=>({u:v2=>str(v2,o,1),p:(v2,c2)=>rts(v2,o,1,c2)})],"?":c=>[c,1,o=>({u:v2=>Boolean(v2.getUint8(o)),p:(v2,B)=>v2.setUint8(o,B)})],b:c=>[c,1,o=>({u:v2=>v2.getInt8(o),p:(v2,b2)=>v2.setInt8(o,b2)})],B:c=>[c,1,o=>({u:v2=>v2.getUint8(o),p:(v2,B)=>v2.setUint8(o,B)})],h:c=>[c,2,o=>({u:v2=>v2.getInt16(o,le),p:(v2,h)=>v2.setInt16(o,h,le)})],H:c=>[c,2,o=>({u:v2=>v2.getUint16(o,le),p:(v2,H)=>v2.setUint16(o,H,le)})],i:c=>[c,4,o=>({u:v2=>v2.getInt32(o,le),p:(v2,i)=>v2.setInt32(o,i,le)})],I:c=>[c,4,o=>({u:v2=>v2.getUint32(o,le),p:(v2,I)=>v2.setUint32(o,I,le)})],f:c=>[c,4,o=>({u:v2=>v2.getFloat32(o,le),p:(v2,f)=>v2.setFloat32(o,f,le)})],d:c=>[c,8,o=>({u:v2=>v2.getFloat64(o,le),p:(v2,d2)=>v2.setFloat64(o,d2,le)})],s:c=>[1,c,o=>({u:v2=>str(v2,o,c),p:(v2,s)=>rts(v2,o,c,s.slice(0,c))})],p:c=>[1,c,o=>({u:v2=>pst(v2,o,c),p:(v2,s)=>tsp(v2,o,c,s.slice(0,c-1))})]});var errbuf=new RangeError("Structure larger than remaining buffer");var errval=new RangeError("Not enough values for structure");var _ByteParser=class extends ArrayManip{static toDataView(value){if(!(value instanceof DataView)){if(typeof value==="string"&&parseInt(value))value=parseInt(value);if(typeof value==="string"){let enc=new TextEncoder;let hascodes={};for(const code in _ByteParser.codes){while(value.indexOf(code)>-1){let idx=value.indexOf(code);value=value.replace(code,"");hascodes[idx]=code}}let encoded=Array.from(enc.encode(value));for(const key in hascodes){encoded.splice(parseInt(key),0,_ByteParser.codes[hascodes[key]])}value=new DataView(new Uint8Array(encoded).buffer)}else if(typeof value==="number"){let tmp=value;if(value<256){value=new DataView(new ArrayBuffer(1));value.setUint8(0,tmp)}else if(value<65536){value=new DataView(new ArrayBuffer(2));value.setInt16(0,tmp)}else{value=new DataView(new ArrayBuffer(4));value.setUint32(0,tmp)}}else if(value instanceof ArrayBuffer||typeof SharedArrayBuffer!=="undefined"&&value instanceof SharedArrayBuffer){value=new DataView(value)}else if(Array.isArray(value)){value=new DataView(Uint8Array.from(value).buffer)}else if(typeof value==="object"){value=new TextEncoder().encode(JSON.stringify(value))}}return value}static searchBuffer(buffer,searchString,limit){var needle=searchString;var haystack=buffer;var search=_ByteParser.boyerMoore(needle);var skip=search.byteLength;var indices=[];for(var i=search(haystack);i!==-1;i=search(haystack,i+skip)){indices.push(i);if(limit){if(indices.length>=limit)break}}return indices}static bytesToInt16(x0,x1){let int16=(255&x0)<<8|255&x1;if((int16&32768)>0){int16|=4294901760}else{int16&=65535}return int16}static bytesToUInt16(x0,x1){return x0*256+x1}static Uint16ToBytes(y2){return[y2&255,y2>>8&255]}static bytesToInt24(x0,x1,x22){let int24=(255&x0)<<16|(255&x1)<<8|255&x22;if((int24&8388608)>0){int24|=4278190080}else{int24&=16777215}return int24}static bytesToUInt24(x0,x1,x22){return x0*65536+x1*256+x22}static Uint24ToBytes(y2){return[y2&255,y2>>8&255,y2>>16&255]}static bytesToInt32(x0,x1,x22,x3){let int32=(255&x0)<<24|(255&x1)<<16|(255&x22)<<8|255&x3;if((int32&2147483648)>0){int32|=0}else{int32&=4294967295}return int32}static bytesToUInt32(x0,x1,x22,x3){return x0*16777216+x1*65536+x22*256+x3}static Uint32ToBytes(y2){return[y2&255,y2>>8&255,y2>>16&255,y2>>24&255]}static get2sCompliment(val,nbits){if(val>4294967296)return null;return val<<32-nbits>>32-nbits}static getSignedInt(...args){let pos=0;function getInt(size){var value=0;var first=true;while(size--){if(first){let byte=args[pos++];value+=byte&127;if(byte&128){value-=128}first=false}else{value*=256;value+=args[pos++]}}return value}return getInt(args.length)}static asUint8Array(input){if(input instanceof Uint8Array){return input}else if(typeof input==="string"){var arr=new Uint8Array(input.length);for(var i=0;i<input.length;i++){var c=input.charCodeAt(i);if(c>127){throw new TypeError("Only ASCII patterns are supported")}arr[i]=c}return arr}else{return new Uint8Array(input)}}static boyerMoore(patternBuffer){var pattern=_ByteParser.asUint8Array(patternBuffer);var M2=pattern.length;if(M2===0){throw new TypeError("patternBuffer must be at least 1 byte long")}var R2=256;var rightmost_positions=new Int32Array(R2);for(var c=0;c<R2;c++){rightmost_positions[c]=-1}for(var j=0;j<M2;j++){rightmost_positions[pattern[j]]=j}var boyerMooreSearch=(txtBuffer,start,end)=>{var txt=_ByteParser.asUint8Array(txtBuffer);if(start===void 0)start=0;if(end===void 0)end=txt.length;var pat=pattern;var right=rightmost_positions;var lastIndex=end-pat.length;var lastPatIndex=pat.length-1;var skip;for(var i=start;i<=lastIndex;i+=skip){skip=0;for(var j2=lastPatIndex;j2>=0;j2--){var c2=txt[i+j2];if(pat[j2]!==c2){skip=Math.max(1,j2-right[c2]);break}}if(skip===0){return i}}return-1};boyerMooreSearch.byteLength=pattern.byteLength;return boyerMooreSearch}static struct(format){let fns=[],size=0,m=rechk.exec(format);if(!m){throw new RangeError("Invalid format string")}const t=lut("<"===m[1]),lu=(n,c)=>t[c](n?parseInt(n,10):1);while(m=refmt.exec(format)){((r,s,f)=>{for(let i=0;i<r;++i,size+=s){if(f){fns.push(f(size))}}})(...lu(...m.slice(1)))}const unpack_from=(arrb,offs)=>{if(arrb.byteLength<(offs|0)+size){throw errbuf}let v2=new DataView(arrb,offs|0);return fns.map(f=>f.u(v2))};const pack_into=(arrb,offs,...values)=>{if(values.length<fns.length){throw errval}if(arrb.byteLength<offs+size){throw errbuf}const v2=new DataView(arrb,offs);new Uint8Array(arrb,offs,size).fill(0);fns.forEach((f,i)=>f.p(v2,values[i]))};const pack=(...values)=>{let b2=new ArrayBuffer(size);pack_into(b2,0,...values);return b2};const unpack=arrb=>unpack_from(arrb,0);function*iter_unpack(arrb){for(let offs=0;offs+size<=arrb.byteLength;offs+=size){yield unpack_from(arrb,offs)}}return Object.freeze({unpack,pack,unpack_from,pack_into,iter_unpack,format,size})}};var ByteParser=_ByteParser;ByteParser.codes={"\\n":10,"\\r":13,"\\t":9,"\\s":32,"\\b":8,"\\f":12,"\\":92};var rms={structs:{sps:250,nSec:1,watch:["0","1","2","3"],data:{},rms:{}},ondata:(ctx,data)=>{ctx.watch.forEach(key=>{if(data[key]){if(!ctx.data[key]){if(Array.isArray(data[key])){ctx.data[key]=new Array(Math.floor(ctx.sps*ctx.nSec)).fill(data[key][0])}else ctx.data[key]=new Array(Math.floor(ctx.sps*ctx.nSec)).fill(data[key])}ByteParser.circularBuffer(ctx.data[key],data[key])}});if(data.timestamp){if(Array.isArray(data.timestamp)){ctx.rms.timestamp=data.timestamp[data.timestamp.length-1]}else ctx.rms.timestamp=data.timestamp}else ctx.rms.timestamp=Date.now();return new Promise(async res=>{await Promise.all(ctx.watch.map(async key=>{if(ctx.data[key])ctx.rms[key]=Math.sqrt(Math.abs(ctx.data[key].reduce((p,v2,i)=>p+v2*v2)/ctx.data[key].length));else delete ctx.rms[key]}));res(ctx.rms)})}};var circularBuffer2d={structs:{bufferSize:250,watch:["0","1","2","3"],data:{},blocking:false},oncreate:ctx=>{for(const key in ctx.watch){ctx.data[key]=new Array(ctx.bufferSize).fill(0)}},ondata:(ctx,data)=>{let buffer2d=[];ctx.watch.forEach(key=>{if(data[key]){ByteParser.circularBuffer(ctx.data[key],data[key]);buffer2d.push(ctx.data[key])}});return buffer2d}};Object.assign(algorithms,{beat_detect,accel_gyro,heartrate:beat_detect,breath:Object.assign({},beat_detect),blink_detect,rms,circularBuffer2d});algorithms["breath"].structs=JSON.parse(JSON.stringify(algorithms["breath"].structs));algorithms["breath"].structs.maxFreq=.2;})();
